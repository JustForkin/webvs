window["Webvs"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 142);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var flow_1 = __webpack_require__(118);
var map_1 = __webpack_require__(13);
var partialRight_1 = __webpack_require__(125);
var takeRight_1 = __webpack_require__(83);
/**
 * A No-Op function
 */
// tslint:disable-next-line:no-empty
function noop() { }
exports.noop = noop;
/**
 * Checks if an object contains the required properties. Throws an error
 * for missing options
 * @param options the options to be checked
 * @param requiredOptions set of required options
 */
function checkRequiredOptions(options, requiredOptions) {
    for (var _i = 0, requiredOptions_1 = requiredOptions; _i < requiredOptions_1.length; _i++) {
        var optionName = requiredOptions_1[_i];
        if (!(optionName in options)) {
            throw new Error("Required option " + optionName + " not found");
        }
    }
}
exports.checkRequiredOptions = checkRequiredOptions;
/**
 * Returns a floating point value representation of a number
 * embeddable in glsl shader code
 * @param val value to be converted
 */
function glslFloatRepr(val) {
    return val + (parseFloat(val) % 1 === 0 ? ".0" : "");
}
exports.glslFloatRepr = glslFloatRepr;
/**
 * Checks whether the argument is a Color or not
 * @param color color to be checked
 */
function isColor(color) {
    return Array.isArray(color) && color.length === 3;
}
/**
 * Parse css color string #RRGGBB or rgb(r, g, b)
 * @param color the color value to be parsed
 */
function parseColor(color) {
    if (isColor(color)) {
        return color;
    }
    else {
        color = color.toLowerCase();
        var match = color.match(/^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/);
        if (match) {
            return flow_1["default"]([
                partialRight_1["default"](takeRight_1["default"], 3),
                partialRight_1["default"](map_1["default"], function (channel) {
                    return parseInt(channel, 16);
                }),
            ])(match);
        }
        match = color.match(/^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/);
        if (match) {
            return flow_1["default"]([
                partialRight_1["default"](takeRight_1["default"], 3),
                partialRight_1["default"](map_1["default"], function (channel) {
                    return Math.min(parseInt(channel, 10), 255);
                }),
            ])(match);
        }
    }
    throw new Error("Invalid Color Format");
}
exports.parseColor = parseColor;
/**
 * Parse css color string and return normalizes Color value
 * @param color the color value to be parsed
 */
function parseColorNorm(color) {
    return map_1["default"](parseColor(color), function (value) { return value / 255; });
}
exports.parseColorNorm = parseColorNorm;
/**
 * Parses shader error message and displays readable information
 * @param src source of the shader
 * @param error error message
 */
function logShaderError(src, error) {
    var lines = src.split("\n");
    var ndigits = lines.length.toString().length;
    var errorPosMatch = error.match(/(\d+):(\d+)/);
    var errorPos;
    if (errorPosMatch) {
        errorPos = [parseInt(errorPosMatch[1], 10), parseInt(errorPosMatch[2], 10)];
    }
    var numberedLines = map_1["default"](lines, function (line, index) {
        var i;
        var lineNumber = (index + 1) + "";
        for (i = 0; i < (ndigits - lineNumber.length); i++) {
            lineNumber = "0" + lineNumber;
        }
        var errorIndicator = "";
        if (errorPos && errorPos[1] === index + 1) {
            var indent = "";
            for (i = 0; i < errorPos[0] + ndigits + 2; i++) {
                indent += " ";
            }
            errorIndicator = "\n" + indent + "^\n" + indent + error;
        }
        return lineNumber + ": " + line + errorIndicator;
    }).join("\n");
    // tslint:disable-next-line:no-console
    console.log("Shader Error : \n" + numberedLines);
}
exports.logShaderError = logShaderError;
/**
 * Blend Modes
 */
var BlendMode;
(function (BlendMode) {
    BlendMode[BlendMode["REPLACE"] = 1] = "REPLACE";
    BlendMode[BlendMode["MAXIMUM"] = 2] = "MAXIMUM";
    BlendMode[BlendMode["AVERAGE"] = 3] = "AVERAGE";
    BlendMode[BlendMode["ADDITIVE"] = 4] = "ADDITIVE";
    BlendMode[BlendMode["SUBTRACTIVE1"] = 5] = "SUBTRACTIVE1";
    BlendMode[BlendMode["SUBTRACTIVE2"] = 6] = "SUBTRACTIVE2";
    BlendMode[BlendMode["MULTIPLY"] = 7] = "MULTIPLY";
    BlendMode[BlendMode["MULTIPLY2"] = 8] = "MULTIPLY2";
    BlendMode[BlendMode["ADJUSTABLE"] = 9] = "ADJUSTABLE";
    BlendMode[BlendMode["ALPHA"] = 10] = "ALPHA";
})(BlendMode = exports.BlendMode || (exports.BlendMode = {}));
/**
 * Channels
 */
var Channels;
(function (Channels) {
    Channels[Channels["CENTER"] = 0] = "CENTER";
    Channels[Channels["LEFT"] = 1] = "LEFT";
    Channels[Channels["RIGHT"] = 2] = "RIGHT";
})(Channels = exports.Channels || (exports.Channels = {}));
/**
 * Source
 */
var Source;
(function (Source) {
    Source[Source["SPECTRUM"] = 1] = "SPECTRUM";
    Source[Source["WAVEFORM"] = 2] = "WAVEFORM";
})(Source = exports.Source || (exports.Source = {}));
/**
 * Returns a random string of given length
 * @param count number of characters
 * @param chars character set to choose from
 */
function randString(count, chars) {
    var randStr = [];
    chars = chars || "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (var i = 0; i < count; i++) {
        randStr.push(chars.charAt(Math.floor(Math.random() * chars.length)));
    }
    return randStr.join("");
}
exports.randString = randString;
/**
 * WebGL data types
 */
var WebGLVarType;
(function (WebGLVarType) {
    WebGLVarType["TEXTURE2D"] = "texture2D";
    WebGLVarType["_1F"] = "1f";
    WebGLVarType["_2F"] = "2f";
    WebGLVarType["_3F"] = "3f";
    WebGLVarType["_4F"] = "4f";
    WebGLVarType["_1I"] = "1i";
    WebGLVarType["_2I"] = "2i";
    WebGLVarType["_3I"] = "3i";
    WebGLVarType["_4I"] = "4i";
    WebGLVarType["_1FV"] = "1fv";
    WebGLVarType["_2FV"] = "2fv";
    WebGLVarType["_3FV"] = "3fv";
    WebGLVarType["_4FV"] = "4fv";
    WebGLVarType["_1IV"] = "1iv";
    WebGLVarType["_2IV"] = "2iv";
    WebGLVarType["_3IV"] = "3iv";
    WebGLVarType["_4IV"] = "4iv";
})(WebGLVarType = exports.WebGLVarType || (exports.WebGLVarType = {}));
function isTypedArray(array) {
    return (array instanceof Int8Array ||
        array instanceof Uint8Array ||
        array instanceof Uint8ClampedArray ||
        array instanceof Int16Array ||
        array instanceof Uint16Array ||
        array instanceof Int32Array ||
        array instanceof Uint32Array ||
        array instanceof Float32Array ||
        array instanceof Float64Array);
}
exports.isTypedArray = isTypedArray;
/**
 * Clamp number between range
 * @param num number to clamp
 * @param min min value of the range
 * @param max max value of the range
 */
function clamp(num, min, max) {
    return Math.min(Math.max(num, min), max);
}
exports.clamp = clamp;
/**
 * Returns the value of property given its (dot separated) path in an object
 * @param obj object with the property
 * @param name name of the property
 */
function getProperty(obj, name) {
    if (typeof name === "string") {
        name = name.split(".");
    }
    var value = obj[name.shift()];
    if (value) {
        if (name.length > 0) {
            return getProperty(value, name);
        }
        else {
            return value;
        }
    }
}
exports.getProperty = getProperty;
/**
 * Sets a property, given its (dot separated) path in an object
 * @param obj the object in which the property is to be set
 * @param name name of the property
 * @param value value of the property
 */
function setProperty(obj, name, value) {
    if (typeof name === "string") {
        name = name.split(".");
    }
    var propertyName = name.shift();
    if (name.length === 0) {
        obj[propertyName] = value;
    }
    else {
        setProperty(obj[propertyName], name, value);
    }
}
exports.setProperty = setProperty;
/**
 * flattens array of strings to single string
 * @param value string or list of strings to be flattened
 * @param sep seprator to flatten the strings with
 */
function flatString(value, sep) {
    if (sep === void 0) { sep = "\n"; }
    if (typeof (value) === "string") {
        return value;
    }
    else {
        return value.join(sep);
    }
}
exports.flatString = flatString;


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/* harmony default export */ __webpack_exports__["default"] = (isArray);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var clone_1 = __webpack_require__(47);
var defaults_1 = __webpack_require__(24);
var flatten_1 = __webpack_require__(38);
var isEqual_1 = __webpack_require__(108);
var isUndefined_1 = __webpack_require__(110);
var omit_1 = __webpack_require__(220);
var uniqueId_1 = __webpack_require__(225);
var Model_1 = __webpack_require__(76);
/**
 * Base class for all Components.
 *
 * Webvs renders visualizations by layering different Components or effects
 * one after the other. Each Component type will have a different rendering
 * behaviour which can be configured through the component options. Some
 * components may have sub components, in which case the rendering of all
 * the subcomponents is modified/controlled in some manner by the parent.
 * eg. [[EffectList]], which renders a set of components into a separate
 * buffer which is then blended back into the main render.
 *
 * Options on components can be modified with a [[Model.set]] call. This
 * allows Components to respond to changes in options in real-time.
 * Eg: Changing colors, Code etc. This feature can be used to build
 * Live-Edit User Interfaces for presets development.
 */
var Component = /** @class */ (function (_super) {
    __extends(Component, _super);
    /**
     * Constructs new Component. Components are usually instantated by a [[Container]] component
     * or [[Main]] in the case of the root [[EffectList]].
     * @param main the main object that manages this component
     * @param parent the parent that manages this component
     * @param options the initial options for this component
     */
    function Component(main, parent, options) {
        var _this = _super.call(this) || this;
        _this.main = main;
        _this.parent = parent;
        _this.id = options.id; // TODO: check for id uniqueness
        if (!_this.id) {
            _this.id = uniqueId_1["default"](_this.constructor.componentName + "_");
        }
        _this.enabled = isUndefined_1["default"](options.enabled) ? true : options.enabled;
        _this.opts = omit_1["default"](options, ["id", "enabled"]);
        var defaultOptions = _this.constructor.defaultOptions;
        if (defaultOptions) {
            _this.opts = defaults_1["default"](_this.opts, defaultOptions);
        }
        _this.init();
        return _this;
    }
    /**
     * Returns the name of the component
     */
    Component.getComponentName = function () {
        return this.componentName;
    };
    /**
     * Returns a string tag that categorizes the component. e.g. trans, render
     */
    Component.getComponentTag = function () {
        return this.componentTag;
    };
    /**
     * Returns whether this component is enabled or not
     */
    Component.prototype.isEnabled = function () {
        return this.enabled;
    };
    /**
     * Returns the id of this component
     */
    Component.prototype.getId = function () {
        return this.id;
    };
    /**
     * Returns the last error. That raised an `error:*` event
     */
    Component.prototype.getLastError = function () {
        return this.lastError;
    };
    /**
     * Destroys and cleansup resources. Please override to
     * cleanup component specific resources.
     */
    Component.prototype.destroy = function () {
        this.stopListening();
    };
    /**
     * Sets the parent of this component
     * @param newParent the new parent of this component
     */
    Component.prototype.setParent = function (newParent) {
        this.parent = newParent;
    };
    /**
     * Returns the JSON representation of the component options.
     *
     * This value if passed into constructor will instantiate a component
     * that behaves the same as this component.
     */
    Component.prototype.toJSON = function () {
        var opts = clone_1["default"](this.opts);
        opts.id = this.id;
        opts.type = this.constructor.componentName;
        opts.enabled = this.enabled;
        return opts;
    };
    /**
     * returns a component options given name
     */
    Component.prototype.get = function (name) {
        if (name === "enabled") {
            return this.enabled;
        }
        else if (name === "id") {
            return this.id;
        }
        else {
            return this.opts[name];
        }
    };
    /**
     * Returns a `/` path to the component from the root.
     */
    Component.prototype.getPath = function () {
        if (!isUndefined_1["default"](this.parent) && !isUndefined_1["default"](this.id)) {
            return this.parent.getPath() + "/" + this.constructor.componentName + "#" + this.id;
        }
        else {
            return this.constructor.componentName + "#Main";
        }
    };
    Component.prototype.setAttribute = function (key, value, options) {
        var oldValue = this.get(key);
        if (key === "type" || isEqual_1["default"](value, oldValue)) {
            return false;
        }
        // set the property
        if (key === "enabled") {
            this.enabled = value;
        }
        else if (key === "id") {
            this.id = value;
        }
        else {
            this.opts[key] = value;
        }
        // call all onchange handlers
        // we just call these manually here no need to
        // go through event triggers
        var optUpdateHandlers = this.constructor.optUpdateHandlers;
        if (optUpdateHandlers) {
            try {
                var onChange = flatten_1["default"]([
                    optUpdateHandlers[key] || [],
                    optUpdateHandlers["*"] || [],
                ]);
                for (var _i = 0, onChange_1 = onChange; _i < onChange_1.length; _i++) {
                    var onChangeHandler = onChange_1[_i];
                    this[onChangeHandler].call(this, value, key, oldValue);
                }
            }
            catch (e) {
                // restore old value in case any of the onChange handlers fail
                if (key === "enabled") {
                    this.enabled = oldValue;
                }
                else if (key === "id") {
                    this.id = oldValue;
                }
                else {
                    this.opts[key] = oldValue;
                }
                this.lastError = e;
                this.emit("error:" + key, this, value, options, e);
            }
        }
        return true;
    };
    /**
     * Name of the component.
     */
    Component.componentName = "Component";
    /**
     * A string tag that categorizes the component. e.g. trans, render
     */
    Component.componentTag = "";
    /**
     * Map from option name to handler methods. The handler methods are
     * called in order when on an option is updated with a [[Model.set]] call.
     * This allows component to respond to option changes live. e.g. In a Live-Edit
     * User Interface for preset development.
     */
    Component.optUpdateHandlers = null;
    /**
     * Default options for this component
     */
    Component.defaultOptions = {};
    return Component;
}(Model_1["default"]));
exports["default"] = Component;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var defaults_1 = __webpack_require__(24);
var each_1 = __webpack_require__(12);
var indexOf_1 = __webpack_require__(277);
var utils_1 = __webpack_require__(0);
var Buffer_1 = __webpack_require__(29);
var geometries_1 = __webpack_require__(85);
/**
 * ShaderProgram is an abstraction for Shaders Programs that provides,
 * blended output, easier variable bindings and other nice features.
 */
var ShaderProgram = /** @class */ (function () {
    /**
     * Creates a new shader and compiles the source
     * @param rctx the rendering context under which the shader program will be created
     * @param opts shader options
     */
    function ShaderProgram(rctx, opts) {
        var _this = this;
        opts = defaults_1["default"](opts, {
            blendMode: utils_1.BlendMode.REPLACE,
            blendValue: 0.5,
            copyOnSwap: false,
            dynamicBlend: false,
            swapFrame: false
        });
        var vsrc = ["\n            precision mediump float;\n            varying vec2 v_position;\n            uniform vec2 u_resolution;\n            uniform sampler2D u_srcTexture;\n\n            #define PI " + Math.PI + "\n            #define getSrcColorAtPos(pos) (texture2D(u_srcTexture, pos))\n            #define setPosition(pos) (v_position = (((pos)+1.0)/2.0),gl_Position = vec4((pos), 0, 1))\n        "];
        var fsrc = ["\n            precision mediump float;\n            varying vec2 v_position;\n            uniform vec2 u_resolution;\n            uniform sampler2D u_srcTexture;\n\n            #define PI " + Math.PI + "\n            #define getSrcColorAtPos(pos) (texture2D(u_srcTexture, pos))\n            #define getSrcColor() (texture2D(u_srcTexture, v_position))\n        "];
        this.rctx = rctx;
        this.swapFrame = opts.swapFrame;
        this.copyOnSwap = opts.copyOnSwap;
        this.blendValue = opts.blendValue;
        this.blendMode = opts.blendMode;
        this.dynamicBlend = opts.dynamicBlend;
        if (this.dynamicBlend) {
            fsrc.push("\n                uniform int u_blendMode;\n                void setFragColor(vec4 color) {\n            ");
            each_1["default"](ShaderProgram.shaderBlendEq, function (eq, mode) {
                fsrc.push("\n                    if(u_blendMode == " + mode + ") {\n                        gl_FragColor = (" + eq + ");\n                    } else\n                ");
            });
            fsrc.push("\n                    {\n                        gl_FragColor = color;\n                    }\n                }\n            ");
        }
        else {
            if (this._isShaderBlend(this.blendMode)) {
                var eq = ShaderProgram.shaderBlendEq[this.blendMode];
                fsrc.push("#define setFragColor(color) (gl_FragColor = (" + eq + "))");
            }
            else {
                fsrc.push("#define setFragColor(color) (gl_FragColor = color)");
            }
        }
        this.drawHook = opts.drawHook;
        this.vertexSrc = vsrc.join("\n") + "\n";
        if (opts.vertexShader) {
            this.vertexSrc += utils_1.flatString(opts.vertexShader);
        }
        else {
            this.vertexSrc += "\n                attribute vec2 a_position;\n                void main() {\n                   setPosition(a_position);\n                }\n            ";
            var oldDrawHook_1 = this.drawHook;
            this.drawHook = function (values, gl, shader) {
                if (oldDrawHook_1) {
                    oldDrawHook_1(values, gl, shader);
                }
                _this.setAttrib("a_position", geometries_1.squareGeometry(_this.rctx));
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            };
        }
        this.fragmentSrc = fsrc.join("\n") + "\n" + utils_1.flatString(opts.fragmentShader);
        this.locations = {};
        this.textureVars = [];
        this.enabledAttribs = [];
        this.bindings = opts.bindings || {};
        this._compile();
    }
    /**
     * Runs the shader program
     * @param tsm the texture set in which the rendering will be made
     * @param values an object containing values for variables specified in the bindings
     * @param blendMode the blendMode for this render
     * @param blendValue blendValue when blendMode is `ADJUSTABLE`
     */
    ShaderProgram.prototype.run = function (tsm, values, blendMode, blendValue) {
        if (blendMode === void 0) { blendMode = null; }
        if (blendValue === void 0) { blendValue = null; }
        var gl = this.rctx.getGl();
        var oldProgram = gl.getParameter(gl.CURRENT_PROGRAM);
        gl.useProgram(this.program);
        if (blendMode && !this.dynamicBlend) {
            throw new Error("Cannot set blendmode at runtime. Use dynamicBlend");
        }
        blendMode = blendMode || this.blendMode;
        blendValue = typeof (blendValue) === "number" ? blendValue : this.blendValue;
        if (tsm) {
            this.setUniform("u_resolution", utils_1.WebGLVarType._2F, gl.drawingBufferWidth, gl.drawingBufferHeight);
            if (this.swapFrame || this._isShaderBlend(blendMode)) {
                this.setUniform("u_srcTexture", utils_1.WebGLVarType.TEXTURE2D, tsm.getCurrentTexture());
                tsm.switchTexture();
                if (this.copyOnSwap) {
                    tsm.copyOver();
                }
            }
            else if (this.dynamicBlend) {
                this.setUniform("u_srcTexture", utils_1.WebGLVarType.TEXTURE2D, null);
            }
        }
        if (this.dynamicBlend) {
            this.setUniform("u_blendMode", utils_1.WebGLVarType._1I, blendMode);
        }
        this._setGlBlendMode(blendMode, blendValue);
        this.draw(values);
        // disable all enabled attributes
        while (this.enabledAttribs.length) {
            gl.disableVertexAttribArray(this.enabledAttribs.shift());
        }
        gl.disable(gl.BLEND);
        gl.useProgram(oldProgram);
    };
    /**
     * Returns the location of a uniform or attribute.
     *
     * Locations are cached
     * @param name name of the variable
     * @param attrib if true then name is assumed to be an attribute
     */
    ShaderProgram.prototype.getLocation = function (name, attrib) {
        if (attrib === void 0) { attrib = false; }
        var location = this.locations[name];
        if (typeof location === "undefined") {
            var gl = this.rctx.getGl();
            if (attrib) {
                location = gl.getAttribLocation(this.program, name);
            }
            else {
                location = gl.getUniformLocation(this.program, name);
            }
            this.locations[name] = location;
        }
        return location;
    };
    /**
     * Returns the index of a texture. Assigns id if not already assigned.
     * @param name name of the texture
     */
    ShaderProgram.prototype.getTextureId = function (name) {
        var id = indexOf_1["default"](this.textureVars, name);
        if (id === -1) {
            this.textureVars.push(name);
            id = this.textureVars.length - 1;
        }
        return id;
    };
    /**
     * Binds value of a uniform variable in this program.
     * @param name name of the uniforma variable
     * @param type type of the value
     * @param values value(s) to be bound
     */
    ShaderProgram.prototype.setUniform = function (name, type) {
        var values = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            values[_i - 2] = arguments[_i];
        }
        var location = this.getLocation(name);
        var gl = this.rctx.getGl();
        switch (type) {
            case "texture2D":
                var id = this.getTextureId(name);
                gl.activeTexture(gl["TEXTURE" + id]);
                gl.bindTexture(gl.TEXTURE_2D, values[0]);
                gl.uniform1i(location, id);
                break;
            case "1f":
            case "2f":
            case "3f":
            case "4f":
            case "1i":
            case "2i":
            case "3i":
            case "4i":
                gl["uniform" + type].apply(gl, [location].concat(values));
                break;
            case "1fv":
            case "2fv":
            case "3fv":
            case "4fv":
            case "1iv":
            case "2iv":
            case "3iv":
            case "4iv":
                var value = values[0];
                if (!(value instanceof Float32Array)) {
                    value = new Float32Array(value);
                }
                gl["uniform" + type].call(gl, location, value);
                break;
        }
    };
    /**
     * Binds given buffer as the `ELEMENT_ARRAY_BUFFER`
     * @param buffer buffer to be bound as index
     */
    ShaderProgram.prototype.setIndex = function (buffer) {
        var gl = this.rctx.getGl();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer.getGlBuffer());
    };
    /**
     * Binds an attribute buffer and sets up vertex pointer
     * @param name name of the attribute
     * @param buffer buffer to be bound
     * @param size size of values
     * @param type type of values
     * @param normalized enables normalization for integers
     * @param stride array value stride
     * @param offset offset of first value
     */
    ShaderProgram.prototype.setAttrib = function (name, buffer, size, type, normalized, stride, offset) {
        if (size === void 0) { size = 2; }
        if (type === void 0) { type = this.rctx.getGl().FLOAT; }
        if (normalized === void 0) { normalized = false; }
        if (stride === void 0) { stride = 0; }
        if (offset === void 0) { offset = 0; }
        var gl = this.rctx.getGl();
        var location = this.getLocation(name, true);
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer.getGlBuffer());
        gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
        gl.enableVertexAttribArray(location);
        this.enabledAttribs.push(location);
    };
    ShaderProgram.prototype.disableAttrib = function (name) {
        var location = this.getLocation(name, true);
        this.rctx.getGl().disableVertexAttribArray(location);
    };
    /**
     * Destroys all webgl resources
     */
    ShaderProgram.prototype.destroy = function () {
        var gl = this.rctx.getGl();
        gl.deleteProgram(this.program);
        gl.deleteShader(this.vertex);
        gl.deleteShader(this.fragment);
    };
    ShaderProgram.prototype._isShaderBlend = function (mode) {
        return (mode in ShaderProgram.shaderBlendEq);
    };
    ShaderProgram.prototype._compile = function () {
        var gl = this.rctx.getGl();
        var vertex = this._compileShader(this.vertexSrc, gl.VERTEX_SHADER);
        var fragment = this._compileShader(this.fragmentSrc, gl.FRAGMENT_SHADER);
        var program = gl.createProgram();
        gl.attachShader(program, vertex);
        gl.attachShader(program, fragment);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error("Program link Error: " + gl.getProgramInfoLog(program));
        }
        this.vertex = vertex;
        this.fragment = fragment;
        this.program = program;
    };
    ShaderProgram.prototype._compileShader = function (shaderSrc, type) {
        var gl = this.rctx.getGl();
        var shader = gl.createShader(type);
        gl.shaderSource(shader, shaderSrc);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            utils_1.logShaderError(shaderSrc, gl.getShaderInfoLog(shader));
            throw new Error("Shader compilation Error: " + gl.getShaderInfoLog(shader));
        }
        return shader;
    };
    ShaderProgram.prototype.draw = function (values) {
        var errorIfNotBuffer = function (value, valueName) {
            if (value instanceof Buffer_1["default"]) {
                return value;
            }
            else {
                throw new Error("Value \"" + valueName + "\" should be a Buffer");
            }
        };
        // bind variables
        var isElements = false;
        var drawMode = null;
        var drawCount = null;
        for (var bindingType in this.bindings) {
            if (bindingType === "index") {
                var defn = this.bindings[bindingType];
                var valueName = defn.valueName;
                var value = values[valueName];
                var indexBuffer = errorIfNotBuffer(value, valueName);
                this.setIndex(indexBuffer);
                if (defn.drawMode) {
                    drawCount = indexBuffer.getLength();
                    drawMode = defn.drawMode;
                    isElements = true;
                }
            }
            else {
                for (var valueName in this.bindings[bindingType]) {
                    if (!this.bindings[bindingType].hasOwnProperty(valueName)) {
                        continue;
                    }
                    var value = values[valueName];
                    if (bindingType === "attribs") {
                        var defn = this.bindings[bindingType][valueName];
                        if (!value) {
                            this.disableAttrib(defn.name);
                        }
                        else {
                            var attribBuffer = errorIfNotBuffer(value, valueName);
                            this.setAttrib(defn.name, attribBuffer, defn.size, defn.valueType, defn.normalized, defn.stride, defn.offset);
                            if (defn.drawMode) {
                                drawCount = attribBuffer.getLength() / (defn.size || 2);
                                drawMode = defn.drawMode;
                            }
                        }
                    }
                    else if (bindingType === "uniforms") {
                        var defn = this.bindings[bindingType][valueName];
                        this.setUniform(defn.name, defn.valueType, value);
                    }
                }
            }
        }
        var gl = this.rctx.getGl();
        var drawHandled = false;
        if (this.drawHook) {
            drawHandled = !this.drawHook(values, gl, this);
        }
        if (!drawHandled) {
            if (drawMode !== null) {
                if (isElements) {
                    gl.drawElements(drawMode, drawCount, gl.UNSIGNED_SHORT, 0);
                }
                else {
                    gl.drawArrays(drawMode, 0, drawCount);
                }
            }
            else {
                throw new Error("Draw unhandled and no bindings containing drawMode.");
            }
        }
    };
    ShaderProgram.prototype._setGlBlendMode = function (mode, blendValue) {
        var gl = this.rctx.getGl();
        switch (mode) {
            case utils_1.BlendMode.ADDITIVE:
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE);
                gl.blendEquation(gl.FUNC_ADD);
                break;
            case utils_1.BlendMode.SUBTRACTIVE1:
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE);
                gl.blendEquation(gl.FUNC_REVERSE_SUBTRACT);
                break;
            case utils_1.BlendMode.SUBTRACTIVE2:
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE);
                gl.blendEquation(gl.FUNC_SUBTRACT);
                break;
            case utils_1.BlendMode.ALPHA:
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.blendEquation(gl.FUNC_ADD);
                break;
            case utils_1.BlendMode.MULTIPLY2:
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.DST_COLOR, gl.ZERO);
                gl.blendEquation(gl.FUNC_ADD);
                break;
            case utils_1.BlendMode.ADJUSTABLE:
                gl.enable(gl.BLEND);
                gl.blendColor(0, 0, 0, blendValue);
                gl.blendFunc(gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA);
                gl.blendEquation(gl.FUNC_ADD);
                break;
            case utils_1.BlendMode.AVERAGE:
                gl.enable(gl.BLEND);
                gl.blendColor(0.5, 0.5, 0.5, 1);
                gl.blendFunc(gl.CONSTANT_COLOR, gl.CONSTANT_COLOR);
                gl.blendEquation(gl.FUNC_ADD);
                break;
            // shader blending cases
            case utils_1.BlendMode.REPLACE:
            case utils_1.BlendMode.MULTIPLY:
            case utils_1.BlendMode.MAXIMUM:
                gl.disable(gl.BLEND);
                break;
            default:
                throw new Error("Unknown blend mode " + mode + " in shader");
        }
    };
    // these are blend modes not supported with gl.BLEND
    // and the formula to be used inside shader
    ShaderProgram.shaderBlendEq = (_a = {},
        _a[utils_1.BlendMode.MAXIMUM] = "max(color, texture2D(u_srcTexture, v_position))",
        _a[utils_1.BlendMode.MULTIPLY] = "clamp(color * texture2D(u_srcTexture, v_position) * 256.0, 0.0, 1.0)",
        _a);
    return ShaderProgram;
}());
exports["default"] = ShaderProgram;
var _a;


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__ = __webpack_require__(87);


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__["a" /* default */] || freeSelf || Function('return this')();

/* harmony default export */ __webpack_exports__["a"] = (root);


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ __webpack_exports__["a"] = (isObjectLike);


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/* harmony default export */ __webpack_exports__["a"] = (isObject);


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayMap);


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getRawTag_js__ = __webpack_require__(156);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__objectToString_js__ = __webpack_require__(157);




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? Object(__WEBPACK_IMPORTED_MODULE_1__getRawTag_js__["a" /* default */])(value)
    : Object(__WEBPACK_IMPORTED_MODULE_2__objectToString_js__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (baseGetTag);


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__identity_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__overRest_js__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__setToString_js__ = __webpack_require__(69);




/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return Object(__WEBPACK_IMPORTED_MODULE_2__setToString_js__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_1__overRest_js__["a" /* default */])(func, start, __WEBPACK_IMPORTED_MODULE_0__identity_js__["a" /* default */]), func + '');
}

/* harmony default export */ __webpack_exports__["a"] = (baseRest);


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIsNative_js__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getValue_js__ = __webpack_require__(160);



/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = Object(__WEBPACK_IMPORTED_MODULE_1__getValue_js__["a" /* default */])(object, key);
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseIsNative_js__["a" /* default */])(value) ? value : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = (getNative);


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayLikeKeys_js__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseKeys_js__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isArrayLike_js__ = __webpack_require__(17);




/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return Object(__WEBPACK_IMPORTED_MODULE_2__isArrayLike_js__["a" /* default */])(object) ? Object(__WEBPACK_IMPORTED_MODULE_0__arrayLikeKeys_js__["a" /* default */])(object) : Object(__WEBPACK_IMPORTED_MODULE_1__baseKeys_js__["a" /* default */])(object);
}

/* harmony default export */ __webpack_exports__["default"] = (keys);


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__forEach_js__ = __webpack_require__(244);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return __WEBPACK_IMPORTED_MODULE_0__forEach_js__["a"]; });



/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayMap_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIteratee_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseMap_js__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isArray_js__ = __webpack_require__(1);





/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = Object(__WEBPACK_IMPORTED_MODULE_3__isArray_js__["default"])(collection) ? __WEBPACK_IMPORTED_MODULE_0__arrayMap_js__["a" /* default */] : __WEBPACK_IMPORTED_MODULE_2__baseMap_js__["a" /* default */];
  return func(collection, Object(__WEBPACK_IMPORTED_MODULE_1__baseIteratee_js__["a" /* default */])(iteratee, 3));
}

/* harmony default export */ __webpack_exports__["default"] = (map);


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(4);


/** Built-in value references. */
var Symbol = __WEBPACK_IMPORTED_MODULE_0__root_js__["a" /* default */].Symbol;

/* harmony default export */ __webpack_exports__["a"] = (Symbol);


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assignValue_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseAssignValue_js__ = __webpack_require__(89);



/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      Object(__WEBPACK_IMPORTED_MODULE_1__baseAssignValue_js__["a" /* default */])(object, key, newValue);
    } else {
      Object(__WEBPACK_IMPORTED_MODULE_0__assignValue_js__["a" /* default */])(object, key, newValue);
    }
  }
  return object;
}

/* harmony default export */ __webpack_exports__["a"] = (copyObject);


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (baseUnary);


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isFunction_js__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isLength_js__ = __webpack_require__(58);



/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && Object(__WEBPACK_IMPORTED_MODULE_1__isLength_js__["a" /* default */])(value.length) && !Object(__WEBPACK_IMPORTED_MODULE_0__isFunction_js__["default"])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (isArrayLike);


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/* harmony default export */ __webpack_exports__["a"] = (identity);


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isArray_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isKey_js__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__stringToPath_js__ = __webpack_require__(201);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__toString_js__ = __webpack_require__(105);





/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (Object(__WEBPACK_IMPORTED_MODULE_0__isArray_js__["default"])(value)) {
    return value;
  }
  return Object(__WEBPACK_IMPORTED_MODULE_1__isKey_js__["a" /* default */])(value, object) ? [value] : Object(__WEBPACK_IMPORTED_MODULE_2__stringToPath_js__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_3__toString_js__["a" /* default */])(value));
}

/* harmony default export */ __webpack_exports__["a"] = (castPath);


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isSymbol_js__ = __webpack_require__(25);


/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || Object(__WEBPACK_IMPORTED_MODULE_0__isSymbol_js__["a" /* default */])(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/* harmony default export */ __webpack_exports__["a"] = (toKey);


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__toFinite_js__ = __webpack_require__(262);


/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = Object(__WEBPACK_IMPORTED_MODULE_0__toFinite_js__["a" /* default */])(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

/* harmony default export */ __webpack_exports__["a"] = (toInteger);


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/* harmony default export */ __webpack_exports__["a"] = (eq);


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/* harmony default export */ __webpack_exports__["a"] = (isIndex);


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseRest_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__eq_js__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isIterateeCall_js__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__keysIn_js__ = __webpack_require__(34);





/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = Object(__WEBPACK_IMPORTED_MODULE_0__baseRest_js__["a" /* default */])(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && Object(__WEBPACK_IMPORTED_MODULE_2__isIterateeCall_js__["a" /* default */])(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = Object(__WEBPACK_IMPORTED_MODULE_3__keysIn_js__["a" /* default */])(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (Object(__WEBPACK_IMPORTED_MODULE_1__eq_js__["a" /* default */])(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

/* harmony default export */ __webpack_exports__["default"] = (defaults);


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(5);



/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a" /* default */])(value) && Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a" /* default */])(value) == symbolTag);
}

/* harmony default export */ __webpack_exports__["a"] = (isSymbol);


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayPush_js__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isFlattenable_js__ = __webpack_require__(207);



/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = __WEBPACK_IMPORTED_MODULE_1__isFlattenable_js__["a" /* default */]);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        Object(__WEBPACK_IMPORTED_MODULE_0__arrayPush_js__["a" /* default */])(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseFlatten);


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseMatches_js__ = __webpack_require__(232);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseMatchesProperty_js__ = __webpack_require__(235);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__identity_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isArray_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__property_js__ = __webpack_require__(237);






/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return __WEBPACK_IMPORTED_MODULE_2__identity_js__["a" /* default */];
  }
  if (typeof value == 'object') {
    return Object(__WEBPACK_IMPORTED_MODULE_3__isArray_js__["default"])(value)
      ? Object(__WEBPACK_IMPORTED_MODULE_1__baseMatchesProperty_js__["a" /* default */])(value[0], value[1])
      : Object(__WEBPACK_IMPORTED_MODULE_0__baseMatches_js__["a" /* default */])(value);
  }
  return Object(__WEBPACK_IMPORTED_MODULE_4__property_js__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (baseIteratee);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var difference_1 = __webpack_require__(239);
var each_1 = __webpack_require__(12);
var flatten_1 = __webpack_require__(38);
var flow_1 = __webpack_require__(118);
var intersection_1 = __webpack_require__(249);
var isArray_1 = __webpack_require__(1);
var isEqual_1 = __webpack_require__(108);
var isNumber_1 = __webpack_require__(123);
var keys_1 = __webpack_require__(11);
var map_1 = __webpack_require__(13);
var partialRight_1 = __webpack_require__(125);
var pick_1 = __webpack_require__(103);
var takeRight_1 = __webpack_require__(83);
var union_1 = __webpack_require__(264);
var uniq_1 = __webpack_require__(134);
var values_1 = __webpack_require__(266);
var utils_1 = __webpack_require__(0);
var Ast = __webpack_require__(135);
var CodeInstance_1 = __webpack_require__(84);
var ExprGrammar_pegjs_1 = __webpack_require__(273);
function compileExpr(codeSrc, jsFuncs, glslFuncs, nonUniforms) {
    if (jsFuncs === void 0) { jsFuncs = []; }
    if (glslFuncs === void 0) { glslFuncs = []; }
    if (nonUniforms === void 0) { nonUniforms = []; }
    var codeStrings = {};
    for (var name_1 in codeSrc) {
        if (!codeSrc.hasOwnProperty(name_1)) {
            continue;
        }
        var codeString = codeSrc[name_1];
        if (isArray_1["default"](codeString)) {
            codeString = codeString.join("\n");
        }
        codeString.trim();
        if (codeString.length === 0) {
            continue;
        }
        codeStrings[name_1] = codeString;
    }
    // 1) Parse the code
    var codeAst = parseCode(codeStrings);
    // 2) Process the AST
    var tables = processAst(codeAst, jsFuncs, glslFuncs, nonUniforms);
    // 3) Generate code
    var codeInst = generateJs(codeAst, tables, jsFuncs);
    var glslCode = generateGlsl(codeAst, tables, glslFuncs);
    return { codeInst: codeInst, glslCode: glslCode };
}
exports["default"] = compileExpr;
function parseCode(codeSrc) {
    var codeAst = {}; // abstract syntax tree
    for (var name_2 in codeSrc) {
        if (!codeSrc.hasOwnProperty(name_2)) {
            continue;
        }
        try {
            codeAst[name_2] = ExprGrammar_pegjs_1.parse(codeSrc[name_2]);
        }
        catch (e) {
            throw new Error("Error parsing " + name_2 + " (" + e.line + ":" + e.column + ")" + " : " + e);
        }
    }
    return codeAst;
}
function isStaticExprList(exprs) {
    return exprs.every(function (expr) {
        return expr instanceof Ast.PrimaryExpr;
    });
}
function processAst(codeAst, jsFuncs, glslFuncs, extraNonUniforms) {
    var funcCall = {};
    var variable = {};
    var register = {};
    var preCompute = {};
    var preComputeCounter = 0;
    var processNode = function (ast, name) {
        if (ast instanceof Ast.Program) {
            for (var _i = 0, _a = ast.statements; _i < _a.length; _i++) {
                var statement = _a[_i];
                processNode(statement, name);
            }
        }
        else if (ast instanceof Ast.BinaryExpr) {
            processNode(ast.leftOperand, name);
            processNode(ast.rightOperand, name);
        }
        else if (ast instanceof Ast.UnaryExpr) {
            processNode(ast.operand, name);
        }
        else if (ast instanceof Ast.FuncCall) {
            checkFunc(ast);
            // if its a precomputable function to be generated in glsl
            // then build a table entry
            if (glslFuncs.indexOf(name) >= 0 && glslPreComputeFuncs.indexOf(ast.funcName) >= 0) {
                var args = ast.args;
                if (!isStaticExprList(args)) {
                    throw new Error("Non Pre-Computable arguments for " + ast.funcName + " in shader code, use variables or constants");
                }
                var entry = [ast.funcName].concat(map_1["default"](args, function (arg) { return arg.value; }));
                var uniformName = void 0;
                for (var key in preCompute) {
                    if (isEqual_1["default"](preCompute[key], entry)) {
                        uniformName = key;
                        break;
                    }
                }
                if (!uniformName) {
                    uniformName = "__PC_" + ast.funcName + "_" + preComputeCounter++;
                    preCompute[uniformName] = entry;
                }
                ast.preComputeUniformName = uniformName;
            }
            funcCall[name].push(ast.funcName);
            for (var _b = 0, _c = ast.args; _b < _c.length; _b++) {
                var arg = _c[_b];
                processNode(arg, name);
            }
        }
        else if (ast instanceof Ast.Assignment) {
            processNode(ast.lhs, name);
            processNode(ast.expr, name);
        }
        else if (ast instanceof Ast.PrimaryExpr && ast.type === "ID") {
            variable[name].push(ast.value);
        }
        else if (ast instanceof Ast.PrimaryExpr && ast.type === "REG") {
            register[name].push(ast.value);
        }
    };
    for (var name_3 in codeAst) {
        if (!codeAst.hasOwnProperty(name_3)) {
            continue;
        }
        funcCall[name_3] = [];
        variable[name_3] = [];
        register[name_3] = [];
        processNode(codeAst[name_3], name_3);
        funcCall[name_3] = uniq_1["default"](funcCall[name_3]);
        variable[name_3] = uniq_1["default"](variable[name_3]);
        register[name_3] = uniq_1["default"](register[name_3]);
    }
    var jsVars = flow_1["default"]([partialRight_1["default"](pick_1["default"], jsFuncs), values_1["default"], flatten_1["default"], uniq_1["default"]])(variable);
    var glslVars = flow_1["default"]([partialRight_1["default"](pick_1["default"], glslFuncs), values_1["default"], flatten_1["default"], uniq_1["default"]])(variable);
    var nonUniforms = flow_1["default"]([partialRight_1["default"](difference_1["default"], jsVars), partialRight_1["default"](union_1["default"], extraNonUniforms), uniq_1["default"]])(glslVars);
    var uniforms = intersection_1["default"](glslVars, jsVars);
    var glslUsedFuncs = flow_1["default"]([partialRight_1["default"](pick_1["default"], glslFuncs), values_1["default"], flatten_1["default"], uniq_1["default"]])(funcCall);
    var glslRegisters = flow_1["default"]([partialRight_1["default"](pick_1["default"], glslFuncs), values_1["default"], flatten_1["default"], uniq_1["default"]])(register);
    return {
        glslRegisters: glslRegisters, glslUsedFuncs: glslUsedFuncs, glslVars: glslVars, jsVars: jsVars, nonUniforms: nonUniforms, preCompute: preCompute, register: register, uniforms: uniforms
    };
}
function generateJs(codeAst, tables, jsFuncs) {
    var generateNode = function (ast) {
        if (ast instanceof Ast.BinaryExpr) {
            return "(" + generateNode(ast.leftOperand) + ast.operator + generateNode(ast.rightOperand) + ")";
        }
        if (ast instanceof Ast.UnaryExpr) {
            return "(" + ast.operator + generateNode(ast.operand) + ")";
        }
        if (ast instanceof Ast.FuncCall) {
            switch (ast.funcName) {
                case "above":
                    return [
                        "(",
                        generateNode(ast.args[0]),
                        ">",
                        generateNode(ast.args[1]),
                        "?1:0)",
                    ].join("");
                case "below":
                    return [
                        "(",
                        generateNode(ast.args[0]),
                        "<",
                        generateNode(ast.args[1]),
                        "?1:0)",
                    ].join("");
                case "equal":
                    return [
                        "(",
                        generateNode(ast.args[0]),
                        "==",
                        generateNode(ast.args[1]),
                        "?1:0)",
                    ].join("");
                case "if":
                    return [
                        "(",
                        generateNode(ast.args[0]),
                        "!==0?",
                        generateNode(ast.args[1]),
                        ":",
                        generateNode(ast.args[2]),
                        ")",
                    ].join("");
                case "select":
                    var code_1 = ["((function() {"];
                    code_1.push("switch(" + generateNode(ast.args[0]) + ") {");
                    each_1["default"](takeRight_1["default"](ast.args, ast.args.length - 1), function (arg, i) {
                        code_1.push("case " + i + ": return " + generateNode(arg) + ";");
                    });
                    code_1.push("default : throw new Error('Unknown selector value in select');");
                    code_1.push("}}).call(this))");
                    return code_1.join("");
                case "sqr":
                    return "(Math.pow((" + generateNode(ast.args[0]) + "),2))";
                case "band":
                    return "(((" + generateNode(ast.args[0]) + ")&&(" + generateNode(ast.args[1]) + "))?1:0)";
                case "bor":
                    return "(((" + generateNode(ast.args[0]) + ")||(" + generateNode(ast.args[1]) + "))?1:0)";
                case "bnot":
                    return "((!(" + generateNode(ast.args[0]) + "))?1:0)";
                case "invsqrt":
                    return "(1/Math.sqrt(" + generateNode(ast.args[0]) + "))";
                case "atan2":
                    return "(Math.atan((" + generateNode(ast.args[0]) + ")/(" + generateNode(ast.args[1]) + ")))";
                default:
                    var prefix = void 0;
                    var args = map_1["default"](ast.args, function (arg) { return generateNode(arg); }).join(",");
                    if (jsMathFuncs.indexOf(ast.funcName) >= 0) {
                        prefix = "Math.";
                    }
                    else {
                        prefix = "this.";
                    }
                    return "(" + prefix + ast.funcName + "(" + args + "))";
            }
        }
        if (ast instanceof Ast.Assignment) {
            return generateNode(ast.lhs) + "=" + generateNode(ast.expr);
        }
        if (ast instanceof Ast.Program) {
            var stmts = map_1["default"](ast.statements, function (stmt) { return generateNode(stmt); });
            return stmts.join(";\n");
        }
        if (ast instanceof Ast.PrimaryExpr && ast.type === "VALUE") {
            return ast.value.toString();
        }
        if (ast instanceof Ast.PrimaryExpr && ast.type === "CONST") {
            return translateConstants(ast.value).toString();
        }
        if (ast instanceof Ast.PrimaryExpr && ast.type === "ID") {
            return "this." + ast.value;
        }
        if (ast instanceof Ast.PrimaryExpr && ast.type === "REG") {
            return "this.registerBank[\"" + ast.value + "\"]";
        }
    };
    var registerUsages = flow_1["default"]([values_1["default"], flatten_1["default"], uniq_1["default"]])(tables.register);
    var hasRandom = tables.glslUsedFuncs.indexOf("rand") >= 0;
    var codeInst = new CodeInstance_1["default"](registerUsages, tables.glslRegisters, hasRandom, tables.uniforms, tables.preCompute);
    // clear all variables
    for (var _i = 0, _a = tables.jsVars; _i < _a.length; _i++) {
        var jsVar = _a[_i];
        codeInst[jsVar] = 0;
    }
    // generate code
    for (var _b = 0, jsFuncs_1 = jsFuncs; _b < jsFuncs_1.length; _b++) {
        var name_4 = jsFuncs_1[_b];
        var ast = codeAst[name_4];
        if (ast) {
            var jsCodeString = generateNode(ast);
            codeInst[name_4] = new Function(jsCodeString);
        }
        else {
            codeInst[name_4] = utils_1.noop;
        }
    }
    return codeInst;
}
function generateGlsl(codeAst, tables, glslFuncs) {
    var generateNode = function (ast) {
        if (ast instanceof Ast.BinaryExpr) {
            return "(" + generateNode(ast.leftOperand) + ast.operator + generateNode(ast.rightOperand) + ")";
        }
        if (ast instanceof Ast.UnaryExpr) {
            return "(" + ast.operator + generateNode(ast.operand) + ")";
        }
        if (ast instanceof Ast.FuncCall) {
            if (ast.preComputeUniformName) {
                return "(" + ast.preComputeUniformName + ")";
            }
            switch (ast.funcName) {
                case "above":
                    return [
                        "(",
                        generateNode(ast.args[0]),
                        ">",
                        generateNode(ast.args[1]),
                        "?1.0:0.0)",
                    ].join("");
                case "below":
                    return [
                        "(",
                        generateNode(ast.args[0]),
                        "<",
                        generateNode(ast.args[1]),
                        "?1.0:0.0)",
                    ].join("");
                case "equal":
                    return [
                        "(",
                        generateNode(ast.args[0]),
                        "==",
                        generateNode(ast.args[1]),
                        "?1.0:0.0)",
                    ].join("");
                case "if":
                    return [
                        "(",
                        generateNode(ast.args[0]),
                        "!=0.0?",
                        generateNode(ast.args[1]),
                        ":",
                        generateNode(ast.args[2]),
                        ")",
                    ].join("");
                case "select": {
                    var selectExpr_1 = generateNode(ast.args[0]);
                    var generateSelect_1 = function (args, i) {
                        if (args.length === 1) {
                            return generateNode(args[0]);
                        }
                        else {
                            return [
                                "((" + selectExpr_1 + " === " + i + ")?",
                                "(" + generateNode(args[0]) + "):",
                                "(" + generateSelect_1(takeRight_1["default"](args, args.length - 1), i + 1) + "))",
                            ].join("");
                        }
                    };
                    return generateSelect_1(takeRight_1["default"](ast.args, ast.args.length - 1), 0);
                }
                case "sqr":
                    return "(pow((" + generateNode(ast.args[0]) + "), 2))";
                case "band":
                    return "(float((" + generateNode(ast.args[0]) + ")&&(" + generateNode(ast.args[1]) + ")))";
                case "bor":
                    return "(float((" + generateNode(ast.args[0]) + ")||(" + generateNode(ast.args[1]) + ")))";
                case "bnot":
                    return "(float(!(" + generateNode(ast.args[0]) + ")))";
                case "invsqrt":
                    return "(1/sqrt(" + generateNode(ast.args[0]) + "))";
                case "atan2":
                    return "(atan((" + generateNode(ast.args[0]) + "),(" + generateNode(ast.args[1]) + "))";
                default: {
                    var args = map_1["default"](ast.args, function (arg) { return generateNode(arg); }).join(",");
                    return "(" + ast.funcName + "(" + args + "))";
                }
            }
        }
        if (ast instanceof Ast.Assignment) {
            return generateNode(ast.lhs) + "=" + generateNode(ast.expr);
        }
        if (ast instanceof Ast.Program) {
            var stmts = map_1["default"](ast.statements, function (stmt) { return generateNode(stmt); });
            return stmts.join(";\n") + ";";
        }
        if (ast instanceof Ast.PrimaryExpr && ast.type === "VALUE") {
            return utils_1.glslFloatRepr(ast.value);
        }
        if (ast instanceof Ast.PrimaryExpr && ast.type === "CONST") {
            return translateConstants(ast.value).toString();
        }
        if (ast instanceof Ast.PrimaryExpr && (ast.type === "ID" || ast.type === "REG")) {
            return ast.value;
        }
    };
    var glslCode = [];
    // glsl variable declarations
    glslCode = glslCode.concat(map_1["default"](tables.nonUniforms, function (name) {
        return "float " + name + " = 0.0;";
    }));
    glslCode = glslCode.concat(map_1["default"](tables.uniforms, function (name) {
        return "uniform float " + name + ";";
    }));
    // include required functions in glsl
    glslCode = glslCode.concat(flow_1["default"]([
        partialRight_1["default"](map_1["default"], function (name) {
            return ((name in glslFuncCode) ? (glslFuncCode[name]) : []);
        }),
        flatten_1["default"],
    ])(tables.glslUsedFuncs));
    // declarations for precomputed functions
    glslCode = glslCode.concat(flow_1["default"]([
        keys_1["default"],
        partialRight_1["default"](map_1["default"], function (name) {
            return "uniform float " + name + ";";
        }),
    ])(tables.preCompute));
    // add the functions
    for (var _i = 0, glslFuncs_1 = glslFuncs; _i < glslFuncs_1.length; _i++) {
        var name_5 = glslFuncs_1[_i];
        var ast = codeAst[name_5];
        if (ast) {
            var codeString = generateNode(ast);
            glslCode.push("void " + name_5 + "() {");
            glslCode.push(codeString);
            glslCode.push("}");
        }
        else {
            glslCode.push("void " + name_5 + "() {}");
        }
    }
    return glslCode.join("\n");
}
var funcArgLengths = {
    above: 2,
    abs: 1,
    acos: 1,
    asin: 1,
    atan: 1,
    atan2: 2,
    band: 2,
    below: 2,
    bnot: 1,
    bor: 2,
    ceil: 1,
    cos: 1,
    equal: 2,
    floor: 1,
    getosc: 3,
    gettime: 1,
    "if": 3,
    invsqrt: 1,
    log: 1,
    max: 2,
    min: 2,
    pow: 2,
    rand: 1,
    select: {
        min: 2
    },
    sin: 1,
    sqr: 1,
    sqrt: 1,
    tan: 1
};
var jsMathFuncs = [
    "min", "max", "sin", "cos", "abs", "tan", "asin", "acos",
    "atan", "log", "pow", "sqrt", "floor", "ceil",
];
var glslPreComputeFuncs = ["getosc", "gettime"];
var glslFuncCode = {
    rand: [
        "uniform vec2 __randStep;",
        "vec2 __randSeed;",
        "float rand(float max) {",
        "   __randSeed += __randStep;",
        "   float val = fract(sin(dot(__randSeed.xy ,vec2(12.9898,78.233))) * 43758.5453);",
        "   return (floor(val*max)+1);",
        "}",
    ].join("\n")
};
function checkFunc(ast) {
    var requiredArgLength = funcArgLengths[ast.funcName];
    if (requiredArgLength === undefined) {
        throw Error("Unknown function " + ast.funcName);
    }
    if (isNumber_1["default"](requiredArgLength)) {
        if (ast.args.length !== requiredArgLength) {
            throw Error(ast.funcName + " accepts " + requiredArgLength + " arguments");
        }
    }
    else if (requiredArgLength.min) {
        if (ast.args.length < requiredArgLength.min) {
            throw Error(ast.funcName + " accepts atleast " + requiredArgLength.min + " arguments");
        }
    }
}
function translateConstants(value) {
    switch (value) {
        case "pi": return Math.PI;
        case "e": return Math.E;
        case "phi": return 1.6180339887;
        default: throw new Error("Unknown constant " + value);
    }
}


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var utils_1 = __webpack_require__(0);
/**
 * Buffer is a wrapper around WebGLBuffer with type and size information.
 */
var Buffer = /** @class */ (function () {
    /**
     * Creates new Buffer
     *
     * @param rctx the rendering context in which the buffer should be created
     * @param isElemArray if true then a `gl.ELEMENT_ARRAY_BUFFER` is created else a `gl.ARRAY_BUFFER`
     * @param data the data to be stored in the buffer
     */
    function Buffer(rctx, isElemArray, data) {
        if (isElemArray === void 0) { isElemArray = false; }
        var gl = rctx.getGl();
        this.type = isElemArray ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
        this.rctx = rctx;
        this.glBuffer = gl.createBuffer();
        this.length = 0;
        if (data) {
            this.setData(data);
        }
    }
    /**
     * Sets the data stored in the buffer
     *
     * @param array the data to be stored in the buffer
     */
    Buffer.prototype.setData = function (array) {
        if (!utils_1.isTypedArray(array)) {
            array = new Float32Array(array);
        }
        var gl = this.rctx.getGl();
        this.length = array.length;
        gl.bindBuffer(this.type, this.glBuffer);
        gl.bufferData(this.type, array, gl.STATIC_DRAW);
    };
    /**
     * Returns the WebGLBuffer for this Buffer
     */
    Buffer.prototype.getGlBuffer = function () {
        return this.glBuffer;
    };
    /**
     * Returns the length of the data
     */
    Buffer.prototype.getLength = function () {
        return this.length;
    };
    /**
     * Destroys the buffer
     */
    Buffer.prototype.destroy = function () {
        this.rctx.getGl().deleteBuffer(this.glBuffer);
    };
    return Buffer;
}());
exports["default"] = Buffer;


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__listCacheClear_js__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__listCacheDelete_js__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__listCacheGet_js__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__listCacheHas_js__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__listCacheSet_js__ = __webpack_require__(148);






/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = __WEBPACK_IMPORTED_MODULE_0__listCacheClear_js__["a" /* default */];
ListCache.prototype['delete'] = __WEBPACK_IMPORTED_MODULE_1__listCacheDelete_js__["a" /* default */];
ListCache.prototype.get = __WEBPACK_IMPORTED_MODULE_2__listCacheGet_js__["a" /* default */];
ListCache.prototype.has = __WEBPACK_IMPORTED_MODULE_3__listCacheHas_js__["a" /* default */];
ListCache.prototype.set = __WEBPACK_IMPORTED_MODULE_4__listCacheSet_js__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (ListCache);


/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__eq_js__ = __webpack_require__(22);


/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (Object(__WEBPACK_IMPORTED_MODULE_0__eq_js__["a" /* default */])(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/* harmony default export */ __webpack_exports__["a"] = (assocIndexOf);


/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getNative_js__ = __webpack_require__(10);


/* Built-in method references that are verified to be native. */
var nativeCreate = Object(__WEBPACK_IMPORTED_MODULE_0__getNative_js__["a" /* default */])(Object, 'create');

/* harmony default export */ __webpack_exports__["a"] = (nativeCreate);


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isKeyable_js__ = __webpack_require__(169);


/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return Object(__WEBPACK_IMPORTED_MODULE_0__isKeyable_js__["a" /* default */])(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/* harmony default export */ __webpack_exports__["a"] = (getMapData);


/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayLikeKeys_js__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseKeysIn_js__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isArrayLike_js__ = __webpack_require__(17);




/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return Object(__WEBPACK_IMPORTED_MODULE_2__isArrayLike_js__["a" /* default */])(object) ? Object(__WEBPACK_IMPORTED_MODULE_0__arrayLikeKeys_js__["a" /* default */])(object, true) : Object(__WEBPACK_IMPORTED_MODULE_1__baseKeysIn_js__["a" /* default */])(object);
}

/* harmony default export */ __webpack_exports__["a"] = (keysIn);


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__DataView_js__ = __webpack_require__(185);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Map_js__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Promise_js__ = __webpack_require__(186);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Set_js__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__WeakMap_js__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__baseGetTag_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__toSource_js__ = __webpack_require__(88);








/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = Object(__WEBPACK_IMPORTED_MODULE_6__toSource_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__DataView_js__["a" /* default */]),
    mapCtorString = Object(__WEBPACK_IMPORTED_MODULE_6__toSource_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__Map_js__["a" /* default */]),
    promiseCtorString = Object(__WEBPACK_IMPORTED_MODULE_6__toSource_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_2__Promise_js__["a" /* default */]),
    setCtorString = Object(__WEBPACK_IMPORTED_MODULE_6__toSource_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_3__Set_js__["a" /* default */]),
    weakMapCtorString = Object(__WEBPACK_IMPORTED_MODULE_6__toSource_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_4__WeakMap_js__["a" /* default */]);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = __WEBPACK_IMPORTED_MODULE_5__baseGetTag_js__["a" /* default */];

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((__WEBPACK_IMPORTED_MODULE_0__DataView_js__["a" /* default */] && getTag(new __WEBPACK_IMPORTED_MODULE_0__DataView_js__["a" /* default */](new ArrayBuffer(1))) != dataViewTag) ||
    (__WEBPACK_IMPORTED_MODULE_1__Map_js__["a" /* default */] && getTag(new __WEBPACK_IMPORTED_MODULE_1__Map_js__["a" /* default */]) != mapTag) ||
    (__WEBPACK_IMPORTED_MODULE_2__Promise_js__["a" /* default */] && getTag(__WEBPACK_IMPORTED_MODULE_2__Promise_js__["a" /* default */].resolve()) != promiseTag) ||
    (__WEBPACK_IMPORTED_MODULE_3__Set_js__["a" /* default */] && getTag(new __WEBPACK_IMPORTED_MODULE_3__Set_js__["a" /* default */]) != setTag) ||
    (__WEBPACK_IMPORTED_MODULE_4__WeakMap_js__["a" /* default */] && getTag(new __WEBPACK_IMPORTED_MODULE_4__WeakMap_js__["a" /* default */]) != weakMapTag)) {
  getTag = function(value) {
    var result = Object(__WEBPACK_IMPORTED_MODULE_5__baseGetTag_js__["a" /* default */])(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? Object(__WEBPACK_IMPORTED_MODULE_6__toSource_js__["a" /* default */])(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (getTag);


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isObject_js__ = __webpack_require__(6);


/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!Object(__WEBPACK_IMPORTED_MODULE_0__isObject_js__["a" /* default */])(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/* harmony default export */ __webpack_exports__["a"] = (baseCreate);


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__castPath_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toKey_js__ = __webpack_require__(20);



/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = Object(__WEBPACK_IMPORTED_MODULE_0__castPath_js__["a" /* default */])(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[Object(__WEBPACK_IMPORTED_MODULE_1__toKey_js__["a" /* default */])(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = (baseGet);


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFlatten_js__ = __webpack_require__(26);


/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? Object(__WEBPACK_IMPORTED_MODULE_0__baseFlatten_js__["a" /* default */])(array, 1) : [];
}

/* harmony default export */ __webpack_exports__["default"] = (flatten);


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__MapCache_js__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__setCacheAdd_js__ = __webpack_require__(214);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__setCacheHas_js__ = __webpack_require__(215);




/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new __WEBPACK_IMPORTED_MODULE_0__MapCache_js__["a" /* default */];
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = __WEBPACK_IMPORTED_MODULE_1__setCacheAdd_js__["a" /* default */];
SetCache.prototype.has = __WEBPACK_IMPORTED_MODULE_2__setCacheHas_js__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (SetCache);


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/* harmony default export */ __webpack_exports__["a"] = (cacheHas);


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseSlice);


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseForOwn_js__ = __webpack_require__(228);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__createBaseEach_js__ = __webpack_require__(231);



/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = Object(__WEBPACK_IMPORTED_MODULE_1__createBaseEach_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__baseForOwn_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (baseEach);


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIndexOf_js__ = __webpack_require__(116);


/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && Object(__WEBPACK_IMPORTED_MODULE_0__baseIndexOf_js__["a" /* default */])(array, value, 0) > -1;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayIncludes);


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isArrayLike_js__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(5);



/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a" /* default */])(value) && Object(__WEBPACK_IMPORTED_MODULE_0__isArrayLike_js__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (isArrayLikeObject);


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseCreate_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObject_js__ = __webpack_require__(6);



/**
 * Creates a function that produces an instance of `Ctor` regardless of
 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
 *
 * @private
 * @param {Function} Ctor The constructor to wrap.
 * @returns {Function} Returns the new wrapped function.
 */
function createCtor(Ctor) {
  return function() {
    // Use a `switch` statement to work with class constructors. See
    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    // for more details.
    var args = arguments;
    switch (args.length) {
      case 0: return new Ctor;
      case 1: return new Ctor(args[0]);
      case 2: return new Ctor(args[0], args[1]);
      case 3: return new Ctor(args[0], args[1], args[2]);
      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = Object(__WEBPACK_IMPORTED_MODULE_0__baseCreate_js__["a" /* default */])(Ctor.prototype),
        result = Ctor.apply(thisBinding, args);

    // Mimic the constructor's `return` behavior.
    // See https://es5.github.io/#x13.2.2 for more details.
    return Object(__WEBPACK_IMPORTED_MODULE_1__isObject_js__["a" /* default */])(result) ? result : thisBinding;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (createCtor);


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/**
 * Replaces all `placeholder` elements in `array` with an internal placeholder
 * and returns an array of their indexes.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {*} placeholder The placeholder to replace.
 * @returns {Array} Returns the new array of placeholder indexes.
 */
function replaceHolders(array, placeholder) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value === placeholder || value === PLACEHOLDER) {
      array[index] = PLACEHOLDER;
      result[resIndex++] = index;
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (replaceHolders);


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseClone_js__ = __webpack_require__(86);


/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseClone_js__["a" /* default */])(value, CLONE_SYMBOLS_FLAG);
}

/* harmony default export */ __webpack_exports__["default"] = (clone);


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ListCache_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__stackClear_js__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__stackDelete_js__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__stackGet_js__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__stackHas_js__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__stackSet_js__ = __webpack_require__(153);







/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new __WEBPACK_IMPORTED_MODULE_0__ListCache_js__["a" /* default */](entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = __WEBPACK_IMPORTED_MODULE_1__stackClear_js__["a" /* default */];
Stack.prototype['delete'] = __WEBPACK_IMPORTED_MODULE_2__stackDelete_js__["a" /* default */];
Stack.prototype.get = __WEBPACK_IMPORTED_MODULE_3__stackGet_js__["a" /* default */];
Stack.prototype.has = __WEBPACK_IMPORTED_MODULE_4__stackHas_js__["a" /* default */];
Stack.prototype.set = __WEBPACK_IMPORTED_MODULE_5__stackSet_js__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (Stack);


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getNative_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__root_js__ = __webpack_require__(4);



/* Built-in method references that are verified to be native. */
var Map = Object(__WEBPACK_IMPORTED_MODULE_0__getNative_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__root_js__["a" /* default */], 'Map');

/* harmony default export */ __webpack_exports__["a"] = (Map);


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObject_js__ = __webpack_require__(6);



/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_1__isObject_js__["a" /* default */])(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a" /* default */])(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/* harmony default export */ __webpack_exports__["default"] = (isFunction);


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mapCacheClear_js__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mapCacheDelete_js__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mapCacheGet_js__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mapCacheHas_js__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mapCacheSet_js__ = __webpack_require__(172);






/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = __WEBPACK_IMPORTED_MODULE_0__mapCacheClear_js__["a" /* default */];
MapCache.prototype['delete'] = __WEBPACK_IMPORTED_MODULE_1__mapCacheDelete_js__["a" /* default */];
MapCache.prototype.get = __WEBPACK_IMPORTED_MODULE_2__mapCacheGet_js__["a" /* default */];
MapCache.prototype.has = __WEBPACK_IMPORTED_MODULE_3__mapCacheHas_js__["a" /* default */];
MapCache.prototype.set = __WEBPACK_IMPORTED_MODULE_4__mapCacheSet_js__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (MapCache);


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayEach);


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseAssignValue_js__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__eq_js__ = __webpack_require__(22);



/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && Object(__WEBPACK_IMPORTED_MODULE_1__eq_js__["a" /* default */])(objValue, value)) ||
      (value === undefined && !(key in object))) {
    Object(__WEBPACK_IMPORTED_MODULE_0__baseAssignValue_js__["a" /* default */])(object, key, value);
  }
}

/* harmony default export */ __webpack_exports__["a"] = (assignValue);


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseTimes);


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIsArguments_js__ = __webpack_require__(174);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(5);



/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = Object(__WEBPACK_IMPORTED_MODULE_0__baseIsArguments_js__["a" /* default */])(function() { return arguments; }()) ? __WEBPACK_IMPORTED_MODULE_0__baseIsArguments_js__["a" /* default */] : function(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a" /* default */])(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/* harmony default export */ __webpack_exports__["a"] = (isArguments);


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__stubFalse_js__ = __webpack_require__(175);



/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? __WEBPACK_IMPORTED_MODULE_0__root_js__["a" /* default */].Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || __WEBPACK_IMPORTED_MODULE_1__stubFalse_js__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (isBuffer);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(57)(module)))

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true,
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/* harmony default export */ __webpack_exports__["a"] = (isLength);


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__ = __webpack_require__(87);


/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__["a" /* default */].process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* harmony default export */ __webpack_exports__["a"] = (nodeUtil);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(57)(module)))

/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/* harmony default export */ __webpack_exports__["a"] = (isPrototype);


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/* harmony default export */ __webpack_exports__["a"] = (copyArray);


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayFilter_js__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__stubArray_js__ = __webpack_require__(94);



/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? __WEBPACK_IMPORTED_MODULE_1__stubArray_js__["a" /* default */] : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return Object(__WEBPACK_IMPORTED_MODULE_0__arrayFilter_js__["a" /* default */])(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/* harmony default export */ __webpack_exports__["a"] = (getSymbols);


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayFilter);


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayPush);


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__overArg_js__ = __webpack_require__(93);


/** Built-in value references. */
var getPrototype = Object(__WEBPACK_IMPORTED_MODULE_0__overArg_js__["a" /* default */])(Object.getPrototypeOf, Object);

/* harmony default export */ __webpack_exports__["a"] = (getPrototype);


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetAllKeys_js__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getSymbolsIn_js__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__keysIn_js__ = __webpack_require__(34);




/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseGetAllKeys_js__["a" /* default */])(object, __WEBPACK_IMPORTED_MODULE_2__keysIn_js__["a" /* default */], __WEBPACK_IMPORTED_MODULE_1__getSymbolsIn_js__["a" /* default */]);
}

/* harmony default export */ __webpack_exports__["a"] = (getAllKeysIn);


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Uint8Array_js__ = __webpack_require__(100);


/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new __WEBPACK_IMPORTED_MODULE_0__Uint8Array_js__["a" /* default */](result).set(new __WEBPACK_IMPORTED_MODULE_0__Uint8Array_js__["a" /* default */](arrayBuffer));
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (cloneArrayBuffer);


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/* harmony default export */ __webpack_exports__["a"] = (apply);


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSetToString_js__ = __webpack_require__(198);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shortOut_js__ = __webpack_require__(102);



/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = Object(__WEBPACK_IMPORTED_MODULE_1__shortOut_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__baseSetToString_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (setToString);


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__eq_js__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isArrayLike_js__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isIndex_js__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isObject_js__ = __webpack_require__(6);





/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_3__isObject_js__["a" /* default */])(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (Object(__WEBPACK_IMPORTED_MODULE_1__isArrayLike_js__["a" /* default */])(object) && Object(__WEBPACK_IMPORTED_MODULE_2__isIndex_js__["a" /* default */])(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__eq_js__["a" /* default */])(object[index], value);
  }
  return false;
}

/* harmony default export */ __webpack_exports__["a"] = (isIterateeCall);


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isArray_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isSymbol_js__ = __webpack_require__(25);



/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (Object(__WEBPACK_IMPORTED_MODULE_0__isArray_js__["default"])(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || Object(__WEBPACK_IMPORTED_MODULE_1__isSymbol_js__["a" /* default */])(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/* harmony default export */ __webpack_exports__["a"] = (isKey);


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__flatten_js__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__overRest_js__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__setToString_js__ = __webpack_require__(69);




/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return Object(__WEBPACK_IMPORTED_MODULE_2__setToString_js__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_1__overRest_js__["a" /* default */])(func, undefined, __WEBPACK_IMPORTED_MODULE_0__flatten_js__["default"]), func + '');
}

/* harmony default export */ __webpack_exports__["a"] = (flatRest);


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isArray_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__ = __webpack_require__(5);




/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!Object(__WEBPACK_IMPORTED_MODULE_1__isArray_js__["default"])(value) && Object(__WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__["a" /* default */])(value) && Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a" /* default */])(value) == stringTag);
}

/* harmony default export */ __webpack_exports__["default"] = (isString);


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIsEqualDeep_js__ = __webpack_require__(213);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(5);



/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a" /* default */])(value) && !Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a" /* default */])(other))) {
    return value !== value && other !== other;
  }
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseIsEqualDeep_js__["a" /* default */])(value, other, bitmask, customizer, baseIsEqual, stack);
}

/* harmony default export */ __webpack_exports__["a"] = (baseIsEqual);


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (setToArray);


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var EventEmitter = __webpack_require__(226);
var filter_1 = __webpack_require__(112);
/**
 * Model is a base for Model-Like objects.
 *
 * Model provides some event-model and general attribute management
 * facilities. Model basically provides getter, setter methods for
 * attributes and an event subscription system to notify of attribute
 * changes or other custom events. Model is used mainly by Components
 * to model component options and thus allow editors to treat each
 * component as a Data Model object to drive user interface.
 */
var Model = /** @class */ (function (_super) {
    __extends(Model, _super);
    function Model() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.subscriptions = [];
        return _this;
    }
    /**
     * Safely set an attribute(s).
     *
     * If the attribute set succeeds, a `change:[attribute name]` event is fired.
     * `change:[attribute name]` event handler receives `this` object, the new `value`
     * and `options` as arguments.
     *
     * Additionally a `change` event is also fired when all changes succeed. The `change`
     * event receives `this` object and the `options` as arguments.
     *
     * @param key the name of the attribute or map of values
     * @param value the new value of the attribute
     * @param options this object is sent down to the event handlers, useful to things down to your
     * handler. if `options.silent` is true then events are not fired.
     */
    Model.prototype.set = function (key, value, options) {
        var success;
        if (typeof (key) === "string") {
            options = options || {};
            var silent = typeof (options.silent) === "undefined" ? true : false;
            success = this.setAttribute(key, value, options);
            if (success && !silent) {
                this.emit("change:" + key, this, value, options);
                this.emit("change", this, options);
            }
        }
        else {
            // if map of key values are passed
            // then set each value separately
            options = value || {};
            var silent = typeof (options.silent) === "undefined" ? true : false;
            var keyValueMap = key;
            success = false;
            for (key in keyValueMap) {
                if (this.setAttribute(key, keyValueMap[key], options)) {
                    success = true;
                    if (!silent) {
                        this.emit("change:" + key, this, keyValueMap[key], options);
                    }
                }
            }
            if (success && !silent) {
                this.emit("change", this, options);
            }
        }
        return success;
    };
    /**
     * Add a listener to another EventEmitter.
     *
     * This provides an event subscription list facility. Allowing
     * subclasses to listen to other emitters and remove all or some listeners
     * with a single call to [[Model.stopListening]], later.
     *
     * @param emitter the event emitter to listen to
     * @param event the name of the event to listen to
     * @param callback the callback for the event handler
     */
    Model.prototype.listenTo = function (emitter, event, callback) {
        emitter.addListener(event, callback);
        this.subscriptions.push({ emitter: emitter, event: event, callback: callback });
    };
    /**
     * Removes to one or more listeners that were set earlier with calls to [[Model.listenTo]].
     *
     * Use the arguments to filter subscriptions. eg: `model.stopListening(em)` will remove all
     * listeners on emitter `em`. `model.stopListening(em, 'change')` will remove all listeners for
     * `change` event on emitter `em`.
     *
     * @param emitter the event emitter on which the listener was set
     * @param event the event to be removed
     * @param callback the callback to be removed
     */
    Model.prototype.stopListening = function (emitter, event, callback) {
        var subFilter = {};
        if (emitter) {
            subFilter.emitter = emitter;
        }
        if (event) {
            subFilter.event = event;
        }
        if (emitter) {
            subFilter.callback = callback;
        }
        var subs = filter_1["default"](this.subscriptions, subFilter);
        subs.forEach(function (sub) {
            sub.emitter.removeListener(sub.event, sub.callback);
        });
    };
    return Model;
}(EventEmitter));
exports["default"] = Model;


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayIncludesWith);


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseCreate_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseLodash_js__ = __webpack_require__(79);



/**
 * The base constructor for creating `lodash` wrapper objects.
 *
 * @private
 * @param {*} value The value to wrap.
 * @param {boolean} [chainAll] Enable explicit method chain sequences.
 */
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = undefined;
}

LodashWrapper.prototype = Object(__WEBPACK_IMPORTED_MODULE_0__baseCreate_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__baseLodash_js__["a" /* default */].prototype);
LodashWrapper.prototype.constructor = LodashWrapper;

/* harmony default export */ __webpack_exports__["a"] = (LodashWrapper);


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The function whose prototype chain sequence wrappers inherit from.
 *
 * @private
 */
function baseLodash() {
  // No operation performed.
}

/* harmony default export */ __webpack_exports__["a"] = (baseLodash);


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__metaMap_js__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__noop_js__ = __webpack_require__(120);



/**
 * Gets metadata for `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {*} Returns the metadata for `func`.
 */
var getData = !__WEBPACK_IMPORTED_MODULE_0__metaMap_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_1__noop_js__["a" /* default */] : function(func) {
  return __WEBPACK_IMPORTED_MODULE_0__metaMap_js__["a" /* default */].get(func);
};

/* harmony default export */ __webpack_exports__["a"] = (getData);


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseCreate_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseLodash_js__ = __webpack_require__(79);



/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/**
 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
 *
 * @private
 * @constructor
 * @param {*} value The value to wrap.
 */
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}

// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype = Object(__WEBPACK_IMPORTED_MODULE_0__baseCreate_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__baseLodash_js__["a" /* default */].prototype);
LazyWrapper.prototype.constructor = LazyWrapper;

/* harmony default export */ __webpack_exports__["a"] = (LazyWrapper);


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Gets the argument placeholder value for `func`.
 *
 * @private
 * @param {Function} func The function to inspect.
 * @returns {*} Returns the placeholder value.
 */
function getHolder(func) {
  var object = func;
  return object.placeholder;
}

/* harmony default export */ __webpack_exports__["a"] = (getHolder);


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSlice_js__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toInteger_js__ = __webpack_require__(21);



/**
 * Creates a slice of `array` with `n` elements taken from the end.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to take.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.takeRight([1, 2, 3]);
 * // => [3]
 *
 * _.takeRight([1, 2, 3], 2);
 * // => [2, 3]
 *
 * _.takeRight([1, 2, 3], 5);
 * // => [1, 2, 3]
 *
 * _.takeRight([1, 2, 3], 0);
 * // => []
 */
function takeRight(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : Object(__WEBPACK_IMPORTED_MODULE_1__toInteger_js__["a" /* default */])(n);
  n = length - n;
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseSlice_js__["a" /* default */])(array, n < 0 ? 0 : n, length);
}

/* harmony default export */ __webpack_exports__["default"] = (takeRight);


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var drop_1 = __webpack_require__(268);
var each_1 = __webpack_require__(12);
var extend_1 = __webpack_require__(136);
var has_1 = __webpack_require__(271);
var isArray_1 = __webpack_require__(1);
var isFunction_1 = __webpack_require__(50);
var isString_1 = __webpack_require__(73);
var map_1 = __webpack_require__(13);
var take_1 = __webpack_require__(137);
var times_1 = __webpack_require__(138);
var utils_1 = __webpack_require__(0);
// An object that encapsulates the generated executable code
// and its state values. Also contains implementations of
// functions callable from expressions
var CodeInstance = /** @class */ (function () {
    function CodeInstance(registerUsages, glslRegisters, hasRandom, uniforms, preCompute) {
        this.registerUsages = registerUsages;
        this.glslRegisters = glslRegisters;
        this.hasRandom = hasRandom;
        this.uniforms = uniforms;
        this.preCompute = preCompute;
    }
    // creates an array of clones of code instances
    CodeInstance.clone = function (cloneOrClones, count) {
        var clones;
        if (!isArray_1["default"](cloneOrClones)) {
            cloneOrClones.cid = 0;
            clones = [cloneOrClones];
        }
        else {
            clones = cloneOrClones;
        }
        var clonesLength = clones.length;
        if (clonesLength < count) {
            times_1["default"](count - clonesLength, function (index) {
                var clone = Object.create(CodeInstance.prototype);
                extend_1["default"](clone, clones[0]);
                clone.cid = index + clonesLength;
                clones.push(clone);
            });
        }
        else if (clonesLength > count) {
            clones = take_1["default"](clones, count);
        }
        return clones;
    };
    // copies instance values from one code instance to another
    CodeInstance.copyValues = function (dest, src) {
        each_1["default"](src, function (value, name) {
            if (!isFunction_1["default"](value) && name.charAt(0) !== "_") {
                dest[name] = value;
            }
        });
    };
    // avs expression rand function
    CodeInstance.prototype.rand = function (max) {
        return Math.floor(Math.random() * max) + 1;
    };
    // avs expression gettime function
    CodeInstance.prototype.gettime = function (startTime) {
        switch (startTime) {
            case 0:
                var currentTime = (new Date()).getTime();
                return (currentTime - this.bootTime) / 1000;
            default: throw new Error("Invalid startTime mode for gettime call");
        }
    };
    // avs expression getosc function
    CodeInstance.prototype.getosc = function (band, width, channel) {
        var osc = this.analyser.getWaveform();
        var pos = Math.floor((band - width / 2) * (osc.length - 1));
        var end = Math.floor((band + width / 2) * (osc.length - 1));
        var sum = 0;
        for (var i = pos; i <= end; i++) {
            sum += osc[i];
        }
        return sum / (end - pos + 1);
    };
    // bind state values to uniforms
    CodeInstance.prototype.bindUniforms = function (program) {
        var _this = this;
        // bind all values
        each_1["default"](this.uniforms, function (name) {
            program.setUniform(name, utils_1.WebGLVarType._1F, _this[name]);
        });
        // bind registers
        each_1["default"](this.glslRegisters, function (name) {
            program.setUniform(name, utils_1.WebGLVarType._1F, _this.registerBank[name]);
        });
        // bind random step value if there are usages of random
        if (this.hasRandom) {
            var step = [Math.random() / 100, Math.random() / 100];
            program.setUniform("__randStep", utils_1.WebGLVarType._2FV, step);
        }
        // bind precomputed values
        each_1["default"](this.preCompute, function (entry, name) {
            var args = map_1["default"](drop_1["default"](entry), function (arg) {
                if (isString_1["default"](arg)) {
                    if (arg.substring(0, 5) === "__REG") {
                        return _this.registerBank[arg];
                    }
                    else {
                        return _this[arg];
                    }
                }
                else {
                    return arg;
                }
            });
            var result = _this[entry[0]].apply(_this, args);
            program.setUniform(name, utils_1.WebGLVarType._1F, result);
        });
    };
    // initializes this codeinstance
    CodeInstance.prototype.setup = function (main) {
        var _this = this;
        this.registerBank = main.getRegisterBank();
        this.bootTime = main.getBootTime();
        this.analyser = main.getAnalyser();
        this.updateDimVars(main.getRctx().getGl());
        // clear all used registers
        each_1["default"](this.registerUsages, function (name) {
            if (!has_1["default"](_this.registerBank, name)) {
                _this.registerBank[name] = 0;
            }
        });
    };
    CodeInstance.prototype.updateDimVars = function (gl) {
        this.w = gl.drawingBufferWidth;
        this.h = gl.drawingBufferHeight;
    };
    return CodeInstance;
}());
exports["default"] = CodeInstance;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Buffer_1 = __webpack_require__(29);
/**
 * Returns a cached Buffer with points on a circle
 * @param rctx RenderingContext undef which the buffer will be created and cached
 * @param pointCount number of points in the geometry
 */
function circleGeometry(rctx, pointCount) {
    if (pointCount === void 0) { pointCount = 100; }
    var cacheKey = "CircleGeometry_" + pointCount;
    var buffer = rctx.getBuffer(cacheKey);
    if (buffer) {
        return buffer;
    }
    var points = new Float32Array((pointCount + 2) * 2);
    var pbi = 0;
    points[pbi++] = 0; // center
    points[pbi++] = 0;
    for (var i = 0; i < pointCount; i++) {
        points[pbi++] = Math.sin(i * 2 * Math.PI / pointCount);
        points[pbi++] = Math.cos(i * 2 * Math.PI / pointCount);
    }
    points[pbi++] = points[2]; // repeat last point again
    points[pbi++] = points[3];
    buffer = new Buffer_1["default"](rctx, false, points);
    rctx.cacheBuffer(cacheKey, buffer);
    return buffer;
}
exports.circleGeometry = circleGeometry;
/**
 * Returns a cached buffer with points on a square
 * @param rctx RenderingContext under which the buffer will be created and cached
 * @param positiveQuad if true then square will be in [0-1][0-1] range.
 */
function squareGeometry(rctx, positiveQuad) {
    if (positiveQuad === void 0) { positiveQuad = false; }
    var cacheKey = "SquareGeometry_" + positiveQuad;
    var buffer = rctx.getBuffer(cacheKey);
    if (buffer) {
        return buffer;
    }
    var points;
    if (positiveQuad) {
        points = [
            0, 0,
            0, 1,
            1, 1,
            0, 0,
            1, 1,
            1, 0,
        ];
    }
    else {
        points = [
            -1, -1,
            1, -1,
            -1, 1,
            -1, 1,
            1, -1,
            1, 1,
        ];
    }
    buffer = new Buffer_1["default"](rctx, false, points);
    rctx.cacheBuffer(cacheKey, buffer);
    return buffer;
}
exports.squareGeometry = squareGeometry;


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Stack_js__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayEach_js__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__assignValue_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__baseAssign_js__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__baseAssignIn_js__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__cloneBuffer_js__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__copyArray_js__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__copySymbols_js__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__copySymbolsIn_js__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__getAllKeys_js__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__getAllKeysIn_js__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__getTag_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__initCloneArray_js__ = __webpack_require__(187);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__initCloneByTag_js__ = __webpack_require__(188);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__initCloneObject_js__ = __webpack_require__(193);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__isArray_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__isBuffer_js__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__isMap_js__ = __webpack_require__(194);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__isObject_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__isSet_js__ = __webpack_require__(196);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__keys_js__ = __webpack_require__(11);






















/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!Object(__WEBPACK_IMPORTED_MODULE_18__isObject_js__["a" /* default */])(value)) {
    return value;
  }
  var isArr = Object(__WEBPACK_IMPORTED_MODULE_15__isArray_js__["default"])(value);
  if (isArr) {
    result = Object(__WEBPACK_IMPORTED_MODULE_12__initCloneArray_js__["a" /* default */])(value);
    if (!isDeep) {
      return Object(__WEBPACK_IMPORTED_MODULE_6__copyArray_js__["a" /* default */])(value, result);
    }
  } else {
    var tag = Object(__WEBPACK_IMPORTED_MODULE_11__getTag_js__["a" /* default */])(value),
        isFunc = tag == funcTag || tag == genTag;

    if (Object(__WEBPACK_IMPORTED_MODULE_16__isBuffer_js__["a" /* default */])(value)) {
      return Object(__WEBPACK_IMPORTED_MODULE_5__cloneBuffer_js__["a" /* default */])(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : Object(__WEBPACK_IMPORTED_MODULE_14__initCloneObject_js__["a" /* default */])(value);
      if (!isDeep) {
        return isFlat
          ? Object(__WEBPACK_IMPORTED_MODULE_8__copySymbolsIn_js__["a" /* default */])(value, Object(__WEBPACK_IMPORTED_MODULE_4__baseAssignIn_js__["a" /* default */])(result, value))
          : Object(__WEBPACK_IMPORTED_MODULE_7__copySymbols_js__["a" /* default */])(value, Object(__WEBPACK_IMPORTED_MODULE_3__baseAssign_js__["a" /* default */])(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = Object(__WEBPACK_IMPORTED_MODULE_13__initCloneByTag_js__["a" /* default */])(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new __WEBPACK_IMPORTED_MODULE_0__Stack_js__["a" /* default */]);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (Object(__WEBPACK_IMPORTED_MODULE_19__isSet_js__["a" /* default */])(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });

    return result;
  }

  if (Object(__WEBPACK_IMPORTED_MODULE_17__isMap_js__["a" /* default */])(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });

    return result;
  }

  var keysFunc = isFull
    ? (isFlat ? __WEBPACK_IMPORTED_MODULE_10__getAllKeysIn_js__["a" /* default */] : __WEBPACK_IMPORTED_MODULE_9__getAllKeys_js__["a" /* default */])
    : (isFlat ? keysIn : __WEBPACK_IMPORTED_MODULE_20__keys_js__["default"]);

  var props = isArr ? undefined : keysFunc(value);
  Object(__WEBPACK_IMPORTED_MODULE_1__arrayEach_js__["a" /* default */])(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    Object(__WEBPACK_IMPORTED_MODULE_2__assignValue_js__["a" /* default */])(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseClone);


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ __webpack_exports__["a"] = (freeGlobal);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(155)))

/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/* harmony default export */ __webpack_exports__["a"] = (toSource);


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__defineProperty_js__ = __webpack_require__(90);


/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && __WEBPACK_IMPORTED_MODULE_0__defineProperty_js__["a" /* default */]) {
    Object(__WEBPACK_IMPORTED_MODULE_0__defineProperty_js__["a" /* default */])(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/* harmony default export */ __webpack_exports__["a"] = (baseAssignValue);


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getNative_js__ = __webpack_require__(10);


var defineProperty = (function() {
  try {
    var func = Object(__WEBPACK_IMPORTED_MODULE_0__getNative_js__["a" /* default */])(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* harmony default export */ __webpack_exports__["a"] = (defineProperty);


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseTimes_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isArguments_js__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isArray_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isBuffer_js__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__isIndex_js__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__isTypedArray_js__ = __webpack_require__(92);







/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = Object(__WEBPACK_IMPORTED_MODULE_2__isArray_js__["default"])(value),
      isArg = !isArr && Object(__WEBPACK_IMPORTED_MODULE_1__isArguments_js__["a" /* default */])(value),
      isBuff = !isArr && !isArg && Object(__WEBPACK_IMPORTED_MODULE_3__isBuffer_js__["a" /* default */])(value),
      isType = !isArr && !isArg && !isBuff && Object(__WEBPACK_IMPORTED_MODULE_5__isTypedArray_js__["a" /* default */])(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? Object(__WEBPACK_IMPORTED_MODULE_0__baseTimes_js__["a" /* default */])(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           Object(__WEBPACK_IMPORTED_MODULE_4__isIndex_js__["a" /* default */])(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayLikeKeys);


/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIsTypedArray_js__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseUnary_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__ = __webpack_require__(59);




/* Node.js helper references. */
var nodeIsTypedArray = __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__["a" /* default */] && __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__["a" /* default */].isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? Object(__WEBPACK_IMPORTED_MODULE_1__baseUnary_js__["a" /* default */])(nodeIsTypedArray) : __WEBPACK_IMPORTED_MODULE_0__baseIsTypedArray_js__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (isTypedArray);


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (overArg);


/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/* harmony default export */ __webpack_exports__["a"] = (stubArray);


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayPush_js__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getPrototype_js__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__getSymbols_js__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__stubArray_js__ = __webpack_require__(94);





/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? __WEBPACK_IMPORTED_MODULE_3__stubArray_js__["a" /* default */] : function(object) {
  var result = [];
  while (object) {
    Object(__WEBPACK_IMPORTED_MODULE_0__arrayPush_js__["a" /* default */])(result, Object(__WEBPACK_IMPORTED_MODULE_2__getSymbols_js__["a" /* default */])(object));
    object = Object(__WEBPACK_IMPORTED_MODULE_1__getPrototype_js__["a" /* default */])(object);
  }
  return result;
};

/* harmony default export */ __webpack_exports__["a"] = (getSymbolsIn);


/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetAllKeys_js__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getSymbols_js__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__keys_js__ = __webpack_require__(11);




/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseGetAllKeys_js__["a" /* default */])(object, __WEBPACK_IMPORTED_MODULE_2__keys_js__["default"], __WEBPACK_IMPORTED_MODULE_1__getSymbols_js__["a" /* default */]);
}

/* harmony default export */ __webpack_exports__["a"] = (getAllKeys);


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayPush_js__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isArray_js__ = __webpack_require__(1);



/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return Object(__WEBPACK_IMPORTED_MODULE_1__isArray_js__["default"])(object) ? result : Object(__WEBPACK_IMPORTED_MODULE_0__arrayPush_js__["a" /* default */])(result, symbolsFunc(object));
}

/* harmony default export */ __webpack_exports__["a"] = (baseGetAllKeys);


/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getNative_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__root_js__ = __webpack_require__(4);



/* Built-in method references that are verified to be native. */
var Set = Object(__WEBPACK_IMPORTED_MODULE_0__getNative_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__root_js__["a" /* default */], 'Set');

/* harmony default export */ __webpack_exports__["a"] = (Set);


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getNative_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__root_js__ = __webpack_require__(4);



/* Built-in method references that are verified to be native. */
var WeakMap = Object(__WEBPACK_IMPORTED_MODULE_0__getNative_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__root_js__["a" /* default */], 'WeakMap');

/* harmony default export */ __webpack_exports__["a"] = (WeakMap);


/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(4);


/** Built-in value references. */
var Uint8Array = __WEBPACK_IMPORTED_MODULE_0__root_js__["a" /* default */].Uint8Array;

/* harmony default export */ __webpack_exports__["a"] = (Uint8Array);


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__apply_js__ = __webpack_require__(68);


/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return Object(__WEBPACK_IMPORTED_MODULE_0__apply_js__["a" /* default */])(func, this, otherArgs);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (overRest);


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (shortOut);


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__basePick_js__ = __webpack_require__(200);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatRest_js__ = __webpack_require__(72);



/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = Object(__WEBPACK_IMPORTED_MODULE_1__flatRest_js__["a" /* default */])(function(object, paths) {
  return object == null ? {} : Object(__WEBPACK_IMPORTED_MODULE_0__basePick_js__["a" /* default */])(object, paths);
});

/* harmony default export */ __webpack_exports__["default"] = (pick);


/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGet_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseSet_js__ = __webpack_require__(205);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__castPath_js__ = __webpack_require__(19);




/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = Object(__WEBPACK_IMPORTED_MODULE_0__baseGet_js__["a" /* default */])(object, path);

    if (predicate(value, path)) {
      Object(__WEBPACK_IMPORTED_MODULE_1__baseSet_js__["a" /* default */])(result, Object(__WEBPACK_IMPORTED_MODULE_2__castPath_js__["a" /* default */])(path, object), value);
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (basePickBy);


/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseToString_js__ = __webpack_require__(204);


/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : Object(__WEBPACK_IMPORTED_MODULE_0__baseToString_js__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (toString);


/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseHasIn_js__ = __webpack_require__(206);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hasPath_js__ = __webpack_require__(107);



/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && Object(__WEBPACK_IMPORTED_MODULE_1__hasPath_js__["a" /* default */])(object, path, __WEBPACK_IMPORTED_MODULE_0__baseHasIn_js__["a" /* default */]);
}

/* harmony default export */ __webpack_exports__["a"] = (hasIn);


/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__castPath_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isArguments_js__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isArray_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isIndex_js__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__isLength_js__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__toKey_js__ = __webpack_require__(20);







/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = Object(__WEBPACK_IMPORTED_MODULE_0__castPath_js__["a" /* default */])(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = Object(__WEBPACK_IMPORTED_MODULE_5__toKey_js__["a" /* default */])(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && Object(__WEBPACK_IMPORTED_MODULE_4__isLength_js__["a" /* default */])(length) && Object(__WEBPACK_IMPORTED_MODULE_3__isIndex_js__["a" /* default */])(key, length) &&
    (Object(__WEBPACK_IMPORTED_MODULE_2__isArray_js__["default"])(object) || Object(__WEBPACK_IMPORTED_MODULE_1__isArguments_js__["a" /* default */])(object));
}

/* harmony default export */ __webpack_exports__["a"] = (hasPath);


/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIsEqual_js__ = __webpack_require__(74);


/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseIsEqual_js__["a" /* default */])(value, other);
}

/* harmony default export */ __webpack_exports__["default"] = (isEqual);


/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__SetCache_js__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arraySome_js__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cacheHas_js__ = __webpack_require__(40);




/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new __WEBPACK_IMPORTED_MODULE_0__SetCache_js__["a" /* default */] : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!Object(__WEBPACK_IMPORTED_MODULE_1__arraySome_js__["a" /* default */])(other, function(othValue, othIndex) {
            if (!Object(__WEBPACK_IMPORTED_MODULE_2__cacheHas_js__["a" /* default */])(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (equalArrays);


/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

/* harmony default export */ __webpack_exports__["default"] = (isUndefined);


/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

/* harmony default export */ __webpack_exports__["default"] = (last);


/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayFilter_js__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseFilter_js__ = __webpack_require__(227);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseIteratee_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isArray_js__ = __webpack_require__(1);





/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 */
function filter(collection, predicate) {
  var func = Object(__WEBPACK_IMPORTED_MODULE_3__isArray_js__["default"])(collection) ? __WEBPACK_IMPORTED_MODULE_0__arrayFilter_js__["a" /* default */] : __WEBPACK_IMPORTED_MODULE_1__baseFilter_js__["a" /* default */];
  return func(collection, Object(__WEBPACK_IMPORTED_MODULE_2__baseIteratee_js__["a" /* default */])(predicate, 3));
}

/* harmony default export */ __webpack_exports__["default"] = (filter);


/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isObject_js__ = __webpack_require__(6);


/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !Object(__WEBPACK_IMPORTED_MODULE_0__isObject_js__["a" /* default */])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (isStrictComparable);


/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/* harmony default export */ __webpack_exports__["a"] = (matchesStrictComparable);


/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/* harmony default export */ __webpack_exports__["a"] = (baseProperty);


/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFindIndex_js__ = __webpack_require__(241);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIsNaN_js__ = __webpack_require__(242);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__strictIndexOf_js__ = __webpack_require__(243);




/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? Object(__WEBPACK_IMPORTED_MODULE_2__strictIndexOf_js__["a" /* default */])(array, value, fromIndex)
    : Object(__WEBPACK_IMPORTED_MODULE_0__baseFindIndex_js__["a" /* default */])(array, __WEBPACK_IMPORTED_MODULE_1__baseIsNaN_js__["a" /* default */], fromIndex);
}

/* harmony default export */ __webpack_exports__["a"] = (baseIndexOf);


/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__identity_js__ = __webpack_require__(18);


/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : __WEBPACK_IMPORTED_MODULE_0__identity_js__["a" /* default */];
}

/* harmony default export */ __webpack_exports__["a"] = (castFunction);


/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createFlow_js__ = __webpack_require__(245);


/**
 * Creates a function that returns the result of invoking the given functions
 * with the `this` binding of the created function, where each successive
 * invocation is supplied the return value of the previous.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {...(Function|Function[])} [funcs] The functions to invoke.
 * @returns {Function} Returns the new composite function.
 * @see _.flowRight
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var addSquare = _.flow([_.add, square]);
 * addSquare(1, 2);
 * // => 9
 */
var flow = Object(__WEBPACK_IMPORTED_MODULE_0__createFlow_js__["a" /* default */])();

/* harmony default export */ __webpack_exports__["default"] = (flow);


/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__WeakMap_js__ = __webpack_require__(99);


/** Used to store function metadata. */
var metaMap = __WEBPACK_IMPORTED_MODULE_0__WeakMap_js__["a" /* default */] && new __WEBPACK_IMPORTED_MODULE_0__WeakMap_js__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (metaMap);


/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

/* harmony default export */ __webpack_exports__["a"] = (noop);


/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__realNames_js__ = __webpack_require__(246);


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the name of `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {string} Returns the function name.
 */
function getFuncName(func) {
  var result = (func.name + ''),
      array = __WEBPACK_IMPORTED_MODULE_0__realNames_js__["a" /* default */][result],
      length = hasOwnProperty.call(__WEBPACK_IMPORTED_MODULE_0__realNames_js__["a" /* default */], result) ? array.length : 0;

  while (length--) {
    var data = array[length],
        otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (getFuncName);


/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LazyWrapper_js__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getData_js__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__getFuncName_js__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__wrapperLodash_js__ = __webpack_require__(247);





/**
 * Checks if `func` has a lazy counterpart.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
 *  else `false`.
 */
function isLaziable(func) {
  var funcName = Object(__WEBPACK_IMPORTED_MODULE_2__getFuncName_js__["a" /* default */])(func),
      other = __WEBPACK_IMPORTED_MODULE_3__wrapperLodash_js__["a" /* default */][funcName];

  if (typeof other != 'function' || !(funcName in __WEBPACK_IMPORTED_MODULE_0__LazyWrapper_js__["a" /* default */].prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = Object(__WEBPACK_IMPORTED_MODULE_1__getData_js__["a" /* default */])(other);
  return !!data && func === data[0];
}

/* harmony default export */ __webpack_exports__["a"] = (isLaziable);


/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(5);



/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a" /* default */])(value) && Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a" /* default */])(value) == numberTag);
}

/* harmony default export */ __webpack_exports__["default"] = (isNumber);


/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseEach_js__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isArrayLike_js__ = __webpack_require__(17);



/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = Object(__WEBPACK_IMPORTED_MODULE_1__isArrayLike_js__["a" /* default */])(collection) ? Array(collection.length) : [];

  Object(__WEBPACK_IMPORTED_MODULE_0__baseEach_js__["a" /* default */])(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseMap);


/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseRest_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__createWrap_js__ = __webpack_require__(252);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__getHolder_js__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__replaceHolders_js__ = __webpack_require__(46);





/** Used to compose bitmasks for function metadata. */
var WRAP_PARTIAL_RIGHT_FLAG = 64;

/**
 * This method is like `_.partial` except that partially applied arguments
 * are appended to the arguments it receives.
 *
 * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
 * builds, may be used as a placeholder for partially applied arguments.
 *
 * **Note:** This method doesn't set the "length" property of partially
 * applied functions.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Function
 * @param {Function} func The function to partially apply arguments to.
 * @param {...*} [partials] The arguments to be partially applied.
 * @returns {Function} Returns the new partially applied function.
 * @example
 *
 * function greet(greeting, name) {
 *   return greeting + ' ' + name;
 * }
 *
 * var greetFred = _.partialRight(greet, 'fred');
 * greetFred('hi');
 * // => 'hi fred'
 *
 * // Partially applied with placeholders.
 * var sayHelloTo = _.partialRight(greet, 'hello', _);
 * sayHelloTo('fred');
 * // => 'hello fred'
 */
var partialRight = Object(__WEBPACK_IMPORTED_MODULE_0__baseRest_js__["a" /* default */])(function(func, partials) {
  var holders = Object(__WEBPACK_IMPORTED_MODULE_3__replaceHolders_js__["a" /* default */])(partials, Object(__WEBPACK_IMPORTED_MODULE_2__getHolder_js__["a" /* default */])(partialRight));
  return Object(__WEBPACK_IMPORTED_MODULE_1__createWrap_js__["a" /* default */])(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
});

// Assign default placeholders.
partialRight.placeholder = {};

/* harmony default export */ __webpack_exports__["default"] = (partialRight);


/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__identity_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__metaMap_js__ = __webpack_require__(119);



/**
 * The base implementation of `setData` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var baseSetData = !__WEBPACK_IMPORTED_MODULE_1__metaMap_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__identity_js__["a" /* default */] : function(func, data) {
  __WEBPACK_IMPORTED_MODULE_1__metaMap_js__["a" /* default */].set(func, data);
  return func;
};

/* harmony default export */ __webpack_exports__["a"] = (baseSetData);


/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__composeArgs_js__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__composeArgsRight_js__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__countHolders_js__ = __webpack_require__(255);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__createCtor_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__createRecurry_js__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__getHolder_js__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__reorder_js__ = __webpack_require__(259);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__replaceHolders_js__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__root_js__ = __webpack_require__(4);










/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_FLAG = 8,
    WRAP_CURRY_RIGHT_FLAG = 16,
    WRAP_ARY_FLAG = 128,
    WRAP_FLIP_FLAG = 512;

/**
 * Creates a function that wraps `func` to invoke it with optional `this`
 * binding of `thisArg`, partial application, and currying.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [partialsRight] The arguments to append to those provided
 *  to the new function.
 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG,
      isBind = bitmask & WRAP_BIND_FLAG,
      isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
      isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
      isFlip = bitmask & WRAP_FLIP_FLAG,
      Ctor = isBindKey ? undefined : Object(__WEBPACK_IMPORTED_MODULE_3__createCtor_js__["a" /* default */])(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length;

    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder = Object(__WEBPACK_IMPORTED_MODULE_5__getHolder_js__["a" /* default */])(wrapper),
          holdersCount = Object(__WEBPACK_IMPORTED_MODULE_2__countHolders_js__["a" /* default */])(args, placeholder);
    }
    if (partials) {
      args = Object(__WEBPACK_IMPORTED_MODULE_0__composeArgs_js__["a" /* default */])(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = Object(__WEBPACK_IMPORTED_MODULE_1__composeArgsRight_js__["a" /* default */])(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = Object(__WEBPACK_IMPORTED_MODULE_7__replaceHolders_js__["a" /* default */])(args, placeholder);
      return Object(__WEBPACK_IMPORTED_MODULE_4__createRecurry_js__["a" /* default */])(
        func, bitmask, createHybrid, wrapper.placeholder, thisArg,
        args, newHolders, argPos, ary, arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this,
        fn = isBindKey ? thisBinding[func] : func;

    length = args.length;
    if (argPos) {
      args = Object(__WEBPACK_IMPORTED_MODULE_6__reorder_js__["a" /* default */])(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary < length) {
      args.length = ary;
    }
    if (this && this !== __WEBPACK_IMPORTED_MODULE_8__root_js__["a" /* default */] && this instanceof wrapper) {
      fn = Ctor || Object(__WEBPACK_IMPORTED_MODULE_3__createCtor_js__["a" /* default */])(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}

/* harmony default export */ __webpack_exports__["a"] = (createHybrid);


/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates an array that is the composition of partially applied arguments,
 * placeholders, and provided arguments into a single array of arguments.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to prepend to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersLength = holders.length,
      leftIndex = -1,
      leftLength = partials.length,
      rangeLength = nativeMax(argsLength - holdersLength, 0),
      result = Array(leftLength + rangeLength),
      isUncurried = !isCurried;

  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (composeArgs);


/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This function is like `composeArgs` except that the arguments composition
 * is tailored for `_.partialRight`.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to append to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersIndex = -1,
      holdersLength = holders.length,
      rightIndex = -1,
      rightLength = partials.length,
      rangeLength = nativeMax(argsLength - holdersLength, 0),
      result = Array(rangeLength + rightLength),
      isUncurried = !isCurried;

  while (++argsIndex < rangeLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (composeArgsRight);


/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isLaziable_js__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__setData_js__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__setWrapToString_js__ = __webpack_require__(132);




/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_BOUND_FLAG = 4,
    WRAP_CURRY_FLAG = 8,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_PARTIAL_RIGHT_FLAG = 64;

/**
 * Creates a function that wraps `func` to continue currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {Function} wrapFunc The function to create the `func` wrapper.
 * @param {*} placeholder The placeholder value.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG,
      newHolders = isCurry ? holders : undefined,
      newHoldersRight = isCurry ? undefined : holders,
      newPartials = isCurry ? partials : undefined,
      newPartialsRight = isCurry ? undefined : partials;

  bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
    bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
  }
  var newData = [
    func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
    newHoldersRight, argPos, ary, arity
  ];

  var result = wrapFunc.apply(undefined, newData);
  if (Object(__WEBPACK_IMPORTED_MODULE_0__isLaziable_js__["a" /* default */])(func)) {
    Object(__WEBPACK_IMPORTED_MODULE_1__setData_js__["a" /* default */])(result, newData);
  }
  result.placeholder = placeholder;
  return Object(__WEBPACK_IMPORTED_MODULE_2__setWrapToString_js__["a" /* default */])(result, func, bitmask);
}

/* harmony default export */ __webpack_exports__["a"] = (createRecurry);


/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSetData_js__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shortOut_js__ = __webpack_require__(102);



/**
 * Sets metadata for `func`.
 *
 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
 * period of time, it will trip its breaker and transition to an identity
 * function to avoid garbage collection pauses in V8. See
 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
 * for more details.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var setData = Object(__WEBPACK_IMPORTED_MODULE_1__shortOut_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_0__baseSetData_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["a"] = (setData);


/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getWrapDetails_js__ = __webpack_require__(256);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__insertWrapDetails_js__ = __webpack_require__(257);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__setToString_js__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__updateWrapDetails_js__ = __webpack_require__(258);





/**
 * Sets the `toString` method of `wrapper` to mimic the source of `reference`
 * with wrapper details in a comment at the top of the source body.
 *
 * @private
 * @param {Function} wrapper The function to modify.
 * @param {Function} reference The reference function.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @returns {Function} Returns `wrapper`.
 */
function setWrapToString(wrapper, reference, bitmask) {
  var source = (reference + '');
  return Object(__WEBPACK_IMPORTED_MODULE_2__setToString_js__["a" /* default */])(wrapper, Object(__WEBPACK_IMPORTED_MODULE_1__insertWrapDetails_js__["a" /* default */])(source, Object(__WEBPACK_IMPORTED_MODULE_3__updateWrapDetails_js__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_0__getWrapDetails_js__["a" /* default */])(source), bitmask)));
}

/* harmony default export */ __webpack_exports__["a"] = (setWrapToString);


/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__SetCache_js__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayIncludes_js__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__arrayIncludesWith_js__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__cacheHas_js__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__createSet_js__ = __webpack_require__(265);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__setToArray_js__ = __webpack_require__(75);







/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = __WEBPACK_IMPORTED_MODULE_1__arrayIncludes_js__["a" /* default */],
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = __WEBPACK_IMPORTED_MODULE_2__arrayIncludesWith_js__["a" /* default */];
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : Object(__WEBPACK_IMPORTED_MODULE_4__createSet_js__["a" /* default */])(array);
    if (set) {
      return Object(__WEBPACK_IMPORTED_MODULE_5__setToArray_js__["a" /* default */])(set);
    }
    isCommon = false;
    includes = __WEBPACK_IMPORTED_MODULE_3__cacheHas_js__["a" /* default */];
    seen = new __WEBPACK_IMPORTED_MODULE_0__SetCache_js__["a" /* default */];
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseUniq);


/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseUniq_js__ = __webpack_require__(133);


/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length) ? Object(__WEBPACK_IMPORTED_MODULE_0__baseUniq_js__["a" /* default */])(array) : [];
}

/* harmony default export */ __webpack_exports__["default"] = (uniq);


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
/* tslint:disable:max-classes-per-file */
var BinaryExpr = /** @class */ (function () {
    function BinaryExpr(operator, leftOperand, rightOperand) {
        this.operator = operator;
        this.leftOperand = leftOperand;
        this.rightOperand = rightOperand;
    }
    return BinaryExpr;
}());
exports.BinaryExpr = BinaryExpr;
// Unary Expression
var UnaryExpr = /** @class */ (function () {
    function UnaryExpr(operator, operand) {
        this.operator = operator;
        this.operand = operand;
    }
    return UnaryExpr;
}());
exports.UnaryExpr = UnaryExpr;
// Function call
var FuncCall = /** @class */ (function () {
    function FuncCall(funcName, args, preComputeUniformName) {
        this.funcName = funcName;
        this.args = args;
        this.preComputeUniformName = preComputeUniformName;
    }
    return FuncCall;
}());
exports.FuncCall = FuncCall;
// Variable assignment
var Assignment = /** @class */ (function () {
    function Assignment(lhs, expr) {
        this.lhs = lhs;
        this.expr = expr;
    }
    return Assignment;
}());
exports.Assignment = Assignment;
// Code start symbol
var Program = /** @class */ (function () {
    function Program(statements) {
        this.statements = statements;
    }
    return Program;
}());
exports.Program = Program;
var PrimaryExprType;
(function (PrimaryExprType) {
    PrimaryExprType["ID"] = "ID";
    PrimaryExprType["CONST"] = "CONST";
    PrimaryExprType["REG"] = "REG";
    PrimaryExprType["VALUE"] = "VALUE";
})(PrimaryExprType = exports.PrimaryExprType || (exports.PrimaryExprType = {}));
// Atomic expression
var PrimaryExpr = /** @class */ (function () {
    function PrimaryExpr(value, type) {
        this.value = value;
        this.type = type;
    }
    return PrimaryExpr;
}());
exports.PrimaryExpr = PrimaryExpr;


/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assignIn_js__ = __webpack_require__(269);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return __WEBPACK_IMPORTED_MODULE_0__assignIn_js__["a"]; });



/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSlice_js__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toInteger_js__ = __webpack_require__(21);



/**
 * Creates a slice of `array` with `n` elements taken from the beginning.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to take.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.take([1, 2, 3]);
 * // => [1]
 *
 * _.take([1, 2, 3], 2);
 * // => [1, 2]
 *
 * _.take([1, 2, 3], 5);
 * // => [1, 2, 3]
 *
 * _.take([1, 2, 3], 0);
 * // => []
 */
function take(array, n, guard) {
  if (!(array && array.length)) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : Object(__WEBPACK_IMPORTED_MODULE_1__toInteger_js__["a" /* default */])(n);
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseSlice_js__["a" /* default */])(array, 0, n < 0 ? 0 : n);
}

/* harmony default export */ __webpack_exports__["default"] = (take);


/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseTimes_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__castFunction_js__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__toInteger_js__ = __webpack_require__(21);




/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Invokes the iteratee `n` times, returning an array of the results of
 * each invocation. The iteratee is invoked with one argument; (index).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 * @example
 *
 * _.times(3, String);
 * // => ['0', '1', '2']
 *
 *  _.times(4, _.constant(0));
 * // => [0, 0, 0, 0]
 */
function times(n, iteratee) {
  n = Object(__WEBPACK_IMPORTED_MODULE_2__toInteger_js__["a" /* default */])(n);
  if (n < 1 || n > MAX_SAFE_INTEGER) {
    return [];
  }
  var index = MAX_ARRAY_LENGTH,
      length = nativeMin(n, MAX_ARRAY_LENGTH);

  iteratee = Object(__WEBPACK_IMPORTED_MODULE_1__castFunction_js__["a" /* default */])(iteratee);
  n -= MAX_ARRAY_LENGTH;

  var result = Object(__WEBPACK_IMPORTED_MODULE_0__baseTimes_js__["a" /* default */])(length, iteratee);
  while (++index < n) {
    iteratee(index);
  }
  return result;
}

/* harmony default export */ __webpack_exports__["default"] = (times);


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var isNumber_1 = __webpack_require__(123);
var isString_1 = __webpack_require__(73);
var isUndefined_1 = __webpack_require__(110);
/**
 * TextureSetManager maintains a set of named/indexed textures and optionally, a
 * FrameBuffer for offscreen rendering.
 */
var TextureSetManager = /** @class */ (function () {
    /**
     * Creates a new TextureSetManager
     * @param rctx the rendering context in which the textures and buffers will be created
     * @param copier an instance of a copier program
     * @param hasFrameBuffer if true, then a FrameBuffer is also created
     * @param texCount initial number of textures
     */
    function TextureSetManager(rctx, copier, hasFrameBuffer, texCount) {
        if (hasFrameBuffer === void 0) { hasFrameBuffer = false; }
        if (texCount === void 0) { texCount = 2; }
        this.rctx = rctx;
        this.copier = copier;
        this.initTexCount = texCount;
        this.hasFrameBuffer = hasFrameBuffer;
        this.init();
    }
    /**
     * Adds the texture
     * @param name name of the texture
     */
    TextureSetManager.prototype.addTexture = function (name) {
        if (name && name in this.names) {
            this.names[name].refCount++;
            return this.names[name].index;
        }
        var gl = this.rctx.getGl();
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.drawingBufferWidth, gl.drawingBufferHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        this.textures.push(texture);
        if (name) {
            this.names[name] = {
                index: this.textures.length - 1,
                refCount: 1
            };
        }
        return this.textures.length - 1;
    };
    /**
     * Removes a texture
     * @param nameOrIndex name or index of the texture to be removed
     */
    TextureSetManager.prototype.removeTexture = function (nameOrIndex) {
        if (isString_1["default"](nameOrIndex) && nameOrIndex in this.names) {
            if (this.names[nameOrIndex].refCount > 1) {
                this.names[nameOrIndex].refCount--;
                return;
            }
        }
        var index = this.findIndex(nameOrIndex);
        if (index === this.curTex && (this.oldTexture || this.oldFrameBuffer)) {
            throw new Error("Cannot remove current texture when set as render target");
        }
        var gl = this.rctx.getGl();
        gl.deleteTexture(this.textures[index]);
        this.textures.splice(index, 1);
        if (this.curTex >= this.textures.length) {
            this.curTex = this.textures.length - 1;
        }
        if (typeof nameOrIndex === "string") {
            delete this.names[nameOrIndex];
        }
    };
    /**
     * Sets the current texture as the frame buffer attachment. If `hasFrameBuffer` is true
     * then the FrameBuffer manager is bound and the texture is set as the frame buffer attachment.
     * @param texName name of the texture to set as target. If undefined then we cycle
     *                through to next texture
     */
    TextureSetManager.prototype.setAsRenderTarget = function (texName) {
        var gl = this.rctx.getGl();
        var curFrameBuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        if (!this.hasFrameBuffer) {
            if (!curFrameBuffer) {
                throw new Error("Cannot set texture when current rendertarget is the default FrameBuffer");
            }
            this.oldTexture = gl.getFramebufferAttachmentParameter(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME);
        }
        else {
            this.oldFrameBuffer = curFrameBuffer;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        }
        this.isRenderTarget = true;
        if (!isUndefined_1["default"](texName)) {
            this.switchTexture(texName);
        }
        else {
            var texture = this.textures[this.curTex];
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        }
    };
    /**
     * Restores the texture attachment or framebuffer that was set
     * with a previous call to [[TextureSetManager.setAsRenderTarget]]
     */
    TextureSetManager.prototype.unsetAsRenderTarget = function () {
        var gl = this.rctx.getGl();
        if (!this.hasFrameBuffer) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.oldTexture, 0);
            this.oldTexture = null;
        }
        else {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.oldFrameBuffer);
            this.oldFrameBuffer = null;
        }
        this.isRenderTarget = false;
    };
    /**
     * Returns the current texture.
     *
     * TextureSetManager has this notion of current texture
     * that it can cycle through the set of all textures.
     */
    TextureSetManager.prototype.getCurrentTexture = function () {
        return this.textures[this.curTex];
    };
    /**
     * Returns the texture at given index or with given nam,e
     * @param nameorIndex name of index of the texture to be returned
     */
    TextureSetManager.prototype.getTexture = function (nameOrIndex) {
        var index = this.findIndex(nameOrIndex);
        return this.textures[index];
    };
    /**
     * Copies previous texture into current texture.
     */
    TextureSetManager.prototype.copyOver = function () {
        var texCount = this.textures.length;
        var prevTexture = this.textures[(texCount + this.curTex - 1) % texCount];
        this.copier.run(null, { srcTexture: prevTexture });
    };
    /**
     * Sets the current texture and sets it as the current frame buffer attachment
     * @param nameOrIndex name or index of the texture. If undefined then we cycle through
     *                    to next texture
     */
    TextureSetManager.prototype.switchTexture = function (nameOrIndex) {
        if (nameOrIndex === void 0) { nameOrIndex = (this.curTex + 1) % this.textures.length; }
        if (!this.isRenderTarget) {
            throw new Error("Cannot switch texture when not set as rendertarget");
        }
        var gl = this.rctx.getGl();
        this.curTex = this.findIndex(nameOrIndex);
        var texture = this.textures[this.curTex];
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    };
    /**
     * Resizes all textures
     */
    TextureSetManager.prototype.resize = function () {
        // TODO: investigate chrome warning: INVALID_OPERATION: no texture
        var gl = this.rctx.getGl();
        for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {
            var texture = _a[_i];
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.drawingBufferWidth, gl.drawingBufferHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
    };
    /**
     * Destroys all texture and framebuffer
     */
    TextureSetManager.prototype.destroy = function () {
        var gl = this.rctx.getGl();
        for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {
            var texture = _a[_i];
            gl.deleteTexture(texture);
        }
        if (this.hasFrameBuffer) {
            gl.deleteFramebuffer(this.framebuffer);
        }
    };
    TextureSetManager.prototype.init = function () {
        var gl = this.rctx.getGl();
        if (this.hasFrameBuffer) {
            this.framebuffer = gl.createFramebuffer();
        }
        this.names = {};
        this.textures = [];
        for (var i = 0; i < this.initTexCount; i++) {
            this.addTexture();
        }
        this.curTex = 0;
        this.isRenderTarget = false;
    };
    TextureSetManager.prototype.findIndex = function (arg) {
        var index;
        if (isString_1["default"](arg) && arg in this.names) {
            index = this.names[arg].index;
        }
        else if (isNumber_1["default"](arg) && arg >= 0 && arg < this.textures.length) {
            index = arg;
        }
        else {
            // tslint:disable-next-line:no-console
            console.log("arg = ", typeof (arg), "textures = ", this.textures);
            throw new Error("Unknown texture '" + arg + "'");
        }
        return index;
    };
    return TextureSetManager;
}());
exports["default"] = TextureSetManager;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var utils_1 = __webpack_require__(0);
var ShaderProgram_1 = __webpack_require__(3);
/**
 * A Shader program the clears the screen to a given color
 */
var ClearScreenProgram = /** @class */ (function (_super) {
    __extends(ClearScreenProgram, _super);
    /**
     * Creates new ClearScreenProgram
     * @param rctx the rendering context in which to create this shader
     * @param blendMode blend mode for this shader
     */
    function ClearScreenProgram(rctx, blendMode) {
        return _super.call(this, rctx, {
            bindings: {
                uniforms: {
                    color: { name: "u_color", valueType: utils_1.WebGLVarType._3FV }
                }
            },
            blendMode: blendMode,
            fragmentShader: "\n                uniform vec3 u_color;\n                void main() {\n                setFragColor(vec4(u_color, 1));\n                }\n            "
        }) || this;
    }
    return ClearScreenProgram;
}(ShaderProgram_1["default"]));
exports["default"] = ClearScreenProgram;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
/**
 * AnalyserAdapter adapts music data analysers so that it can be plugged into Webvs.
 *
 * Implement this to send music data into webvs
 */
var AnalyserAdapter = /** @class */ (function () {
    function AnalyserAdapter() {
    }
    return AnalyserAdapter;
}());
exports["default"] = AnalyserAdapter;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Main_1 = __webpack_require__(143);
var Component_1 = __webpack_require__(2);
var WebAudioAnalyser_1 = __webpack_require__(309);
var AnalyserAdapter_1 = __webpack_require__(141);
var ShaderProgram_1 = __webpack_require__(3);
var Webvs = {
    Main: Main_1["default"], Component: Component_1["default"], ShaderProgram: ShaderProgram_1["default"],
    WebAudioAnalyser: WebAudioAnalyser_1["default"], AnalyserAdapter: AnalyserAdapter_1["default"]
};
exports["default"] = Webvs;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var clone_1 = __webpack_require__(47);
var defaults_1 = __webpack_require__(24);
var pick_1 = __webpack_require__(103);
var stats_js_1 = __webpack_require__(208);
var builtinResourcePack_1 = __webpack_require__(209);
var ComponentRegistry_1 = __webpack_require__(210);
var EffectList_1 = __webpack_require__(211);
var BufferSave_1 = __webpack_require__(274);
var GlobalVar_1 = __webpack_require__(275);
var Model_1 = __webpack_require__(76);
var ClearScreen_1 = __webpack_require__(276);
var MovingParticle_1 = __webpack_require__(278);
var Picture_1 = __webpack_require__(279);
var SuperScope_1 = __webpack_require__(280);
var Texer_1 = __webpack_require__(281);
var ResourceManager_1 = __webpack_require__(282);
var ChannelShift_1 = __webpack_require__(284);
var ColorClip_1 = __webpack_require__(286);
var ColorMap_1 = __webpack_require__(287);
var Convolution_1 = __webpack_require__(297);
var DynamicMovement_1 = __webpack_require__(301);
var FadeOut_1 = __webpack_require__(302);
var Invert_1 = __webpack_require__(303);
var Mirror_1 = __webpack_require__(304);
var Mosaic_1 = __webpack_require__(305);
var UniqueTone_1 = __webpack_require__(306);
var utils_1 = __webpack_require__(0);
var CopyProgram_1 = __webpack_require__(307);
var RenderingContext_1 = __webpack_require__(308);
var TextureSetManager_1 = __webpack_require__(139);
/**
 * Main is the primary interface that controls loading of presets, starting stopping animations, etc.
 * It maintains the root Component and the hierarchy of components under it.
 * A typical usage involves creating an Analyser and a Main object. The Analyser interfaces with your
 * audio source and generates the visualization data, while the Main object serves as the primary
 * interface for controlling the visualization. E.g:
 * ```
 * const analyser = new Webvs.WebAudioAnalyser();
 * const webvs = new Webvs.Main({
 *     canvas: document.getElementById("canvas"),
 *     analyser: analyser,
 *     showStat: true
 * });
 * webvs.loadPreset({
 *   "clearFrame": true,
 *   "components": [
 *       {
 *           "type": "SuperScope",
 *           "source": "WAVEFORM",
 *           "code": {
 *               "perPoint": "x=i*2-1;y=v;"
 *           },
 *           "colors": ["#ffffff"]
 *       }
 *   ]
 * });
 * webvs.start();
 * analyser.load("music.ogg");
 * analyser.play();
 * ```
 */
var Main = /** @class */ (function (_super) {
    __extends(Main, _super);
    /**
     * Constructs a Webvs Main object that can load and render visualization presets
     * @param options options for Main
     */
    function Main(options) {
        var _this = _super.call(this) || this;
        _this.presetResourceKeys = [];
        utils_1.checkRequiredOptions(options, ["canvas", "analyser"]);
        options = defaults_1["default"](options, {
            showStat: false
        });
        _this.canvas = options.canvas;
        _this.analyser = options.analyser;
        _this.isStarted = false;
        if (options.requestAnimationFrame && options.cancelAnimationFrame) {
            _this.requestAnimationFrame = options.requestAnimationFrame;
            _this.cancelAnimationFrame = options.cancelAnimationFrame;
        }
        else {
            _this.requestAnimationFrame = window.requestAnimationFrame.bind(window);
            _this.cancelAnimationFrame = window.cancelAnimationFrame.bind(window);
        }
        if (options.showStat) {
            var stats = new stats_js_1["default"]();
            stats.setMode(0);
            stats.domElement.style.position = "absolute";
            stats.domElement.style.right = "5px";
            stats.domElement.style.bottom = "5px";
            document.body.appendChild(stats.domElement);
            _this.stats = stats;
        }
        _this.meta = {};
        _this.buffers = {};
        _this._initComponentRegistry();
        _this._initResourceManager(options.resourcePrefix || "");
        _this._registerContextEvents();
        _this._initGl();
        _this._setupRoot({ id: "root" });
        return _this;
    }
    /**
     * Starts running the animation when ready. The animation may not start
     * playing immediately because preset may use external resources which
     * needs to be loaded asynchronously by the resource manager.
     */
    Main.prototype.start = function () {
        if (this.isStarted) {
            return;
        }
        this.isStarted = true;
        if (this.rsrcMan.ready) {
            this._startAnimation();
        }
    };
    /**
     * Stops the animation
     */
    Main.prototype.stop = function () {
        if (!this.isStarted) {
            return;
        }
        this.isStarted = false;
        if (this.rsrcMan.ready) {
            this._stopAnimation();
        }
    };
    /**
     * Loads a preset into this webvs main instance.
     *
     * @param preset an object that contains the preset. The root object should
     * have a `components` property which will contain an Array for component configurations
     * for all the components. All component configurations should have a
     * `type` property containing the string name of the Component. Other
     * properties are specific to each component. The `resources.uris` property
     * in preset is used to register resources with [[ResourceManager]] and has
     * the same format accepted by the [[ResourceManager.registerUri]].
     */
    Main.prototype.loadPreset = function (preset) {
        preset = clone_1["default"](preset); // use our own copy
        preset.id = "root";
        this.rootComponent.destroy();
        // setup resources
        this.rsrcMan.clear(this.presetResourceKeys);
        if ("resources" in preset && "uris" in preset.resources) {
            this.rsrcMan.registerUri(preset.resources.uris);
            this.presetResourceKeys = Object.keys(preset.resources.uris);
        }
        else {
            this.presetResourceKeys = [];
        }
        // load meta
        this.meta = clone_1["default"](preset.meta);
        this._setupRoot(preset);
    };
    /**
     * Resets and reinitializes all the components and canvas.
     */
    Main.prototype.resetCanvas = function () {
        var preset = this.rootComponent.toJSON();
        this.rootComponent.destroy();
        this.tempTSM.destroy();
        this._initGl();
        this._setupRoot(preset);
    };
    /**
     * This function should be called if the canvas element's
     * width or height attribute has changed. This allows Webvs
     * to update and resize all the buffers.
     */
    Main.prototype.notifyResize = function () {
        var gl = this.rctx.getGl();
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        this.tempTSM.resize();
        this.emit("resize", gl.drawingBufferWidth, gl.drawingBufferHeight);
    };
    /**
     * Cache webgl Buffers. Useful to store buffers that can be shared. e.g. geometries.
     * @param name Name of the buffer
     * @param buffer Buffer to be cached
     */
    Main.prototype.cacheBuffer = function (name, buffer) {
        this.buffers[name] = buffer;
    };
    /**
     * Returns buffer cached under given name
     * @param name Name of the buffer
     * @returns The buffer cached under given name. `undefined` if not found.
     */
    Main.prototype.getBuffer = function (name) {
        return this.buffers[name];
    };
    /**
     * Gets the current value of a preset property. Eg. `main.get("meta")`
     * @param key preset property to be returned
     */
    Main.prototype.get = function (key) {
        if (key === "meta") {
            return this.meta;
        }
    };
    /**
     * Generates and returns the instantaneous preset JSON representation
     * @returns JSON representaton of the preset
     */
    Main.prototype.toJSON = function () {
        var preset = this.rootComponent.toJSON();
        preset = pick_1["default"](preset, "clearFrame", "components");
        preset.resources = this.rsrcMan.toJSON();
        preset.meta = clone_1["default"](this.meta);
        return preset;
    };
    /**
     * Destroys and cleans up all resources
     */
    Main.prototype.destroy = function () {
        this.stop();
        this.rootComponent.destroy();
        this.rootComponent = null;
        this.copier.destroy();
        for (var bufName in this.buffers) {
            if (!this.buffers.hasOwnProperty(bufName)) {
                continue;
            }
            this.buffers[bufName].destroy();
        }
        this.tempTSM.destroy();
        this.tempTSM = null;
        this.rctx.destroy();
        this.rctx = null;
        if (this.stats) {
            var statsDomElement = this.stats.domElement;
            statsDomElement.parentNode.removeChild(statsDomElement);
            this.stats = null;
        }
        this.rsrcMan = null;
        this.stopListening();
        this.canvas.removeEventListener("webglcontextlost", this.contextLostHander);
        this.canvas.removeEventListener("webglcontextrestored", this.contextRestoredHander);
    };
    /**
     * Returns the rendering context for webgl rendering
     */
    Main.prototype.getRctx = function () { return this.rctx; };
    /**
     * Returns the Resource Manager that manages media resources
     */
    Main.prototype.getRsrcMan = function () { return this.rsrcMan; };
    /**
     * Returns A shader program that can be used to copy frames
     */
    Main.prototype.getCopier = function () { return this.copier; };
    /**
     * Returns the analyser instance that's used to get music data
     * for the visualization
     */
    Main.prototype.getAnalyser = function () { return this.analyser; };
    /**
     * Returns a registry of [[Component]] classes that will be used
     * to create preset effects
     */
    Main.prototype.getComponentRegistry = function () { return this.componentRegistry; };
    /**
     * Returns a TextureSetManager for global temporary buffers, that can
     * be shared between components.
     */
    Main.prototype.getTempTSM = function () { return this.tempTSM; };
    /**
     * Returns register bank, a map of shared register values available
     * in EEL code in components.
     */
    Main.prototype.getRegisterBank = function () { return this.registerBank; };
    /**
     * Returns the timestamp at which this instance was constructed
     */
    Main.prototype.getBootTime = function () { return this.bootTime; };
    Main.prototype.setAttribute = function (key, value, options) {
        if (key === "meta") {
            this.meta = value;
            return true;
        }
        return false;
    };
    // event handlers
    Main.prototype.handleRsrcWait = function () {
        if (this.isStarted) {
            this._stopAnimation();
        }
    };
    Main.prototype.handleRsrcReady = function () {
        if (this.isStarted) {
            this._startAnimation();
        }
    };
    Main.prototype._initComponentRegistry = function () {
        this.componentRegistry = new ComponentRegistry_1["default"]([
            EffectList_1["default"],
            ClearScreen_1["default"],
            MovingParticle_1["default"],
            Picture_1["default"],
            SuperScope_1["default"],
            Texer_1["default"],
            ChannelShift_1["default"],
            ColorClip_1["default"],
            ColorMap_1["default"],
            Convolution_1["default"],
            DynamicMovement_1["default"],
            FadeOut_1["default"],
            Invert_1["default"],
            Mirror_1["default"],
            Mosaic_1["default"],
            UniqueTone_1["default"],
            BufferSave_1["default"],
            GlobalVar_1["default"],
        ]);
    };
    Main.prototype._initResourceManager = function (prefix) {
        var _this = this;
        var builtinPack = builtinResourcePack_1["default"];
        if (prefix) {
            builtinPack = clone_1["default"](builtinPack);
            builtinPack.prefix = prefix;
        }
        this.rsrcMan = new ResourceManager_1["default"](builtinPack);
        this.listenTo(this.rsrcMan, "wait", function () { return _this.handleRsrcWait(); });
        this.listenTo(this.rsrcMan, "ready", function () { return _this.handleRsrcReady(); });
    };
    Main.prototype._registerContextEvents = function () {
        var _this = this;
        this.contextLostHander = function (event) {
            event.preventDefault();
            _this.stop();
        };
        this.canvas.addEventListener("webglcontextlost", this.contextLostHander);
        this.contextRestoredHander = function (event) {
            _this.resetCanvas();
        };
        this.canvas.addEventListener("webglcontextrestored", this.contextRestoredHander);
    };
    Main.prototype._initGl = function () {
        try {
            var gl = this.canvas.getContext("webgl", { alpha: false });
            if (!gl) {
                throw new Error("context is falsy");
            }
            this.rctx = new RenderingContext_1["default"](gl);
            this.copier = new CopyProgram_1["default"](this.rctx, true);
            this.tempTSM = new TextureSetManager_1["default"](this.rctx, this.copier, true, 0);
        }
        catch (e) {
            throw new Error("Couldnt get webgl context" + e);
        }
    };
    Main.prototype._setupRoot = function (preset) {
        this.registerBank = {};
        this.bootTime = (new Date()).getTime();
        this.rootComponent = new EffectList_1["default"](this, null, preset);
    };
    Main.prototype._startAnimation = function () {
        var _this = this;
        var drawFrame = function () {
            _this.analyser.update();
            _this.rootComponent.draw();
            _this.animReqId = _this.requestAnimationFrame(drawFrame);
        };
        // Wrap drawframe in stats collection if required
        if (this.stats) {
            var oldDrawFrame_1 = drawFrame;
            drawFrame = function () {
                _this.stats.begin();
                oldDrawFrame_1();
                _this.stats.end();
            };
        }
        this.animReqId = this.requestAnimationFrame(drawFrame);
    };
    Main.prototype._stopAnimation = function () {
        this.cancelAnimationFrame(this.animReqId);
    };
    /**
     * version of Webvs library
     */
    Main.version = "3.0.0";
    return Main;
}(Model_1["default"]));
exports["default"] = Main;


/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/* harmony default export */ __webpack_exports__["a"] = (listCacheClear);


/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assocIndexOf_js__ = __webpack_require__(31);


/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = Object(__WEBPACK_IMPORTED_MODULE_0__assocIndexOf_js__["a" /* default */])(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/* harmony default export */ __webpack_exports__["a"] = (listCacheDelete);


/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assocIndexOf_js__ = __webpack_require__(31);


/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = Object(__WEBPACK_IMPORTED_MODULE_0__assocIndexOf_js__["a" /* default */])(data, key);

  return index < 0 ? undefined : data[index][1];
}

/* harmony default export */ __webpack_exports__["a"] = (listCacheGet);


/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assocIndexOf_js__ = __webpack_require__(31);


/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__assocIndexOf_js__["a" /* default */])(this.__data__, key) > -1;
}

/* harmony default export */ __webpack_exports__["a"] = (listCacheHas);


/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assocIndexOf_js__ = __webpack_require__(31);


/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = Object(__WEBPACK_IMPORTED_MODULE_0__assocIndexOf_js__["a" /* default */])(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/* harmony default export */ __webpack_exports__["a"] = (listCacheSet);


/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ListCache_js__ = __webpack_require__(30);


/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new __WEBPACK_IMPORTED_MODULE_0__ListCache_js__["a" /* default */];
  this.size = 0;
}

/* harmony default export */ __webpack_exports__["a"] = (stackClear);


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (stackDelete);


/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/* harmony default export */ __webpack_exports__["a"] = (stackGet);


/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* harmony default export */ __webpack_exports__["a"] = (stackHas);


/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ListCache_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Map_js__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__MapCache_js__ = __webpack_require__(51);




/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof __WEBPACK_IMPORTED_MODULE_0__ListCache_js__["a" /* default */]) {
    var pairs = data.__data__;
    if (!__WEBPACK_IMPORTED_MODULE_1__Map_js__["a" /* default */] || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new __WEBPACK_IMPORTED_MODULE_2__MapCache_js__["a" /* default */](pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/* harmony default export */ __webpack_exports__["a"] = (stackSet);


/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isFunction_js__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isMasked_js__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isObject_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__toSource_js__ = __webpack_require__(88);





/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_2__isObject_js__["a" /* default */])(value) || Object(__WEBPACK_IMPORTED_MODULE_1__isMasked_js__["a" /* default */])(value)) {
    return false;
  }
  var pattern = Object(__WEBPACK_IMPORTED_MODULE_0__isFunction_js__["default"])(value) ? reIsNative : reIsHostCtor;
  return pattern.test(Object(__WEBPACK_IMPORTED_MODULE_3__toSource_js__["a" /* default */])(value));
}

/* harmony default export */ __webpack_exports__["a"] = (baseIsNative);


/***/ }),
/* 155 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(14);


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (getRawTag);


/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/* harmony default export */ __webpack_exports__["a"] = (objectToString);


/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__coreJsData_js__ = __webpack_require__(159);


/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(__WEBPACK_IMPORTED_MODULE_0__coreJsData_js__["a" /* default */] && __WEBPACK_IMPORTED_MODULE_0__coreJsData_js__["a" /* default */].keys && __WEBPACK_IMPORTED_MODULE_0__coreJsData_js__["a" /* default */].keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/* harmony default export */ __webpack_exports__["a"] = (isMasked);


/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(4);


/** Used to detect overreaching core-js shims. */
var coreJsData = __WEBPACK_IMPORTED_MODULE_0__root_js__["a" /* default */]['__core-js_shared__'];

/* harmony default export */ __webpack_exports__["a"] = (coreJsData);


/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/* harmony default export */ __webpack_exports__["a"] = (getValue);


/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Hash_js__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ListCache_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Map_js__ = __webpack_require__(49);




/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new __WEBPACK_IMPORTED_MODULE_0__Hash_js__["a" /* default */],
    'map': new (__WEBPACK_IMPORTED_MODULE_2__Map_js__["a" /* default */] || __WEBPACK_IMPORTED_MODULE_1__ListCache_js__["a" /* default */]),
    'string': new __WEBPACK_IMPORTED_MODULE_0__Hash_js__["a" /* default */]
  };
}

/* harmony default export */ __webpack_exports__["a"] = (mapCacheClear);


/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__hashClear_js__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hashDelete_js__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__hashGet_js__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__hashHas_js__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__hashSet_js__ = __webpack_require__(167);






/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = __WEBPACK_IMPORTED_MODULE_0__hashClear_js__["a" /* default */];
Hash.prototype['delete'] = __WEBPACK_IMPORTED_MODULE_1__hashDelete_js__["a" /* default */];
Hash.prototype.get = __WEBPACK_IMPORTED_MODULE_2__hashGet_js__["a" /* default */];
Hash.prototype.has = __WEBPACK_IMPORTED_MODULE_3__hashHas_js__["a" /* default */];
Hash.prototype.set = __WEBPACK_IMPORTED_MODULE_4__hashSet_js__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (Hash);


/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__nativeCreate_js__ = __webpack_require__(32);


/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = __WEBPACK_IMPORTED_MODULE_0__nativeCreate_js__["a" /* default */] ? Object(__WEBPACK_IMPORTED_MODULE_0__nativeCreate_js__["a" /* default */])(null) : {};
  this.size = 0;
}

/* harmony default export */ __webpack_exports__["a"] = (hashClear);


/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (hashDelete);


/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__nativeCreate_js__ = __webpack_require__(32);


/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (__WEBPACK_IMPORTED_MODULE_0__nativeCreate_js__["a" /* default */]) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = (hashGet);


/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__nativeCreate_js__ = __webpack_require__(32);


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return __WEBPACK_IMPORTED_MODULE_0__nativeCreate_js__["a" /* default */] ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/* harmony default export */ __webpack_exports__["a"] = (hashHas);


/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__nativeCreate_js__ = __webpack_require__(32);


/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (__WEBPACK_IMPORTED_MODULE_0__nativeCreate_js__["a" /* default */] && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

/* harmony default export */ __webpack_exports__["a"] = (hashSet);


/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getMapData_js__ = __webpack_require__(33);


/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = Object(__WEBPACK_IMPORTED_MODULE_0__getMapData_js__["a" /* default */])(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (mapCacheDelete);


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/* harmony default export */ __webpack_exports__["a"] = (isKeyable);


/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getMapData_js__ = __webpack_require__(33);


/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__getMapData_js__["a" /* default */])(this, key).get(key);
}

/* harmony default export */ __webpack_exports__["a"] = (mapCacheGet);


/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getMapData_js__ = __webpack_require__(33);


/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__getMapData_js__["a" /* default */])(this, key).has(key);
}

/* harmony default export */ __webpack_exports__["a"] = (mapCacheHas);


/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getMapData_js__ = __webpack_require__(33);


/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = Object(__WEBPACK_IMPORTED_MODULE_0__getMapData_js__["a" /* default */])(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/* harmony default export */ __webpack_exports__["a"] = (mapCacheSet);


/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__copyObject_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__keys_js__ = __webpack_require__(11);



/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && Object(__WEBPACK_IMPORTED_MODULE_0__copyObject_js__["a" /* default */])(source, Object(__WEBPACK_IMPORTED_MODULE_1__keys_js__["default"])(source), object);
}

/* harmony default export */ __webpack_exports__["a"] = (baseAssign);


/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(5);



/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a" /* default */])(value) && Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a" /* default */])(value) == argsTag;
}

/* harmony default export */ __webpack_exports__["a"] = (baseIsArguments);


/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/* harmony default export */ __webpack_exports__["a"] = (stubFalse);


/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isLength_js__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__ = __webpack_require__(5);




/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__["a" /* default */])(value) &&
    Object(__WEBPACK_IMPORTED_MODULE_1__isLength_js__["a" /* default */])(value.length) && !!typedArrayTags[Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a" /* default */])(value)];
}

/* harmony default export */ __webpack_exports__["a"] = (baseIsTypedArray);


/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isPrototype_js__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__nativeKeys_js__ = __webpack_require__(178);



/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_0__isPrototype_js__["a" /* default */])(object)) {
    return Object(__WEBPACK_IMPORTED_MODULE_1__nativeKeys_js__["a" /* default */])(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseKeys);


/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__overArg_js__ = __webpack_require__(93);


/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = Object(__WEBPACK_IMPORTED_MODULE_0__overArg_js__["a" /* default */])(Object.keys, Object);

/* harmony default export */ __webpack_exports__["a"] = (nativeKeys);


/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__copyObject_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__keysIn_js__ = __webpack_require__(34);



/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && Object(__WEBPACK_IMPORTED_MODULE_0__copyObject_js__["a" /* default */])(source, Object(__WEBPACK_IMPORTED_MODULE_1__keysIn_js__["a" /* default */])(source), object);
}

/* harmony default export */ __webpack_exports__["a"] = (baseAssignIn);


/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isObject_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isPrototype_js__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__nativeKeysIn_js__ = __webpack_require__(181);




/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_0__isObject_js__["a" /* default */])(object)) {
    return Object(__WEBPACK_IMPORTED_MODULE_2__nativeKeysIn_js__["a" /* default */])(object);
  }
  var isProto = Object(__WEBPACK_IMPORTED_MODULE_1__isPrototype_js__["a" /* default */])(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseKeysIn);


/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (nativeKeysIn);


/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(4);


/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? __WEBPACK_IMPORTED_MODULE_0__root_js__["a" /* default */].Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (cloneBuffer);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(57)(module)))

/***/ }),
/* 183 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__copyObject_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getSymbols_js__ = __webpack_require__(62);



/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__copyObject_js__["a" /* default */])(source, Object(__WEBPACK_IMPORTED_MODULE_1__getSymbols_js__["a" /* default */])(source), object);
}

/* harmony default export */ __webpack_exports__["a"] = (copySymbols);


/***/ }),
/* 184 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__copyObject_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getSymbolsIn_js__ = __webpack_require__(95);



/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__copyObject_js__["a" /* default */])(source, Object(__WEBPACK_IMPORTED_MODULE_1__getSymbolsIn_js__["a" /* default */])(source), object);
}

/* harmony default export */ __webpack_exports__["a"] = (copySymbolsIn);


/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getNative_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__root_js__ = __webpack_require__(4);



/* Built-in method references that are verified to be native. */
var DataView = Object(__WEBPACK_IMPORTED_MODULE_0__getNative_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__root_js__["a" /* default */], 'DataView');

/* harmony default export */ __webpack_exports__["a"] = (DataView);


/***/ }),
/* 186 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getNative_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__root_js__ = __webpack_require__(4);



/* Built-in method references that are verified to be native. */
var Promise = Object(__WEBPACK_IMPORTED_MODULE_0__getNative_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__root_js__["a" /* default */], 'Promise');

/* harmony default export */ __webpack_exports__["a"] = (Promise);


/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (initCloneArray);


/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cloneArrayBuffer_js__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__cloneDataView_js__ = __webpack_require__(189);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cloneRegExp_js__ = __webpack_require__(190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__cloneSymbol_js__ = __webpack_require__(191);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__cloneTypedArray_js__ = __webpack_require__(192);






/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return Object(__WEBPACK_IMPORTED_MODULE_0__cloneArrayBuffer_js__["a" /* default */])(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return Object(__WEBPACK_IMPORTED_MODULE_1__cloneDataView_js__["a" /* default */])(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return Object(__WEBPACK_IMPORTED_MODULE_4__cloneTypedArray_js__["a" /* default */])(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return Object(__WEBPACK_IMPORTED_MODULE_2__cloneRegExp_js__["a" /* default */])(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return Object(__WEBPACK_IMPORTED_MODULE_3__cloneSymbol_js__["a" /* default */])(object);
  }
}

/* harmony default export */ __webpack_exports__["a"] = (initCloneByTag);


/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cloneArrayBuffer_js__ = __webpack_require__(67);


/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? Object(__WEBPACK_IMPORTED_MODULE_0__cloneArrayBuffer_js__["a" /* default */])(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/* harmony default export */ __webpack_exports__["a"] = (cloneDataView);


/***/ }),
/* 190 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (cloneRegExp);


/***/ }),
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(14);


/** Used to convert symbols to primitives and strings. */
var symbolProto = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/* harmony default export */ __webpack_exports__["a"] = (cloneSymbol);


/***/ }),
/* 192 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__cloneArrayBuffer_js__ = __webpack_require__(67);


/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? Object(__WEBPACK_IMPORTED_MODULE_0__cloneArrayBuffer_js__["a" /* default */])(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/* harmony default export */ __webpack_exports__["a"] = (cloneTypedArray);


/***/ }),
/* 193 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseCreate_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getPrototype_js__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isPrototype_js__ = __webpack_require__(60);




/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !Object(__WEBPACK_IMPORTED_MODULE_2__isPrototype_js__["a" /* default */])(object))
    ? Object(__WEBPACK_IMPORTED_MODULE_0__baseCreate_js__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_1__getPrototype_js__["a" /* default */])(object))
    : {};
}

/* harmony default export */ __webpack_exports__["a"] = (initCloneObject);


/***/ }),
/* 194 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIsMap_js__ = __webpack_require__(195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseUnary_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__ = __webpack_require__(59);




/* Node.js helper references. */
var nodeIsMap = __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__["a" /* default */] && __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__["a" /* default */].isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? Object(__WEBPACK_IMPORTED_MODULE_1__baseUnary_js__["a" /* default */])(nodeIsMap) : __WEBPACK_IMPORTED_MODULE_0__baseIsMap_js__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (isMap);


/***/ }),
/* 195 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getTag_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(5);



/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a" /* default */])(value) && Object(__WEBPACK_IMPORTED_MODULE_0__getTag_js__["a" /* default */])(value) == mapTag;
}

/* harmony default export */ __webpack_exports__["a"] = (baseIsMap);


/***/ }),
/* 196 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIsSet_js__ = __webpack_require__(197);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseUnary_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__ = __webpack_require__(59);




/* Node.js helper references. */
var nodeIsSet = __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__["a" /* default */] && __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__["a" /* default */].isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? Object(__WEBPACK_IMPORTED_MODULE_1__baseUnary_js__["a" /* default */])(nodeIsSet) : __WEBPACK_IMPORTED_MODULE_0__baseIsSet_js__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (isSet);


/***/ }),
/* 197 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getTag_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(5);



/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a" /* default */])(value) && Object(__WEBPACK_IMPORTED_MODULE_0__getTag_js__["a" /* default */])(value) == setTag;
}

/* harmony default export */ __webpack_exports__["a"] = (baseIsSet);


/***/ }),
/* 198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constant_js__ = __webpack_require__(199);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__defineProperty_js__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__identity_js__ = __webpack_require__(18);




/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !__WEBPACK_IMPORTED_MODULE_1__defineProperty_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_2__identity_js__["a" /* default */] : function(func, string) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__defineProperty_js__["a" /* default */])(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': Object(__WEBPACK_IMPORTED_MODULE_0__constant_js__["a" /* default */])(string),
    'writable': true
  });
};

/* harmony default export */ __webpack_exports__["a"] = (baseSetToString);


/***/ }),
/* 199 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (constant);


/***/ }),
/* 200 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__basePickBy_js__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hasIn_js__ = __webpack_require__(106);



/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__basePickBy_js__["a" /* default */])(object, paths, function(value, path) {
    return Object(__WEBPACK_IMPORTED_MODULE_1__hasIn_js__["a" /* default */])(object, path);
  });
}

/* harmony default export */ __webpack_exports__["a"] = (basePick);


/***/ }),
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__memoizeCapped_js__ = __webpack_require__(202);


/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = Object(__WEBPACK_IMPORTED_MODULE_0__memoizeCapped_js__["a" /* default */])(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/* harmony default export */ __webpack_exports__["a"] = (stringToPath);


/***/ }),
/* 202 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__memoize_js__ = __webpack_require__(203);


/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = Object(__WEBPACK_IMPORTED_MODULE_0__memoize_js__["a" /* default */])(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (memoizeCapped);


/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__MapCache_js__ = __webpack_require__(51);


/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || __WEBPACK_IMPORTED_MODULE_0__MapCache_js__["a" /* default */]);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = __WEBPACK_IMPORTED_MODULE_0__MapCache_js__["a" /* default */];

/* harmony default export */ __webpack_exports__["a"] = (memoize);


/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayMap_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isArray_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isSymbol_js__ = __webpack_require__(25);





/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (Object(__WEBPACK_IMPORTED_MODULE_2__isArray_js__["default"])(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return Object(__WEBPACK_IMPORTED_MODULE_1__arrayMap_js__["a" /* default */])(value, baseToString) + '';
  }
  if (Object(__WEBPACK_IMPORTED_MODULE_3__isSymbol_js__["a" /* default */])(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseToString);


/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assignValue_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__castPath_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isIndex_js__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isObject_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__toKey_js__ = __webpack_require__(20);






/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_3__isObject_js__["a" /* default */])(object)) {
    return object;
  }
  path = Object(__WEBPACK_IMPORTED_MODULE_1__castPath_js__["a" /* default */])(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = Object(__WEBPACK_IMPORTED_MODULE_4__toKey_js__["a" /* default */])(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = Object(__WEBPACK_IMPORTED_MODULE_3__isObject_js__["a" /* default */])(objValue)
          ? objValue
          : (Object(__WEBPACK_IMPORTED_MODULE_2__isIndex_js__["a" /* default */])(path[index + 1]) ? [] : {});
      }
    }
    Object(__WEBPACK_IMPORTED_MODULE_0__assignValue_js__["a" /* default */])(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/* harmony default export */ __webpack_exports__["a"] = (baseSet);


/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/* harmony default export */ __webpack_exports__["a"] = (baseHasIn);


/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isArguments_js__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isArray_js__ = __webpack_require__(1);




/** Built-in value references. */
var spreadableSymbol = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_2__isArray_js__["default"])(value) || Object(__WEBPACK_IMPORTED_MODULE_1__isArguments_js__["a" /* default */])(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/* harmony default export */ __webpack_exports__["a"] = (isFlattenable);


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

// stats.js - http://github.com/mrdoob/stats.js
(function(f,e){ true?module.exports=e():"function"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();
u(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel("FPS","#0ff","#002")),h=e(new f.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var t=e(new f.Panel("MB","#f08","#201"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/
1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=h;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);
b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+" "+e+" ("+g(c)+"-"+g(k)+")",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var builtinResourcePack = {
    fileNames: [
        "avsres_texer_circle_edgeonly_19x19.bmp",
        "avsres_texer_circle_edgeonly_29x29.bmp",
        "avsres_texer_circle_fade_13x13.bmp",
        "avsres_texer_circle_heavyblur_19x19.bmp",
        "avsres_texer_circle_heavyblur_21x21.bmp",
        "avsres_texer_circle_heavyblur_29x29.bmp",
        "avsres_texer_circle_sharp_09x09.bmp",
        "avsres_texer_circle_sharp_19x19.bmp",
        "avsres_texer_circle_slightblur_13x13.bmp",
        "avsres_texer_circle_slightblur_21x21.bmp",
        "avsres_texer_hexagon-h_blur_123x123.bmp",
        "avsres_texer_square_edgeonly_24x24.bmp",
        "avsres_texer_square_edgeonly_28x28.bmp",
        "avsres_texer_square_edgeonly_30x30.bmp",
        "avsres_texer_square_sharp_20x20.bmp",
        "avsres_texer_square_sharp_32x32.bmp",
        "avsres_texer_square_sharp_48x48.bmp",
        "avsres_texer_square_sharp_60x60.bmp",
        "avsres_texer_square_sharp_64x64.bmp",
        "avsres_texer_square_sharp_72x72.bmp",
        "avsres_texer_square_sharp_96x96.bmp",
        "avsres_texer_square_sharp_250x250.bmp",
    ],
    name: "Builtin",
    prefix: "https://unpkg.com/webvs@3.0.0/resources/"
};
exports["default"] = builtinResourcePack;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
/**
 * A Registry of Component classes.
 *
 * ComponentRegistry maintains a map from Component name
 * to Component class constructors. Typically used through the [[Main.componentRegistry]]
 */
var ComponentRegistry = /** @class */ (function () {
    /**
     * construct a ComponentRegistry with an initial set of Component class
     * constructors.
     * @param componentClasses one or more Component class constructors
     */
    function ComponentRegistry(componentClasses) {
        this.components = {};
        this.tags = [];
        if (componentClasses) {
            this.addComponent(componentClasses);
        }
    }
    /**
     * Add a Component class constructor into the registry. Each constructor is mapped
     * to the static [[Component.componentName]] value of the class.
     * @param componentClasses one or more Component class constructors to be added
     */
    ComponentRegistry.prototype.addComponent = function (componentClasses) {
        var _this = this;
        if (!Array.isArray(componentClasses)) {
            componentClasses = [componentClasses];
        }
        componentClasses.forEach(function (componentClass) {
            var name = componentClass.getComponentName();
            if (name in _this.components) {
                throw new Error("Component " + name + " already exists in the registry");
            }
            _this.components[name] = componentClass;
            if (_this.tags.indexOf(componentClass.getComponentTag()) === -1) {
                _this.tags.push(componentClass.getComponentTag());
            }
        });
    };
    /**
     * Returns the Component class constructor mapped to the given name
     * @param name componentName of the Component class to be retrieved
     */
    ComponentRegistry.prototype.getComponentClass = function (name) {
        return this.components[name];
    };
    /**
     * Returns all components with given tag
     * @param tag of component classes to be returned
     */
    ComponentRegistry.prototype.getComponentClassesByTag = function (tag) {
        var _this = this;
        return Object.keys(this.components)
            .map(function (name) { return _this.components[name]; })
            .filter(function (componentClass) { return componentClass.getComponentTag() === tag; });
    };
    return ComponentRegistry;
}());
exports["default"] = ComponentRegistry;


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Container_1 = __webpack_require__(212);
var compileExpr_1 = __webpack_require__(28);
var TextureSetManager_1 = __webpack_require__(139);
/**
 * BlendModes supported by Effectlist
 */
var ELBlendMode;
(function (ELBlendMode) {
    ELBlendMode[ELBlendMode["REPLACE"] = 1] = "REPLACE";
    ELBlendMode[ELBlendMode["MAXIMUM"] = 2] = "MAXIMUM";
    ELBlendMode[ELBlendMode["AVERAGE"] = 3] = "AVERAGE";
    ELBlendMode[ELBlendMode["ADDITIVE"] = 4] = "ADDITIVE";
    ELBlendMode[ELBlendMode["SUBTRACTIVE1"] = 5] = "SUBTRACTIVE1";
    ELBlendMode[ELBlendMode["SUBTRACTIVE2"] = 6] = "SUBTRACTIVE2";
    ELBlendMode[ELBlendMode["MULTIPLY"] = 7] = "MULTIPLY";
    ELBlendMode[ELBlendMode["MULTIPLY2"] = 8] = "MULTIPLY2";
    ELBlendMode[ELBlendMode["ADJUSTABLE"] = 9] = "ADJUSTABLE";
    ELBlendMode[ELBlendMode["ALPHA"] = 10] = "ALPHA";
    ELBlendMode[ELBlendMode["IGNORE"] = 11] = "IGNORE";
})(ELBlendMode = exports.ELBlendMode || (exports.ELBlendMode = {}));
/**
 * Effectlist is a container that renders components to a separate buffer. And blends
 * it in with the parent buffer.
 *
 * An implicit Effeclist is also created by [[Main]] as a root component.
 */
var EffectList = /** @class */ (function (_super) {
    __extends(EffectList, _super);
    function EffectList(main, parent, opts) {
        var _this = _super.call(this, main, parent, opts) || this;
        _this.inited = false;
        return _this;
    }
    EffectList.prototype.init = function () {
        var _this = this;
        _super.prototype.init.call(this);
        var tsm = new TextureSetManager_1["default"](this.main.getRctx(), this.main.getCopier(), this.parent ? false : true);
        this.setTSM(tsm);
        this.updateCode();
        this.updateBlendMode(this.opts.input, "input");
        this.updateBlendMode(this.opts.output, "output");
        this.frameCounter = 0;
        this.first = true;
        this.listenTo(this.main, "resize", function () { return _this.handleResize(); });
    };
    EffectList.prototype.draw = function () {
        var opts = this.opts;
        if (opts.enableOnBeat) {
            if (this.main.getAnalyser().isBeat()) {
                this.frameCounter = opts.enableOnBeatFor;
            }
            else if (this.frameCounter > 0) {
                this.frameCounter--;
            }
            // only enable for enableOnBeatFor # of frames
            if (this.frameCounter === 0) {
                return;
            }
        }
        this.code.beat = this.main.getAnalyser().isBeat() ? 1 : 0;
        this.code.enabled = 1;
        this.code.clear = opts.clearFrame ? 1 : 0;
        if (!this.inited) {
            this.inited = true;
            this.code.init();
        }
        this.code.perFrame();
        if (this.code.enabled === 0) {
            return;
        }
        // set rendertarget to internal framebuffer
        this.getTSM().setAsRenderTarget();
        // clear frame
        if (opts.clearFrame || this.first || this.code.clear) {
            var gl = this.main.getRctx().getGl();
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            this.first = false;
        }
        // blend input texture onto internal texture
        if (this.input !== ELBlendMode.IGNORE) {
            var inputTexture = this.parent.getTSM().getCurrentTexture();
            this.main.getCopier().run(this.getTSM(), { srcTexture: inputTexture }, this.input);
        }
        // render all the components
        // for (let i = 0; i < this.components.length; i++) {
        for (var _i = 0, _a = this.components; _i < _a.length; _i++) {
            var component = _a[_i];
            if (component.isEnabled()) {
                component.draw();
            }
        }
        // switch to old framebuffer
        this.getTSM().unsetAsRenderTarget();
        // blend current texture to the output framebuffer
        if (this.output !== ELBlendMode.IGNORE) {
            if (this.parent) {
                this.main.getCopier().run(this.parent.getTSM(), { srcTexture: this.getTSM().getCurrentTexture() }, this.output);
            }
            else {
                this.main.getCopier().run(null, { srcTexture: this.getTSM().getCurrentTexture() });
            }
        }
    };
    EffectList.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this.getTSM()) {
            // destroy the framebuffer manager
            this.getTSM().destroy();
        }
    };
    EffectList.prototype.updateCode = function () {
        this.code = compileExpr_1["default"](this.opts.code, ["init", "perFrame"]).codeInst;
        this.code.setup(this.main);
        this.inited = false;
    };
    EffectList.prototype.updateBlendMode = function (value, name) {
        if (name === "input") {
            this.input = ELBlendMode[value];
        }
        else {
            this.output = ELBlendMode[value];
        }
    };
    EffectList.prototype.handleResize = function () {
        this.getTSM().resize();
        this.code.updateDimVars(this.main.getRctx().getGl());
    };
    EffectList.componentName = "EffectList";
    EffectList.componentTag = "";
    EffectList.defaultOptions = {
        clearFrame: false,
        code: {
            init: "",
            perFrame: ""
        },
        enableOnBeat: false,
        enableOnBeatFor: 1,
        input: "IGNORE",
        output: "REPLACE"
    };
    EffectList.optUpdateHandlers = {
        code: "updateCode",
        input: "updateBlendMode",
        output: "updateBlendMode"
    };
    return EffectList;
}(Container_1["default"]));
exports["default"] = EffectList;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var defaults_1 = __webpack_require__(24);
var isString_1 = __webpack_require__(73);
var Component_1 = __webpack_require__(2);
/**
 * A Base class for all Components that have a sub component.
 *
 * Manages, cloning and component tree operations.
 */
var Container = /** @class */ (function (_super) {
    __extends(Container, _super);
    /**
     * See [[Component.constructor]]
     */
    function Container(main, parent, opts) {
        var _this = _super.call(this, main, parent, opts) || this;
        delete _this.opts.components;
        return _this;
    }
    /**
     * Returns the TextSetManager for this component.
     *
     * A container inherits TextureSetManager from it's own parent
     * unless explicitly overridden by Subclass
     */
    Container.prototype.getTSM = function () {
        return this.tsm;
    };
    /**
     * Initializes Container. Please override to implement component specific initialization
     *
     * Container init basically instantiates all subcomponents from the `components` option.
     * It also initializes the TextureSetManager to the parent's.
     */
    Container.prototype.init = function () {
        var components = [];
        if (this.opts.components) {
            for (var _i = 0, _a = this.opts.components; _i < _a.length; _i++) {
                var opts = _a[_i];
                var componentClass = this.main.getComponentRegistry().getComponentClass(opts.type);
                if (!componentClass) {
                    // tslint:disable-next-line:no-console
                    console.warn("Unknown ComponentClass: " + opts.type + ". Skipping.");
                    continue;
                }
                var component = new componentClass(this.main, this, opts);
                components.push(component);
            }
        }
        this.components = components;
        this.tsm = this.parent && this.parent.getTSM();
    };
    /**
     * Destroy all subcomponents and itself.
     */
    Container.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        for (var _i = 0, _a = this.components; _i < _a.length; _i++) {
            var component = _a[_i];
            component.destroy();
        }
    };
    /**
     * Adds new sub component in this Container
     *
     * Once component is inserted, an `addComponent` event is fired with the following arguments:
     * 1. The newly created component
     * 2. This container
     * 3. Additional params passed in to this call
     *
     * @param componentOpts options for the new sub-component
     * @param pos the position at which the sub-component should be inserted. Defaults to appending
     * @param params additional params to be passed down the the `addComponent` event
     */
    Container.prototype.addComponent = function (componentOpts, pos, params) {
        if (pos === void 0) { pos = this.components.length; }
        if (params === void 0) { params = {}; }
        var component;
        if (componentOpts instanceof Component_1["default"]) {
            component = componentOpts;
            component.setParent(this);
        }
        else {
            var componentClass = this.main.getComponentRegistry().getComponentClass(componentOpts.type);
            if (!componentClass) {
                // tslint:disable-next-line:no-console
                console.warn("Unknown ComponentClass: " + componentOpts.type + ".");
                return null;
            }
            component = new componentClass(this.main, this, componentOpts);
        }
        this.components.splice(pos, 0, component);
        params = defaults_1["default"]({ pos: pos }, params);
        this.emit("addComponent", component, this, params);
        return component;
    };
    /**
     * Detaches a component from this container and returns it.
     *
     * Once component is detached, a `detachComponent` event is fired with following arguments.
     * 1. The newly created component
     * 2. This container
     * 3. Additional params passed in to this call
     *
     * @param pos The position from which component should be detached
     * @param params additional params to be passed down the the `detachComponent` event
     */
    Container.prototype.detachComponent = function (pos, params) {
        if (params === void 0) { params = {}; }
        if (isString_1["default"](pos)) {
            var id = pos;
            var i = void 0;
            for (i = 0; i < this.components.length; i++) {
                if (this.components[i].getId() === id) {
                    pos = i;
                    break;
                }
            }
            if (i === this.components.length) {
                return;
            }
        }
        var component = this.components[pos];
        this.components.splice(pos, 1);
        params = defaults_1["default"]({ pos: pos }, params);
        this.emit("detachComponent", component, this, params);
        return component;
    };
    /**
     * Returns a sub-component under hierarchy of this Container with the given id
     * @param id id of the component to find
     */
    Container.prototype.findComponent = function (id) {
        for (var _i = 0, _a = this.components; _i < _a.length; _i++) {
            var component = _a[_i];
            if (component.getId() === id) {
                return component;
            }
        }
        // search in any subcontainers
        for (var _b = 0, _c = this.components; _b < _c.length; _b++) {
            var container = _c[_b];
            if (!(container instanceof Container)) {
                continue;
            }
            var subComponent = container.findComponent(id);
            if (subComponent) {
                return subComponent;
            }
        }
    };
    /**
     * Returns the JSON representation of the component options.
     */
    Container.prototype.toJSON = function () {
        var opts = _super.prototype.toJSON.call(this);
        opts.components = [];
        for (var _i = 0, _a = this.components; _i < _a.length; _i++) {
            var component = _a[_i];
            opts.components.push(component.toJSON());
        }
        return opts;
    };
    /**
     * sets the frambuffer manager for this container
     * @param tsm the frambuffermanager
     */
    Container.prototype.setTSM = function (tsm) {
        this.tsm = tsm;
    };
    return Container;
}(Component_1["default"]));
exports["default"] = Container;


/***/ }),
/* 213 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Stack_js__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__equalArrays_js__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__equalByTag_js__ = __webpack_require__(217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__equalObjects_js__ = __webpack_require__(219);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__getTag_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__isArray_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__isBuffer_js__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__isTypedArray_js__ = __webpack_require__(92);









/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = Object(__WEBPACK_IMPORTED_MODULE_5__isArray_js__["default"])(object),
      othIsArr = Object(__WEBPACK_IMPORTED_MODULE_5__isArray_js__["default"])(other),
      objTag = objIsArr ? arrayTag : Object(__WEBPACK_IMPORTED_MODULE_4__getTag_js__["a" /* default */])(object),
      othTag = othIsArr ? arrayTag : Object(__WEBPACK_IMPORTED_MODULE_4__getTag_js__["a" /* default */])(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && Object(__WEBPACK_IMPORTED_MODULE_6__isBuffer_js__["a" /* default */])(object)) {
    if (!Object(__WEBPACK_IMPORTED_MODULE_6__isBuffer_js__["a" /* default */])(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new __WEBPACK_IMPORTED_MODULE_0__Stack_js__["a" /* default */]);
    return (objIsArr || Object(__WEBPACK_IMPORTED_MODULE_7__isTypedArray_js__["a" /* default */])(object))
      ? Object(__WEBPACK_IMPORTED_MODULE_1__equalArrays_js__["a" /* default */])(object, other, bitmask, customizer, equalFunc, stack)
      : Object(__WEBPACK_IMPORTED_MODULE_2__equalByTag_js__["a" /* default */])(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new __WEBPACK_IMPORTED_MODULE_0__Stack_js__["a" /* default */]);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new __WEBPACK_IMPORTED_MODULE_0__Stack_js__["a" /* default */]);
  return Object(__WEBPACK_IMPORTED_MODULE_3__equalObjects_js__["a" /* default */])(object, other, bitmask, customizer, equalFunc, stack);
}

/* harmony default export */ __webpack_exports__["a"] = (baseIsEqualDeep);


/***/ }),
/* 214 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/* harmony default export */ __webpack_exports__["a"] = (setCacheAdd);


/***/ }),
/* 215 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/* harmony default export */ __webpack_exports__["a"] = (setCacheHas);


/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/* harmony default export */ __webpack_exports__["a"] = (arraySome);


/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Uint8Array_js__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__eq_js__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__equalArrays_js__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mapToArray_js__ = __webpack_require__(218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__setToArray_js__ = __webpack_require__(75);







/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a" /* default */].prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new __WEBPACK_IMPORTED_MODULE_1__Uint8Array_js__["a" /* default */](object), new __WEBPACK_IMPORTED_MODULE_1__Uint8Array_js__["a" /* default */](other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return Object(__WEBPACK_IMPORTED_MODULE_2__eq_js__["a" /* default */])(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = __WEBPACK_IMPORTED_MODULE_4__mapToArray_js__["a" /* default */];

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = __WEBPACK_IMPORTED_MODULE_5__setToArray_js__["a" /* default */]);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = Object(__WEBPACK_IMPORTED_MODULE_3__equalArrays_js__["a" /* default */])(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/* harmony default export */ __webpack_exports__["a"] = (equalByTag);


/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (mapToArray);


/***/ }),
/* 219 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__getAllKeys_js__ = __webpack_require__(96);


/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = Object(__WEBPACK_IMPORTED_MODULE_0__getAllKeys_js__["a" /* default */])(object),
      objLength = objProps.length,
      othProps = Object(__WEBPACK_IMPORTED_MODULE_0__getAllKeys_js__["a" /* default */])(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (equalObjects);


/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayMap_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseClone_js__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseUnset_js__ = __webpack_require__(221);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__castPath_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__copyObject_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__customOmitClone_js__ = __webpack_require__(223);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__flatRest_js__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__getAllKeysIn_js__ = __webpack_require__(66);









/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable property paths of `object` that are not omitted.
 *
 * **Note:** This method is considerably slower than `_.pick`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit = Object(__WEBPACK_IMPORTED_MODULE_6__flatRest_js__["a" /* default */])(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = Object(__WEBPACK_IMPORTED_MODULE_0__arrayMap_js__["a" /* default */])(paths, function(path) {
    path = Object(__WEBPACK_IMPORTED_MODULE_3__castPath_js__["a" /* default */])(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  Object(__WEBPACK_IMPORTED_MODULE_4__copyObject_js__["a" /* default */])(object, Object(__WEBPACK_IMPORTED_MODULE_7__getAllKeysIn_js__["a" /* default */])(object), result);
  if (isDeep) {
    result = Object(__WEBPACK_IMPORTED_MODULE_1__baseClone_js__["a" /* default */])(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, __WEBPACK_IMPORTED_MODULE_5__customOmitClone_js__["a" /* default */]);
  }
  var length = paths.length;
  while (length--) {
    Object(__WEBPACK_IMPORTED_MODULE_2__baseUnset_js__["a" /* default */])(result, paths[length]);
  }
  return result;
});

/* harmony default export */ __webpack_exports__["default"] = (omit);


/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__castPath_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__last_js__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__parent_js__ = __webpack_require__(222);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__toKey_js__ = __webpack_require__(20);





/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = Object(__WEBPACK_IMPORTED_MODULE_0__castPath_js__["a" /* default */])(path, object);
  object = Object(__WEBPACK_IMPORTED_MODULE_2__parent_js__["a" /* default */])(object, path);
  return object == null || delete object[Object(__WEBPACK_IMPORTED_MODULE_3__toKey_js__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_1__last_js__["default"])(path))];
}

/* harmony default export */ __webpack_exports__["a"] = (baseUnset);


/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGet_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseSlice_js__ = __webpack_require__(41);



/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : Object(__WEBPACK_IMPORTED_MODULE_0__baseGet_js__["a" /* default */])(object, Object(__WEBPACK_IMPORTED_MODULE_1__baseSlice_js__["a" /* default */])(path, 0, -1));
}

/* harmony default export */ __webpack_exports__["a"] = (parent);


/***/ }),
/* 223 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isPlainObject_js__ = __webpack_require__(224);


/**
 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
 * objects.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {string} key The key of the property to inspect.
 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
 */
function customOmitClone(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__isPlainObject_js__["a" /* default */])(value) ? undefined : value;
}

/* harmony default export */ __webpack_exports__["a"] = (customOmitClone);


/***/ }),
/* 224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getPrototype_js__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__ = __webpack_require__(5);




/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!Object(__WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__["a" /* default */])(value) || Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a" /* default */])(value) != objectTag) {
    return false;
  }
  var proto = Object(__WEBPACK_IMPORTED_MODULE_1__getPrototype_js__["a" /* default */])(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/* harmony default export */ __webpack_exports__["a"] = (isPlainObject);


/***/ }),
/* 225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__toString_js__ = __webpack_require__(105);


/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return Object(__WEBPACK_IMPORTED_MODULE_0__toString_js__["a" /* default */])(prefix) + id;
}

/* harmony default export */ __webpack_exports__["default"] = (uniqueId);


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
if (true) {
  module.exports = EventEmitter;
}


/***/ }),
/* 227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseEach_js__ = __webpack_require__(42);


/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  Object(__WEBPACK_IMPORTED_MODULE_0__baseEach_js__["a" /* default */])(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseFilter);


/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFor_js__ = __webpack_require__(229);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__keys_js__ = __webpack_require__(11);



/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && Object(__WEBPACK_IMPORTED_MODULE_0__baseFor_js__["a" /* default */])(object, iteratee, __WEBPACK_IMPORTED_MODULE_1__keys_js__["default"]);
}

/* harmony default export */ __webpack_exports__["a"] = (baseForOwn);


/***/ }),
/* 229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createBaseFor_js__ = __webpack_require__(230);


/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = Object(__WEBPACK_IMPORTED_MODULE_0__createBaseFor_js__["a" /* default */])();

/* harmony default export */ __webpack_exports__["a"] = (baseFor);


/***/ }),
/* 230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (createBaseFor);


/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isArrayLike_js__ = __webpack_require__(17);


/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!Object(__WEBPACK_IMPORTED_MODULE_0__isArrayLike_js__["a" /* default */])(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/* harmony default export */ __webpack_exports__["a"] = (createBaseEach);


/***/ }),
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIsMatch_js__ = __webpack_require__(233);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__getMatchData_js__ = __webpack_require__(234);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__matchesStrictComparable_js__ = __webpack_require__(114);




/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = Object(__WEBPACK_IMPORTED_MODULE_1__getMatchData_js__["a" /* default */])(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return Object(__WEBPACK_IMPORTED_MODULE_2__matchesStrictComparable_js__["a" /* default */])(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || Object(__WEBPACK_IMPORTED_MODULE_0__baseIsMatch_js__["a" /* default */])(object, source, matchData);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (baseMatches);


/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Stack_js__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIsEqual_js__ = __webpack_require__(74);



/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new __WEBPACK_IMPORTED_MODULE_0__Stack_js__["a" /* default */];
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? Object(__WEBPACK_IMPORTED_MODULE_1__baseIsEqual_js__["a" /* default */])(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/* harmony default export */ __webpack_exports__["a"] = (baseIsMatch);


/***/ }),
/* 234 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isStrictComparable_js__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__keys_js__ = __webpack_require__(11);



/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = Object(__WEBPACK_IMPORTED_MODULE_1__keys_js__["default"])(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, Object(__WEBPACK_IMPORTED_MODULE_0__isStrictComparable_js__["a" /* default */])(value)];
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (getMatchData);


/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIsEqual_js__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__get_js__ = __webpack_require__(236);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__hasIn_js__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isKey_js__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__isStrictComparable_js__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__matchesStrictComparable_js__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__toKey_js__ = __webpack_require__(20);








/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (Object(__WEBPACK_IMPORTED_MODULE_3__isKey_js__["a" /* default */])(path) && Object(__WEBPACK_IMPORTED_MODULE_4__isStrictComparable_js__["a" /* default */])(srcValue)) {
    return Object(__WEBPACK_IMPORTED_MODULE_5__matchesStrictComparable_js__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_6__toKey_js__["a" /* default */])(path), srcValue);
  }
  return function(object) {
    var objValue = Object(__WEBPACK_IMPORTED_MODULE_1__get_js__["a" /* default */])(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? Object(__WEBPACK_IMPORTED_MODULE_2__hasIn_js__["a" /* default */])(object, path)
      : Object(__WEBPACK_IMPORTED_MODULE_0__baseIsEqual_js__["a" /* default */])(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (baseMatchesProperty);


/***/ }),
/* 236 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGet_js__ = __webpack_require__(37);


/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : Object(__WEBPACK_IMPORTED_MODULE_0__baseGet_js__["a" /* default */])(object, path);
  return result === undefined ? defaultValue : result;
}

/* harmony default export */ __webpack_exports__["a"] = (get);


/***/ }),
/* 237 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseProperty_js__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__basePropertyDeep_js__ = __webpack_require__(238);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__isKey_js__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__toKey_js__ = __webpack_require__(20);





/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return Object(__WEBPACK_IMPORTED_MODULE_2__isKey_js__["a" /* default */])(path) ? Object(__WEBPACK_IMPORTED_MODULE_0__baseProperty_js__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_3__toKey_js__["a" /* default */])(path)) : Object(__WEBPACK_IMPORTED_MODULE_1__basePropertyDeep_js__["a" /* default */])(path);
}

/* harmony default export */ __webpack_exports__["a"] = (property);


/***/ }),
/* 238 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseGet_js__ = __webpack_require__(37);


/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return Object(__WEBPACK_IMPORTED_MODULE_0__baseGet_js__["a" /* default */])(object, path);
  };
}

/* harmony default export */ __webpack_exports__["a"] = (basePropertyDeep);


/***/ }),
/* 239 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseDifference_js__ = __webpack_require__(240);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseFlatten_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseRest_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject_js__ = __webpack_require__(44);





/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = Object(__WEBPACK_IMPORTED_MODULE_2__baseRest_js__["a" /* default */])(function(array, values) {
  return Object(__WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject_js__["a" /* default */])(array)
    ? Object(__WEBPACK_IMPORTED_MODULE_0__baseDifference_js__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_1__baseFlatten_js__["a" /* default */])(values, 1, __WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject_js__["a" /* default */], true))
    : [];
});

/* harmony default export */ __webpack_exports__["default"] = (difference);


/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__SetCache_js__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayIncludes_js__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__arrayIncludesWith_js__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__arrayMap_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__baseUnary_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__cacheHas_js__ = __webpack_require__(40);







/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = __WEBPACK_IMPORTED_MODULE_1__arrayIncludes_js__["a" /* default */],
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = Object(__WEBPACK_IMPORTED_MODULE_3__arrayMap_js__["a" /* default */])(values, Object(__WEBPACK_IMPORTED_MODULE_4__baseUnary_js__["a" /* default */])(iteratee));
  }
  if (comparator) {
    includes = __WEBPACK_IMPORTED_MODULE_2__arrayIncludesWith_js__["a" /* default */];
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = __WEBPACK_IMPORTED_MODULE_5__cacheHas_js__["a" /* default */];
    isCommon = false;
    values = new __WEBPACK_IMPORTED_MODULE_0__SetCache_js__["a" /* default */](values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseDifference);


/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/* harmony default export */ __webpack_exports__["a"] = (baseFindIndex);


/***/ }),
/* 242 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/* harmony default export */ __webpack_exports__["a"] = (baseIsNaN);


/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/* harmony default export */ __webpack_exports__["a"] = (strictIndexOf);


/***/ }),
/* 244 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayEach_js__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseEach_js__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__castFunction_js__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isArray_js__ = __webpack_require__(1);





/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = Object(__WEBPACK_IMPORTED_MODULE_3__isArray_js__["default"])(collection) ? __WEBPACK_IMPORTED_MODULE_0__arrayEach_js__["a" /* default */] : __WEBPACK_IMPORTED_MODULE_1__baseEach_js__["a" /* default */];
  return func(collection, Object(__WEBPACK_IMPORTED_MODULE_2__castFunction_js__["a" /* default */])(iteratee));
}

/* harmony default export */ __webpack_exports__["a"] = (forEach);


/***/ }),
/* 245 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LodashWrapper_js__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flatRest_js__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__getData_js__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__getFuncName_js__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__isArray_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__isLaziable_js__ = __webpack_require__(122);







/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to compose bitmasks for function metadata. */
var WRAP_CURRY_FLAG = 8,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_ARY_FLAG = 128,
    WRAP_REARG_FLAG = 256;

/**
 * Creates a `_.flow` or `_.flowRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new flow function.
 */
function createFlow(fromRight) {
  return Object(__WEBPACK_IMPORTED_MODULE_1__flatRest_js__["a" /* default */])(function(funcs) {
    var length = funcs.length,
        index = length,
        prereq = __WEBPACK_IMPORTED_MODULE_0__LodashWrapper_js__["a" /* default */].prototype.thru;

    if (fromRight) {
      funcs.reverse();
    }
    while (index--) {
      var func = funcs[index];
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (prereq && !wrapper && Object(__WEBPACK_IMPORTED_MODULE_3__getFuncName_js__["a" /* default */])(func) == 'wrapper') {
        var wrapper = new __WEBPACK_IMPORTED_MODULE_0__LodashWrapper_js__["a" /* default */]([], true);
      }
    }
    index = wrapper ? index : length;
    while (++index < length) {
      func = funcs[index];

      var funcName = Object(__WEBPACK_IMPORTED_MODULE_3__getFuncName_js__["a" /* default */])(func),
          data = funcName == 'wrapper' ? Object(__WEBPACK_IMPORTED_MODULE_2__getData_js__["a" /* default */])(func) : undefined;

      if (data && Object(__WEBPACK_IMPORTED_MODULE_5__isLaziable_js__["a" /* default */])(data[0]) &&
            data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
            !data[4].length && data[9] == 1
          ) {
        wrapper = wrapper[Object(__WEBPACK_IMPORTED_MODULE_3__getFuncName_js__["a" /* default */])(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = (func.length == 1 && Object(__WEBPACK_IMPORTED_MODULE_5__isLaziable_js__["a" /* default */])(func))
          ? wrapper[funcName]()
          : wrapper.thru(func);
      }
    }
    return function() {
      var args = arguments,
          value = args[0];

      if (wrapper && args.length == 1 && Object(__WEBPACK_IMPORTED_MODULE_4__isArray_js__["default"])(value)) {
        return wrapper.plant(value).value();
      }
      var index = 0,
          result = length ? funcs[index].apply(this, args) : value;

      while (++index < length) {
        result = funcs[index].call(this, result);
      }
      return result;
    };
  });
}

/* harmony default export */ __webpack_exports__["a"] = (createFlow);


/***/ }),
/* 246 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used to lookup unminified function names. */
var realNames = {};

/* harmony default export */ __webpack_exports__["a"] = (realNames);


/***/ }),
/* 247 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LazyWrapper_js__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__LodashWrapper_js__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseLodash_js__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isArray_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__isObjectLike_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__wrapperClone_js__ = __webpack_require__(248);







/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates a `lodash` object which wraps `value` to enable implicit method
 * chain sequences. Methods that operate on and return arrays, collections,
 * and functions can be chained together. Methods that retrieve a single value
 * or may return a primitive value will automatically end the chain sequence
 * and return the unwrapped value. Otherwise, the value must be unwrapped
 * with `_#value`.
 *
 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
 * enabled using `_.chain`.
 *
 * The execution of chained methods is lazy, that is, it's deferred until
 * `_#value` is implicitly or explicitly called.
 *
 * Lazy evaluation allows several methods to support shortcut fusion.
 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
 * the creation of intermediate arrays and can greatly reduce the number of
 * iteratee executions. Sections of a chain sequence qualify for shortcut
 * fusion if the section is applied to an array and iteratees accept only
 * one argument. The heuristic for whether a section qualifies for shortcut
 * fusion is subject to change.
 *
 * Chaining is supported in custom builds as long as the `_#value` method is
 * directly or indirectly included in the build.
 *
 * In addition to lodash methods, wrappers have `Array` and `String` methods.
 *
 * The wrapper `Array` methods are:
 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
 *
 * The wrapper `String` methods are:
 * `replace` and `split`
 *
 * The wrapper methods that support shortcut fusion are:
 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
 *
 * The chainable wrapper methods are:
 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
 * `zipObject`, `zipObjectDeep`, and `zipWith`
 *
 * The wrapper methods that are **not** chainable by default are:
 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
 * `upperFirst`, `value`, and `words`
 *
 * @name _
 * @constructor
 * @category Seq
 * @param {*} value The value to wrap in a `lodash` instance.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var wrapped = _([1, 2, 3]);
 *
 * // Returns an unwrapped value.
 * wrapped.reduce(_.add);
 * // => 6
 *
 * // Returns a wrapped value.
 * var squares = wrapped.map(square);
 *
 * _.isArray(squares);
 * // => false
 *
 * _.isArray(squares.value());
 * // => true
 */
function lodash(value) {
  if (Object(__WEBPACK_IMPORTED_MODULE_4__isObjectLike_js__["a" /* default */])(value) && !Object(__WEBPACK_IMPORTED_MODULE_3__isArray_js__["default"])(value) && !(value instanceof __WEBPACK_IMPORTED_MODULE_0__LazyWrapper_js__["a" /* default */])) {
    if (value instanceof __WEBPACK_IMPORTED_MODULE_1__LodashWrapper_js__["a" /* default */]) {
      return value;
    }
    if (hasOwnProperty.call(value, '__wrapped__')) {
      return Object(__WEBPACK_IMPORTED_MODULE_5__wrapperClone_js__["a" /* default */])(value);
    }
  }
  return new __WEBPACK_IMPORTED_MODULE_1__LodashWrapper_js__["a" /* default */](value);
}

// Ensure wrappers are instances of `baseLodash`.
lodash.prototype = __WEBPACK_IMPORTED_MODULE_2__baseLodash_js__["a" /* default */].prototype;
lodash.prototype.constructor = lodash;

/* harmony default export */ __webpack_exports__["a"] = (lodash);


/***/ }),
/* 248 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__LazyWrapper_js__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__LodashWrapper_js__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__copyArray_js__ = __webpack_require__(61);




/**
 * Creates a clone of `wrapper`.
 *
 * @private
 * @param {Object} wrapper The wrapper to clone.
 * @returns {Object} Returns the cloned wrapper.
 */
function wrapperClone(wrapper) {
  if (wrapper instanceof __WEBPACK_IMPORTED_MODULE_0__LazyWrapper_js__["a" /* default */]) {
    return wrapper.clone();
  }
  var result = new __WEBPACK_IMPORTED_MODULE_1__LodashWrapper_js__["a" /* default */](wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = Object(__WEBPACK_IMPORTED_MODULE_2__copyArray_js__["a" /* default */])(wrapper.__actions__);
  result.__index__  = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (wrapperClone);


/***/ }),
/* 249 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayMap_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIntersection_js__ = __webpack_require__(250);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseRest_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__castArrayLikeObject_js__ = __webpack_require__(251);





/**
 * Creates an array of unique values that are included in all given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersection([2, 1], [2, 3]);
 * // => [2]
 */
var intersection = Object(__WEBPACK_IMPORTED_MODULE_2__baseRest_js__["a" /* default */])(function(arrays) {
  var mapped = Object(__WEBPACK_IMPORTED_MODULE_0__arrayMap_js__["a" /* default */])(arrays, __WEBPACK_IMPORTED_MODULE_3__castArrayLikeObject_js__["a" /* default */]);
  return (mapped.length && mapped[0] === arrays[0])
    ? Object(__WEBPACK_IMPORTED_MODULE_1__baseIntersection_js__["a" /* default */])(mapped)
    : [];
});

/* harmony default export */ __webpack_exports__["default"] = (intersection);


/***/ }),
/* 250 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__SetCache_js__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayIncludes_js__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__arrayIncludesWith_js__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__arrayMap_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__baseUnary_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__cacheHas_js__ = __webpack_require__(40);







/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * The base implementation of methods like `_.intersection`, without support
 * for iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */
function baseIntersection(arrays, iteratee, comparator) {
  var includes = comparator ? __WEBPACK_IMPORTED_MODULE_2__arrayIncludesWith_js__["a" /* default */] : __WEBPACK_IMPORTED_MODULE_1__arrayIncludes_js__["a" /* default */],
      length = arrays[0].length,
      othLength = arrays.length,
      othIndex = othLength,
      caches = Array(othLength),
      maxLength = Infinity,
      result = [];

  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee) {
      array = Object(__WEBPACK_IMPORTED_MODULE_3__arrayMap_js__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_4__baseUnary_js__["a" /* default */])(iteratee));
    }
    maxLength = nativeMin(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
      ? new __WEBPACK_IMPORTED_MODULE_0__SetCache_js__["a" /* default */](othIndex && array)
      : undefined;
  }
  array = arrays[0];

  var index = -1,
      seen = caches[0];

  outer:
  while (++index < length && result.length < maxLength) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (!(seen
          ? Object(__WEBPACK_IMPORTED_MODULE_5__cacheHas_js__["a" /* default */])(seen, computed)
          : includes(result, computed, comparator)
        )) {
      othIndex = othLength;
      while (--othIndex) {
        var cache = caches[othIndex];
        if (!(cache
              ? Object(__WEBPACK_IMPORTED_MODULE_5__cacheHas_js__["a" /* default */])(cache, computed)
              : includes(arrays[othIndex], computed, comparator))
            ) {
          continue outer;
        }
      }
      if (seen) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (baseIntersection);


/***/ }),
/* 251 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isArrayLikeObject_js__ = __webpack_require__(44);


/**
 * Casts `value` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */
function castArrayLikeObject(value) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__isArrayLikeObject_js__["a" /* default */])(value) ? value : [];
}

/* harmony default export */ __webpack_exports__["a"] = (castArrayLikeObject);


/***/ }),
/* 252 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSetData_js__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__createBind_js__ = __webpack_require__(253);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__createCurry_js__ = __webpack_require__(254);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__createHybrid_js__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__createPartial_js__ = __webpack_require__(260);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__getData_js__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__mergeData_js__ = __webpack_require__(261);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__setData_js__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__setWrapToString_js__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__toInteger_js__ = __webpack_require__(21);











/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_FLAG = 8,
    WRAP_CURRY_RIGHT_FLAG = 16,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_PARTIAL_RIGHT_FLAG = 64;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that either curries or invokes `func` with optional
 * `this` binding and partially applied arguments.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask flags.
 *    1 - `_.bind`
 *    2 - `_.bindKey`
 *    4 - `_.curry` or `_.curryRight` of a bound function
 *    8 - `_.curry`
 *   16 - `_.curryRight`
 *   32 - `_.partial`
 *   64 - `_.partialRight`
 *  128 - `_.rearg`
 *  256 - `_.ary`
 *  512 - `_.flip`
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to be partially applied.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
  if (!isBindKey && typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
    partials = holders = undefined;
  }
  ary = ary === undefined ? ary : nativeMax(Object(__WEBPACK_IMPORTED_MODULE_9__toInteger_js__["a" /* default */])(ary), 0);
  arity = arity === undefined ? arity : Object(__WEBPACK_IMPORTED_MODULE_9__toInteger_js__["a" /* default */])(arity);
  length -= holders ? holders.length : 0;

  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials,
        holdersRight = holders;

    partials = holders = undefined;
  }
  var data = isBindKey ? undefined : Object(__WEBPACK_IMPORTED_MODULE_5__getData_js__["a" /* default */])(func);

  var newData = [
    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
    argPos, ary, arity
  ];

  if (data) {
    Object(__WEBPACK_IMPORTED_MODULE_6__mergeData_js__["a" /* default */])(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === undefined
    ? (isBindKey ? 0 : func.length)
    : nativeMax(newData[9] - length, 0);

  if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
    bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG) {
    var result = Object(__WEBPACK_IMPORTED_MODULE_1__createBind_js__["a" /* default */])(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
    result = Object(__WEBPACK_IMPORTED_MODULE_2__createCurry_js__["a" /* default */])(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
    result = Object(__WEBPACK_IMPORTED_MODULE_4__createPartial_js__["a" /* default */])(func, bitmask, thisArg, partials);
  } else {
    result = __WEBPACK_IMPORTED_MODULE_3__createHybrid_js__["a" /* default */].apply(undefined, newData);
  }
  var setter = data ? __WEBPACK_IMPORTED_MODULE_0__baseSetData_js__["a" /* default */] : __WEBPACK_IMPORTED_MODULE_7__setData_js__["a" /* default */];
  return Object(__WEBPACK_IMPORTED_MODULE_8__setWrapToString_js__["a" /* default */])(setter(result, newData), func, bitmask);
}

/* harmony default export */ __webpack_exports__["a"] = (createWrap);


/***/ }),
/* 253 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createCtor_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__root_js__ = __webpack_require__(4);



/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1;

/**
 * Creates a function that wraps `func` to invoke it with the optional `this`
 * binding of `thisArg`.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG,
      Ctor = Object(__WEBPACK_IMPORTED_MODULE_0__createCtor_js__["a" /* default */])(func);

  function wrapper() {
    var fn = (this && this !== __WEBPACK_IMPORTED_MODULE_1__root_js__["a" /* default */] && this instanceof wrapper) ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}

/* harmony default export */ __webpack_exports__["a"] = (createBind);


/***/ }),
/* 254 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__apply_js__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__createCtor_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__createHybrid_js__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__createRecurry_js__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__getHolder_js__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__replaceHolders_js__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__root_js__ = __webpack_require__(4);








/**
 * Creates a function that wraps `func` to enable currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {number} arity The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createCurry(func, bitmask, arity) {
  var Ctor = Object(__WEBPACK_IMPORTED_MODULE_1__createCtor_js__["a" /* default */])(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length,
        placeholder = Object(__WEBPACK_IMPORTED_MODULE_4__getHolder_js__["a" /* default */])(wrapper);

    while (index--) {
      args[index] = arguments[index];
    }
    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
      ? []
      : Object(__WEBPACK_IMPORTED_MODULE_5__replaceHolders_js__["a" /* default */])(args, placeholder);

    length -= holders.length;
    if (length < arity) {
      return Object(__WEBPACK_IMPORTED_MODULE_3__createRecurry_js__["a" /* default */])(
        func, bitmask, __WEBPACK_IMPORTED_MODULE_2__createHybrid_js__["a" /* default */], wrapper.placeholder, undefined,
        args, holders, undefined, undefined, arity - length);
    }
    var fn = (this && this !== __WEBPACK_IMPORTED_MODULE_6__root_js__["a" /* default */] && this instanceof wrapper) ? Ctor : func;
    return Object(__WEBPACK_IMPORTED_MODULE_0__apply_js__["a" /* default */])(fn, this, args);
  }
  return wrapper;
}

/* harmony default export */ __webpack_exports__["a"] = (createCurry);


/***/ }),
/* 255 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Gets the number of `placeholder` occurrences in `array`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} placeholder The placeholder to search for.
 * @returns {number} Returns the placeholder count.
 */
function countHolders(array, placeholder) {
  var length = array.length,
      result = 0;

  while (length--) {
    if (array[length] === placeholder) {
      ++result;
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (countHolders);


/***/ }),
/* 256 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used to match wrap detail comments. */
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
    reSplitDetails = /,? & /;

/**
 * Extracts wrapper details from the `source` body comment.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {Array} Returns the wrapper details.
 */
function getWrapDetails(source) {
  var match = source.match(reWrapDetails);
  return match ? match[1].split(reSplitDetails) : [];
}

/* harmony default export */ __webpack_exports__["a"] = (getWrapDetails);


/***/ }),
/* 257 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used to match wrap detail comments. */
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;

/**
 * Inserts wrapper `details` in a comment at the top of the `source` body.
 *
 * @private
 * @param {string} source The source to modify.
 * @returns {Array} details The details to insert.
 * @returns {string} Returns the modified source.
 */
function insertWrapDetails(source, details) {
  var length = details.length;
  if (!length) {
    return source;
  }
  var lastIndex = length - 1;
  details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
  details = details.join(length > 2 ? ', ' : ' ');
  return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
}

/* harmony default export */ __webpack_exports__["a"] = (insertWrapDetails);


/***/ }),
/* 258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayEach_js__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayIncludes_js__ = __webpack_require__(43);



/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_FLAG = 8,
    WRAP_CURRY_RIGHT_FLAG = 16,
    WRAP_PARTIAL_FLAG = 32,
    WRAP_PARTIAL_RIGHT_FLAG = 64,
    WRAP_ARY_FLAG = 128,
    WRAP_REARG_FLAG = 256,
    WRAP_FLIP_FLAG = 512;

/** Used to associate wrap methods with their bit flags. */
var wrapFlags = [
  ['ary', WRAP_ARY_FLAG],
  ['bind', WRAP_BIND_FLAG],
  ['bindKey', WRAP_BIND_KEY_FLAG],
  ['curry', WRAP_CURRY_FLAG],
  ['curryRight', WRAP_CURRY_RIGHT_FLAG],
  ['flip', WRAP_FLIP_FLAG],
  ['partial', WRAP_PARTIAL_FLAG],
  ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
  ['rearg', WRAP_REARG_FLAG]
];

/**
 * Updates wrapper `details` based on `bitmask` flags.
 *
 * @private
 * @returns {Array} details The details to modify.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @returns {Array} Returns `details`.
 */
function updateWrapDetails(details, bitmask) {
  Object(__WEBPACK_IMPORTED_MODULE_0__arrayEach_js__["a" /* default */])(wrapFlags, function(pair) {
    var value = '_.' + pair[0];
    if ((bitmask & pair[1]) && !Object(__WEBPACK_IMPORTED_MODULE_1__arrayIncludes_js__["a" /* default */])(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}

/* harmony default export */ __webpack_exports__["a"] = (updateWrapDetails);


/***/ }),
/* 259 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__copyArray_js__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isIndex_js__ = __webpack_require__(23);



/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Reorder `array` according to the specified indexes where the element at
 * the first index is assigned as the first element, the element at
 * the second index is assigned as the second element, and so on.
 *
 * @private
 * @param {Array} array The array to reorder.
 * @param {Array} indexes The arranged array indexes.
 * @returns {Array} Returns `array`.
 */
function reorder(array, indexes) {
  var arrLength = array.length,
      length = nativeMin(indexes.length, arrLength),
      oldArray = Object(__WEBPACK_IMPORTED_MODULE_0__copyArray_js__["a" /* default */])(array);

  while (length--) {
    var index = indexes[length];
    array[length] = Object(__WEBPACK_IMPORTED_MODULE_1__isIndex_js__["a" /* default */])(index, arrLength) ? oldArray[index] : undefined;
  }
  return array;
}

/* harmony default export */ __webpack_exports__["a"] = (reorder);


/***/ }),
/* 260 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__apply_js__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__createCtor_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__root_js__ = __webpack_require__(4);




/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1;

/**
 * Creates a function that wraps `func` to invoke it with the `this` binding
 * of `thisArg` and `partials` prepended to the arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} partials The arguments to prepend to those provided to
 *  the new function.
 * @returns {Function} Returns the new wrapped function.
 */
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG,
      Ctor = Object(__WEBPACK_IMPORTED_MODULE_1__createCtor_js__["a" /* default */])(func);

  function wrapper() {
    var argsIndex = -1,
        argsLength = arguments.length,
        leftIndex = -1,
        leftLength = partials.length,
        args = Array(leftLength + argsLength),
        fn = (this && this !== __WEBPACK_IMPORTED_MODULE_2__root_js__["a" /* default */] && this instanceof wrapper) ? Ctor : func;

    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return Object(__WEBPACK_IMPORTED_MODULE_0__apply_js__["a" /* default */])(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}

/* harmony default export */ __webpack_exports__["a"] = (createPartial);


/***/ }),
/* 261 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__composeArgs_js__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__composeArgsRight_js__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__replaceHolders_js__ = __webpack_require__(46);




/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/** Used to compose bitmasks for function metadata. */
var WRAP_BIND_FLAG = 1,
    WRAP_BIND_KEY_FLAG = 2,
    WRAP_CURRY_BOUND_FLAG = 4,
    WRAP_CURRY_FLAG = 8,
    WRAP_ARY_FLAG = 128,
    WRAP_REARG_FLAG = 256;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Merges the function metadata of `source` into `data`.
 *
 * Merging metadata reduces the number of wrappers used to invoke a function.
 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
 * may be applied regardless of execution order. Methods like `_.ary` and
 * `_.rearg` modify function arguments, making the order in which they are
 * executed important, preventing the merging of metadata. However, we make
 * an exception for a safe combined case where curried functions have `_.ary`
 * and or `_.rearg` applied.
 *
 * @private
 * @param {Array} data The destination metadata.
 * @param {Array} source The source metadata.
 * @returns {Array} Returns `data`.
 */
function mergeData(data, source) {
  var bitmask = data[1],
      srcBitmask = source[1],
      newBitmask = bitmask | srcBitmask,
      isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

  var isCombo =
    ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
    ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
    ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

  // Exit early if metadata can't be merged.
  if (!(isCommon || isCombo)) {
    return data;
  }
  // Use source `thisArg` if available.
  if (srcBitmask & WRAP_BIND_FLAG) {
    data[2] = source[2];
    // Set when currying a bound function.
    newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
  }
  // Compose partial arguments.
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? Object(__WEBPACK_IMPORTED_MODULE_0__composeArgs_js__["a" /* default */])(partials, value, source[4]) : value;
    data[4] = partials ? Object(__WEBPACK_IMPORTED_MODULE_2__replaceHolders_js__["a" /* default */])(data[3], PLACEHOLDER) : source[4];
  }
  // Compose partial right arguments.
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? Object(__WEBPACK_IMPORTED_MODULE_1__composeArgsRight_js__["a" /* default */])(partials, value, source[6]) : value;
    data[6] = partials ? Object(__WEBPACK_IMPORTED_MODULE_2__replaceHolders_js__["a" /* default */])(data[5], PLACEHOLDER) : source[6];
  }
  // Use source `argPos` if available.
  value = source[7];
  if (value) {
    data[7] = value;
  }
  // Use source `ary` if it's smaller.
  if (srcBitmask & WRAP_ARY_FLAG) {
    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
  }
  // Use source `arity` if one is not provided.
  if (data[9] == null) {
    data[9] = source[9];
  }
  // Use source `func` and merge bitmasks.
  data[0] = source[0];
  data[1] = newBitmask;

  return data;
}

/* harmony default export */ __webpack_exports__["a"] = (mergeData);


/***/ }),
/* 262 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__toNumber_js__ = __webpack_require__(263);


/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = Object(__WEBPACK_IMPORTED_MODULE_0__toNumber_js__["a" /* default */])(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/* harmony default export */ __webpack_exports__["a"] = (toFinite);


/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isObject_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isSymbol_js__ = __webpack_require__(25);



/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (Object(__WEBPACK_IMPORTED_MODULE_1__isSymbol_js__["a" /* default */])(value)) {
    return NAN;
  }
  if (Object(__WEBPACK_IMPORTED_MODULE_0__isObject_js__["a" /* default */])(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = Object(__WEBPACK_IMPORTED_MODULE_0__isObject_js__["a" /* default */])(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/* harmony default export */ __webpack_exports__["a"] = (toNumber);


/***/ }),
/* 264 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFlatten_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseRest_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseUniq_js__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject_js__ = __webpack_require__(44);





/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = Object(__WEBPACK_IMPORTED_MODULE_1__baseRest_js__["a" /* default */])(function(arrays) {
  return Object(__WEBPACK_IMPORTED_MODULE_2__baseUniq_js__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_0__baseFlatten_js__["a" /* default */])(arrays, 1, __WEBPACK_IMPORTED_MODULE_3__isArrayLikeObject_js__["a" /* default */], true));
});

/* harmony default export */ __webpack_exports__["default"] = (union);


/***/ }),
/* 265 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Set_js__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__noop_js__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__setToArray_js__ = __webpack_require__(75);




/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(__WEBPACK_IMPORTED_MODULE_0__Set_js__["a" /* default */] && (1 / Object(__WEBPACK_IMPORTED_MODULE_2__setToArray_js__["a" /* default */])(new __WEBPACK_IMPORTED_MODULE_0__Set_js__["a" /* default */]([,-0]))[1]) == INFINITY) ? __WEBPACK_IMPORTED_MODULE_1__noop_js__["a" /* default */] : function(values) {
  return new __WEBPACK_IMPORTED_MODULE_0__Set_js__["a" /* default */](values);
};

/* harmony default export */ __webpack_exports__["a"] = (createSet);


/***/ }),
/* 266 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseValues_js__ = __webpack_require__(267);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__keys_js__ = __webpack_require__(11);



/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : Object(__WEBPACK_IMPORTED_MODULE_0__baseValues_js__["a" /* default */])(object, Object(__WEBPACK_IMPORTED_MODULE_1__keys_js__["default"])(object));
}

/* harmony default export */ __webpack_exports__["default"] = (values);


/***/ }),
/* 267 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayMap_js__ = __webpack_require__(7);


/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__arrayMap_js__["a" /* default */])(props, function(key) {
    return object[key];
  });
}

/* harmony default export */ __webpack_exports__["a"] = (baseValues);


/***/ }),
/* 268 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseSlice_js__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toInteger_js__ = __webpack_require__(21);



/**
 * Creates a slice of `array` with `n` elements dropped from the beginning.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.drop([1, 2, 3]);
 * // => [2, 3]
 *
 * _.drop([1, 2, 3], 2);
 * // => [3]
 *
 * _.drop([1, 2, 3], 5);
 * // => []
 *
 * _.drop([1, 2, 3], 0);
 * // => [1, 2, 3]
 */
function drop(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : Object(__WEBPACK_IMPORTED_MODULE_1__toInteger_js__["a" /* default */])(n);
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseSlice_js__["a" /* default */])(array, n < 0 ? 0 : n, length);
}

/* harmony default export */ __webpack_exports__["default"] = (drop);


/***/ }),
/* 269 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__copyObject_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__createAssigner_js__ = __webpack_require__(270);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__keysIn_js__ = __webpack_require__(34);




/**
 * This method is like `_.assign` except that it iterates over own and
 * inherited source properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assign
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assignIn({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
 */
var assignIn = Object(__WEBPACK_IMPORTED_MODULE_1__createAssigner_js__["a" /* default */])(function(object, source) {
  Object(__WEBPACK_IMPORTED_MODULE_0__copyObject_js__["a" /* default */])(source, Object(__WEBPACK_IMPORTED_MODULE_2__keysIn_js__["a" /* default */])(source), object);
});

/* harmony default export */ __webpack_exports__["a"] = (assignIn);


/***/ }),
/* 270 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseRest_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__isIterateeCall_js__ = __webpack_require__(70);



/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseRest_js__["a" /* default */])(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && Object(__WEBPACK_IMPORTED_MODULE_1__isIterateeCall_js__["a" /* default */])(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/* harmony default export */ __webpack_exports__["a"] = (createAssigner);


/***/ }),
/* 271 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseHas_js__ = __webpack_require__(272);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__hasPath_js__ = __webpack_require__(107);



/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && Object(__WEBPACK_IMPORTED_MODULE_1__hasPath_js__["a" /* default */])(object, path, __WEBPACK_IMPORTED_MODULE_0__baseHas_js__["a" /* default */]);
}

/* harmony default export */ __webpack_exports__["default"] = (has);


/***/ }),
/* 272 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

/* harmony default export */ __webpack_exports__["a"] = (baseHas);


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */



function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { program: peg$parseprogram },
      peg$startRuleFunction  = peg$parseprogram,

      peg$c0 = ";",
      peg$c1 = peg$literalExpectation(";", false),
      peg$c2 = function(p) {
          var stmts = [p[1]];
          stmts = stmts.concat(map(p[3], function(pp) {
              return pp[2];
          }));
          return new Ast.Program(stmts);
      },
      peg$c3 = "=",
      peg$c4 = peg$literalExpectation("=", false),
      peg$c5 = function(lhs, e) { return new Ast.Assignment(lhs, e); },
      peg$c6 = "+",
      peg$c7 = peg$literalExpectation("+", false),
      peg$c8 = "-",
      peg$c9 = peg$literalExpectation("-", false),
      peg$c10 = "*",
      peg$c11 = peg$literalExpectation("*", false),
      peg$c12 = "/",
      peg$c13 = peg$literalExpectation("/", false),
      peg$c14 = "%",
      peg$c15 = peg$literalExpectation("%", false),
      peg$c16 = "&",
      peg$c17 = peg$literalExpectation("&", false),
      peg$c18 = "|",
      peg$c19 = peg$literalExpectation("|", false),
      peg$c20 = function(head, tail) { return makeBinaryExpr(head, tail); },
      peg$c21 = function(op, oper) { return new Ast.UnaryExpr(op, oper); },
      peg$c22 = /^[a-zA-Z_]/,
      peg$c23 = peg$classExpectation([["a", "z"], ["A", "Z"], "_"], false, false),
      peg$c24 = /^[a-zA-Z_0-9]/,
      peg$c25 = peg$classExpectation([["a", "z"], ["A", "Z"], "_", ["0", "9"]], false, false),
      peg$c26 = "(",
      peg$c27 = peg$literalExpectation("(", false),
      peg$c28 = ",",
      peg$c29 = peg$literalExpectation(",", false),
      peg$c30 = ")",
      peg$c31 = peg$literalExpectation(")", false),
      peg$c32 = function(funcName, args) {
      		        var argsList = [];
      		        each(args[0], function(toks) {
      		            argsList.push(toks[1]);
      		        });
                      argsList.push(args[2]);
                      return new Ast.FuncCall(flattenChars(funcName), argsList);
      		},
      peg$c33 = function(e) { return e; },
      peg$c34 = function(val) { return new Ast.PrimaryExpr(flattenChars(val).toLowerCase(), "ID"); },
      peg$c35 = "$",
      peg$c36 = peg$literalExpectation("$", false),
      peg$c37 = function(val) { return new Ast.PrimaryExpr(flattenChars(val).toLowerCase(), "CONST"); },
      peg$c38 = "@",
      peg$c39 = peg$literalExpectation("@", false),
      peg$c40 = function(val) { return new Ast.PrimaryExpr("__REG_AT_" + flattenChars(val).toLowerCase(), "REG"); },
      peg$c41 = /^[rR]/,
      peg$c42 = peg$classExpectation(["r", "R"], false, false),
      peg$c43 = /^[eE]/,
      peg$c44 = peg$classExpectation(["e", "E"], false, false),
      peg$c45 = /^[gG]/,
      peg$c46 = peg$classExpectation(["g", "G"], false, false),
      peg$c47 = /^[0-9]/,
      peg$c48 = peg$classExpectation([["0", "9"]], false, false),
      peg$c49 = function(val) { return new Ast.PrimaryExpr("__REG_" + flattenChars(val).toLowerCase(), "REG"); },
      peg$c50 = ".",
      peg$c51 = peg$literalExpectation(".", false),
      peg$c52 = /^[Ee]/,
      peg$c53 = peg$classExpectation(["E", "e"], false, false),
      peg$c54 = function(val) { return new Ast.PrimaryExpr(parseFloat(flattenChars(val)), "VALUE"); },
      peg$c55 = /^[a-fA-F0-9]/,
      peg$c56 = peg$classExpectation([["a", "f"], ["A", "F"], ["0", "9"]], false, false),
      peg$c57 = /^[hH]/,
      peg$c58 = peg$classExpectation(["h", "H"], false, false),
      peg$c59 = function(val) { return new Ast.PrimaryExpr(parseInt(flattenChars(val), 16), "VALUE"); },
      peg$c60 = /^[dD]/,
      peg$c61 = peg$classExpectation(["d", "D"], false, false),
      peg$c62 = function(val) { return new Ast.PrimaryExpr(parseInt(flattenChars(val), 10), "VALUE"); },
      peg$c63 = /^[\t\x0B\f \xA0\uFEFF]/,
      peg$c64 = peg$classExpectation(["\t", "\x0B", "\f", " ", "\xA0", "\uFEFF"], false, false),
      peg$c65 = /^[\n\r\u2028\u2029]/,
      peg$c66 = peg$classExpectation(["\n", "\r", "\u2028", "\u2029"], false, false),
      peg$c67 = "/*",
      peg$c68 = peg$literalExpectation("/*", false),
      peg$c69 = "*/",
      peg$c70 = peg$literalExpectation("*/", false),
      peg$c71 = peg$anyExpectation(),
      peg$c72 = "//",
      peg$c73 = peg$literalExpectation("//", false),

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parseprogram() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = peg$parse__();
    if (s2 !== peg$FAILED) {
      s3 = peg$parsestatement();
      if (s3 !== peg$FAILED) {
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = [];
          s6 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 59) {
            s7 = peg$c0;
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c1); }
          }
          if (s7 !== peg$FAILED) {
            s8 = peg$parse__();
            if (s8 !== peg$FAILED) {
              s9 = peg$parsestatement();
              if (s9 !== peg$FAILED) {
                s10 = peg$parse__();
                if (s10 !== peg$FAILED) {
                  s7 = [s7, s8, s9, s10];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 59) {
              s7 = peg$c0;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c1); }
            }
            if (s7 !== peg$FAILED) {
              s8 = peg$parse__();
              if (s8 !== peg$FAILED) {
                s9 = peg$parsestatement();
                if (s9 !== peg$FAILED) {
                  s10 = peg$parse__();
                  if (s10 !== peg$FAILED) {
                    s7 = [s7, s8, s9, s10];
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          }
          if (s5 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 59) {
              s6 = peg$c0;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c1); }
            }
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parse__();
              if (s7 !== peg$FAILED) {
                s2 = [s2, s3, s4, s5, s6, s7];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c2(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parsestatement() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    s1 = peg$parseassignable();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61) {
          s3 = peg$c3;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c4); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse__();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseboolean_expr();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c5(s1, s5);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseboolean_expr();
    }

    return s0;
  }

  function peg$parseunary_ops() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 43) {
      s0 = peg$c6;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c7); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s0 = peg$c8;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c9); }
      }
    }

    return s0;
  }

  function peg$parseadditive_ops() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 43) {
      s0 = peg$c6;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c7); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 45) {
        s0 = peg$c8;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c9); }
      }
    }

    return s0;
  }

  function peg$parsemultiplicative_ops() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 42) {
      s0 = peg$c10;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c11); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 47) {
        s0 = peg$c12;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c13); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 37) {
          s0 = peg$c14;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c15); }
        }
      }
    }

    return s0;
  }

  function peg$parseboolean_ops() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 38) {
      s0 = peg$c16;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c17); }
    }
    if (s0 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 124) {
        s0 = peg$c18;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c19); }
      }
    }

    return s0;
  }

  function peg$parseboolean_expr() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parseadditive_expr();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseboolean_ops();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseadditive_expr();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseboolean_ops();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseadditive_expr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c20(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseadditive_expr() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parsemultiplicative_expr();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parseadditive_ops();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parsemultiplicative_expr();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseadditive_ops();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsemultiplicative_expr();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c20(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsemultiplicative_expr() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    s0 = peg$currPos;
    s1 = peg$parseunary();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$parse__();
      if (s4 !== peg$FAILED) {
        s5 = peg$parsemultiplicative_ops();
        if (s5 !== peg$FAILED) {
          s6 = peg$parse__();
          if (s6 !== peg$FAILED) {
            s7 = peg$parseunary();
            if (s7 !== peg$FAILED) {
              s4 = [s4, s5, s6, s7];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$parse__();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsemultiplicative_ops();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseunary();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c20(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseunary() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parseunary_ops();
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        s3 = peg$parsefunc_call();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c21(s1, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parsefunc_call();
    }

    return s0;
  }

  function peg$parsefunc_call() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (peg$c22.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c23); }
    }
    if (s2 !== peg$FAILED) {
      s3 = [];
      if (peg$c24.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c25); }
      }
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        if (peg$c24.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c25); }
        }
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse__();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 40) {
          s3 = peg$c26;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c27); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$currPos;
          s5 = [];
          s6 = peg$currPos;
          s7 = peg$parse__();
          if (s7 !== peg$FAILED) {
            s8 = peg$parseboolean_expr();
            if (s8 !== peg$FAILED) {
              s9 = peg$parse__();
              if (s9 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s10 = peg$c28;
                  peg$currPos++;
                } else {
                  s10 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c29); }
                }
                if (s10 !== peg$FAILED) {
                  s7 = [s7, s8, s9, s10];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$currPos;
            s7 = peg$parse__();
            if (s7 !== peg$FAILED) {
              s8 = peg$parseboolean_expr();
              if (s8 !== peg$FAILED) {
                s9 = peg$parse__();
                if (s9 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s10 = peg$c28;
                    peg$currPos++;
                  } else {
                    s10 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c29); }
                  }
                  if (s10 !== peg$FAILED) {
                    s7 = [s7, s8, s9, s10];
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse__();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseboolean_expr();
              if (s7 !== peg$FAILED) {
                s5 = [s5, s6, s7];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse__();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s6 = peg$c30;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c31); }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c32(s1, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseprimary_expr();
    }

    return s0;
  }

  function peg$parseprimary_expr() {
    var s0, s1, s2, s3;

    s0 = peg$parsevalue();
    if (s0 === peg$FAILED) {
      s0 = peg$parseconstant();
      if (s0 === peg$FAILED) {
        s0 = peg$parseregister();
        if (s0 === peg$FAILED) {
          s0 = peg$parseidentifier();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
              s1 = peg$c26;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c27); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseboolean_expr();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s3 = peg$c30;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c31); }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c33(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseassignable() {
    var s0;

    s0 = peg$parseregister();
    if (s0 === peg$FAILED) {
      s0 = peg$parseidentifier();
    }

    return s0;
  }

  function peg$parseidentifier() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$currPos;
    if (peg$c22.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c23); }
    }
    if (s2 !== peg$FAILED) {
      s3 = [];
      if (peg$c24.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c25); }
      }
      while (s4 !== peg$FAILED) {
        s3.push(s4);
        if (peg$c24.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c25); }
        }
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c34(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseconstant() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 36) {
      s1 = peg$c35;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c36); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c24.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c25); }
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (peg$c24.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c25); }
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c37(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseregister() {
    var s0, s1, s2, s3, s4, s5, s6;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 64) {
      s1 = peg$c38;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c39); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      if (peg$c24.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c25); }
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        if (peg$c24.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c25); }
        }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c40(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (peg$c41.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c42); }
      }
      if (s2 !== peg$FAILED) {
        if (peg$c43.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c44); }
        }
        if (s3 !== peg$FAILED) {
          if (peg$c45.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c46); }
          }
          if (s4 !== peg$FAILED) {
            if (peg$c47.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c48); }
            }
            if (s5 !== peg$FAILED) {
              if (peg$c47.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c48); }
              }
              if (s6 !== peg$FAILED) {
                s2 = [s2, s3, s4, s5, s6];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c49(s1);
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parsevalue() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8;

    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = [];
    if (peg$c47.test(input.charAt(peg$currPos))) {
      s3 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s3 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c48); }
    }
    while (s3 !== peg$FAILED) {
      s2.push(s3);
      if (peg$c47.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c48); }
      }
    }
    if (s2 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 46) {
        s3 = peg$c50;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        if (peg$c47.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c48); }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (peg$c47.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c48); }
            }
          }
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$currPos;
          if (peg$c52.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c53); }
          }
          if (s6 !== peg$FAILED) {
            s7 = [];
            if (peg$c47.test(input.charAt(peg$currPos))) {
              s8 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c48); }
            }
            if (s8 !== peg$FAILED) {
              while (s8 !== peg$FAILED) {
                s7.push(s8);
                if (peg$c47.test(input.charAt(peg$currPos))) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c48); }
                }
              }
            } else {
              s7 = peg$FAILED;
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = null;
          }
          if (s5 !== peg$FAILED) {
            s2 = [s2, s3, s4, s5];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c54(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      if (peg$c55.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c56); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c55.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c56); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        if (peg$c57.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c58); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c59(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        if (peg$c47.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c48); }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c47.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c48); }
            }
          }
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (peg$c60.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c61); }
          }
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c62(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      }
    }

    return s0;
  }

  function peg$parse__() {
    var s0, s1;

    s0 = [];
    s1 = peg$parsewhiteSpace();
    if (s1 === peg$FAILED) {
      s1 = peg$parselineEnd();
      if (s1 === peg$FAILED) {
        s1 = peg$parsecomment();
      }
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parsewhiteSpace();
      if (s1 === peg$FAILED) {
        s1 = peg$parselineEnd();
        if (s1 === peg$FAILED) {
          s1 = peg$parsecomment();
        }
      }
    }

    return s0;
  }

  function peg$parsewhiteSpace() {
    var s0;

    if (peg$c63.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c64); }
    }

    return s0;
  }

  function peg$parselineEnd() {
    var s0;

    if (peg$c65.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c66); }
    }

    return s0;
  }

  function peg$parsecomment() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c67) {
      s1 = peg$c67;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c68); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$currPos;
      s4 = peg$currPos;
      peg$silentFails++;
      if (input.substr(peg$currPos, 2) === peg$c69) {
        s5 = peg$c69;
        peg$currPos += 2;
      } else {
        s5 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c70); }
      }
      peg$silentFails--;
      if (s5 === peg$FAILED) {
        s4 = void 0;
      } else {
        peg$currPos = s4;
        s4 = peg$FAILED;
      }
      if (s4 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c71); }
        }
        if (s5 !== peg$FAILED) {
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      } else {
        peg$currPos = s3;
        s3 = peg$FAILED;
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c69) {
          s5 = peg$c69;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c70); }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c71); }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c69) {
          s3 = peg$c69;
          peg$currPos += 2;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c70); }
        }
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c72) {
        s1 = peg$c72;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c73); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parselineEnd();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = void 0;
        } else {
          peg$currPos = s4;
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c71); }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parselineEnd();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = void 0;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c71); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }


      var flatten = __webpack_require__(38).default;
      var map = __webpack_require__(13).default;
      var each = __webpack_require__(12).default;
      var Ast = __webpack_require__(135);

      function makeBinaryExpr(head, tail) {
          var result = head;
          tail.forEach(function(tailItem) {
              result = new Ast.BinaryExpr(tailItem[1], result, tailItem[3]);
          });
          return result;
      }

      function flattenChars(val) {
          return flatten(val).join("");
      }


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Component_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(0);
/**
 * Actions for BufferSave
 */
var BufferSaveAction;
(function (BufferSaveAction) {
    BufferSaveAction[BufferSaveAction["SAVE"] = 0] = "SAVE";
    BufferSaveAction[BufferSaveAction["RESTORE"] = 1] = "RESTORE";
    BufferSaveAction[BufferSaveAction["SAVERESTORE"] = 2] = "SAVERESTORE";
    BufferSaveAction[BufferSaveAction["RESTORESAVE"] = 3] = "RESTORESAVE";
})(BufferSaveAction || (BufferSaveAction = {}));
/**
 * A component that saves or restores a copy of the current
 * frame buffer
 */
var BufferSave = /** @class */ (function (_super) {
    __extends(BufferSave, _super);
    function BufferSave(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    BufferSave.prototype.init = function () {
        this.updateAction();
        this.updateBlendMode();
        this.updateBuffer();
    };
    BufferSave.prototype.draw = function () {
        var currentAction;
        if (this.action === BufferSaveAction.SAVERESTORE ||
            this.action === BufferSaveAction.RESTORESAVE) {
            currentAction = this.nextAction;
            // toggle next action
            this.nextAction =
                (this.nextAction === BufferSaveAction.SAVE) ? BufferSaveAction.RESTORE : BufferSaveAction.SAVE;
        }
        else {
            currentAction = this.action;
        }
        var tempTSM = this.main.getTempTSM();
        switch (currentAction) {
            case BufferSaveAction.SAVE:
                tempTSM.setAsRenderTarget(this.opts.bufferId);
                this.main.getCopier().run(null, { srcTexture: this.parent.getTSM().getCurrentTexture() });
                tempTSM.unsetAsRenderTarget();
                break;
            case BufferSaveAction.RESTORE:
                this.main.getCopier().run(this.parent.getTSM(), { srcTexture: tempTSM.getTexture(this.opts.bufferId) }, this.blendMode);
                break;
        }
    };
    BufferSave.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.main.getTempTSM().removeTexture(this.opts.bufferId);
    };
    BufferSave.prototype.updateAction = function () {
        this.action = BufferSaveAction[this.opts.action];
        if (this.action === BufferSaveAction.SAVERESTORE) {
            this.nextAction = BufferSaveAction.SAVE;
        }
        else if (this.action === BufferSaveAction.RESTORESAVE) {
            this.nextAction = BufferSaveAction.RESTORE;
        }
    };
    BufferSave.prototype.updateBuffer = function (value, key, oldValue) {
        // buffer names in TextureSetManager have to be string
        // converting to string to maintain backward compatibility
        this.opts.bufferId = this.opts.bufferId + "";
        if (oldValue) {
            this.main.getTempTSM().removeTexture(oldValue);
        }
        this.main.getTempTSM().addTexture(this.opts.bufferId);
    };
    BufferSave.prototype.updateBlendMode = function () {
        this.blendMode = utils_1.BlendMode[this.opts.blendMode];
    };
    BufferSave.componentName = "BufferSave";
    BufferSave.componentTag = "misc";
    BufferSave.optUpdateHandlers = {
        action: "updateAction",
        blendMode: "updateBlendMode",
        bufferId: "updateBuffer"
    };
    BufferSave.defaultOptions = {
        action: "SAVE",
        blendMode: "REPLACE",
        bufferId: "buffer1"
    };
    return BufferSave;
}(Component_1["default"]));
exports["default"] = BufferSave;


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Component_1 = __webpack_require__(2);
var compileExpr_1 = __webpack_require__(28);
// A component that simply runs some avs expressions.
// Useful to maintain global state
var GlobalVar = /** @class */ (function (_super) {
    __extends(GlobalVar, _super);
    function GlobalVar(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    GlobalVar.prototype.init = function () {
        var _this = this;
        this.updateCode();
        this.listenTo(this.main, "resize", function () { return _this.handleResize(); });
    };
    GlobalVar.prototype.draw = function () {
        var code = this.code;
        code.b = this.main.getAnalyser().isBeat() ? 1 : 0;
        if (!this.inited) {
            code.init();
            this.inited = true;
        }
        if (this.main.getAnalyser().isBeat()) {
            code.onBeat();
        }
        code.perFrame();
    };
    GlobalVar.prototype.updateCode = function () {
        this.code = compileExpr_1["default"](this.opts.code, ["init", "onBeat", "perFrame"]).codeInst;
        this.code.setup(this.main);
        this.inited = false;
    };
    GlobalVar.prototype.handleResize = function () {
        this.code.updateDimVars(this.main.getRctx().getGl());
    };
    GlobalVar.componentName = "GlobalVar";
    GlobalVar.componentTag = "misc";
    GlobalVar.optUpdateHandlers = {
        code: "updateCode"
    };
    GlobalVar.defaultOptions = {
        code: {
            init: "",
            onBeat: "",
            perFrame: ""
        }
    };
    return GlobalVar;
}(Component_1["default"]));
exports["default"] = GlobalVar;


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Component_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(0);
var ClearScreenProgram_1 = __webpack_require__(140);
// A component that clears the screen
var ClearScreen = /** @class */ (function (_super) {
    __extends(ClearScreen, _super);
    function ClearScreen(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    ClearScreen.prototype.init = function () {
        this.prevBeat = false;
        this.beatCount = 0;
        this.updateColor();
        this.updateProgram();
    };
    ClearScreen.prototype.draw = function () {
        var clear = false;
        if (this.opts.beatCount === 0) {
            clear = true;
        }
        else {
            if (this.main.getAnalyser().isBeat() && !this.prevBeat) {
                this.beatCount++;
                if (this.beatCount >= this.opts.beatCount) {
                    clear = true;
                    this.beatCount = 0;
                }
            }
            this.prevBeat = this.main.getAnalyser().isBeat();
        }
        if (clear) {
            this.program.run(this.parent.getTSM(), { color: this.color });
        }
    };
    ClearScreen.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.program.destroy();
    };
    ClearScreen.prototype.updateColor = function () {
        this.color = utils_1.parseColorNorm(this.opts.color);
    };
    ClearScreen.prototype.updateProgram = function () {
        var blendMode = utils_1.BlendMode[this.opts.blendMode];
        var program = new ClearScreenProgram_1["default"](this.main.getRctx(), blendMode);
        if (this.program) {
            this.program.destroy();
        }
        this.program = program;
    };
    ClearScreen.componentName = "ClearScreen";
    ClearScreen.componentTag = "render";
    ClearScreen.defaultOptions = {
        beatCount: 0,
        blendMode: "REPLACE",
        color: "#000000"
    };
    ClearScreen.optUpdateHandlers = {
        blendMode: "updateProgram",
        color: "updateColor"
    };
    return ClearScreen;
}(Component_1["default"]));
exports["default"] = ClearScreen;


/***/ }),
/* 277 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseIndexOf_js__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__toInteger_js__ = __webpack_require__(21);



/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Gets the index at which the first occurrence of `value` is found in `array`
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the
 * offset from the end of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.indexOf([1, 2, 1, 2], 2);
 * // => 1
 *
 * // Search from the `fromIndex`.
 * _.indexOf([1, 2, 1, 2], 2, 2);
 * // => 3
 */
function indexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : Object(__WEBPACK_IMPORTED_MODULE_1__toInteger_js__["a" /* default */])(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseIndexOf_js__["a" /* default */])(array, value, index);
}

/* harmony default export */ __webpack_exports__["default"] = (indexOf);


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Component_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(0);
var geometries_1 = __webpack_require__(85);
var ShaderProgram_1 = __webpack_require__(3);
// A particle that moves around depending on beat changes
var MovingParticle = /** @class */ (function (_super) {
    __extends(MovingParticle, _super);
    function MovingParticle(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    MovingParticle.prototype.init = function () {
        this.centerX = 0;
        this.centerY = 0;
        this.velocityX = 0;
        this.velocityY = 0;
        this.posX = 0;
        this.posY = 0;
        this.updateBlendMode();
        var gl = this.main.getRctx().getGl();
        this.program = new ShaderProgram_1["default"](this.main.getRctx(), {
            bindings: {
                attribs: {
                    points: { name: "a_points", drawMode: gl.TRIANGLE_FAN }
                },
                uniforms: {
                    color: { name: "u_color", valueType: utils_1.WebGLVarType._3FV },
                    position: { name: "u_position", valueType: utils_1.WebGLVarType._2FV },
                    scale: { name: "u_scale", valueType: utils_1.WebGLVarType._2FV }
                }
            },
            copyOnSwap: true,
            dynamicBlend: true,
            fragmentShader: "\n                uniform vec3 u_color;\n                void main() {\n                   setFragColor(vec4(u_color, 1));\n                }\n            ",
            vertexShader: "\n                attribute vec2 a_point;\n                uniform vec2 u_position;\n                uniform vec2 u_scale;\n                void main() {\n                   setPosition((a_point*u_scale)+u_position);\n                }\n            "
        });
        this.updateColor();
    };
    MovingParticle.prototype.draw = function () {
        if (this.main.getAnalyser().isBeat()) {
            this.centerX = (Math.random() * 2 - 1) * 0.3;
            this.centerY = (Math.random() * 2 - 1) * 0.3;
        }
        this.velocityX -= 0.004 * (this.posX - this.centerX);
        this.velocityY -= 0.004 * (this.posY - this.centerY);
        this.posX += this.velocityX;
        this.posY += this.velocityY;
        this.velocityX *= 0.991;
        this.velocityY *= 0.991;
        var x = this.posX * this.opts.distance;
        var y = this.posY * this.opts.distance;
        var scaleX;
        var scaleY;
        if (this.opts.onBeatSizeChange && this.main.getAnalyser().isBeat()) {
            scaleX = this.opts.onBeatParticleSize;
            scaleY = this.opts.onBeatParticleSize;
        }
        else {
            scaleX = this.opts.particleSize;
            scaleY = this.opts.particleSize;
        }
        var gl = this.main.getRctx().getGl();
        scaleX = 2 * scaleX / gl.drawingBufferWidth;
        scaleY = 2 * scaleY / gl.drawingBufferHeight;
        this.program.run(this.parent.getTSM(), {
            color: this.color,
            points: geometries_1.circleGeometry(this.main.getRctx()),
            position: [x, y],
            scale: [scaleX, scaleY]
        }, this.blendMode);
    };
    MovingParticle.prototype.updateBlendMode = function () {
        this.blendMode = utils_1.BlendMode[this.opts.blendMode];
    };
    MovingParticle.prototype.updateColor = function () {
        this.color = utils_1.parseColorNorm(this.opts.color);
    };
    MovingParticle.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.program.destroy();
    };
    MovingParticle.componentName = "MovingParticle";
    MovingParticle.componentTag = "render";
    MovingParticle.optUpdateHandlers = {
        blendMode: "updateBlendMode",
        color: "updateColor"
    };
    MovingParticle.defaultOptions = {
        blendMode: "REPLACE",
        color: "#FFFFFF",
        distance: 0.7,
        onBeatParticleSize: 10,
        onBeatSizeChange: false,
        particleSize: 10
    };
    return MovingParticle;
}(Component_1["default"]));
exports["default"] = MovingParticle;


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Component_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(0);
var geometries_1 = __webpack_require__(85);
var ShaderProgram_1 = __webpack_require__(3);
// A component that renders an image onto the screen
var Picture = /** @class */ (function (_super) {
    __extends(Picture, _super);
    function Picture(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    Picture.prototype.init = function () {
        var gl = this.main.getRctx().getGl();
        this.program = new ShaderProgram_1["default"](this.main.getRctx(), {
            bindings: {
                attribs: {
                    points: { name: "a_texVertex", drawMode: gl.TRIANGLES }
                },
                uniforms: {
                    image: { name: "u_image", valueType: utils_1.WebGLVarType.TEXTURE2D },
                    imageRes: { name: "u_texRes", valueType: utils_1.WebGLVarType._2FV },
                    position: { name: "u_pos", valueType: utils_1.WebGLVarType._2FV }
                }
            },
            copyOnSwap: true,
            fragmentShader: "\n                uniform sampler2D u_image;\n                varying vec2 v_texCoord;\n                void main() {\n                   setFragColor(texture2D(u_image, v_texCoord));\n                }\n            ",
            vertexShader: "\n                attribute vec2 a_texVertex;\n                uniform vec2 u_pos;\n                uniform vec2 u_texRes;\n                varying vec2 v_texCoord;\n\n                void main() {\n                   v_texCoord = a_texVertex;\n                   setPosition(a_texVertex*(u_texRes/u_resolution)*vec2(2,-2)+u_pos);\n                }\n            "
        });
        this.updateImage();
    };
    Picture.prototype.draw = function () {
        this.program.run(this.parent.getTSM(), {
            image: this.texture,
            imageRes: [this.width, this.height],
            points: geometries_1.squareGeometry(this.main.getRctx(), true),
            position: [this.opts.x, -this.opts.y]
        });
    };
    Picture.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.program.destroy();
        this.main.getRctx().getGl().deleteTexture(this.texture);
    };
    Picture.prototype.updateImage = function () {
        var _this = this;
        var gl = this.main.getRctx().getGl();
        this.main.getRsrcMan().getImage(this.opts.src, function (image) {
            _this.width = image.width;
            _this.height = image.height;
            if (!_this.texture) {
                _this.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, _this.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            }
            else {
                gl.bindTexture(gl.TEXTURE_2D, _this.texture);
            }
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        });
    };
    Picture.componentName = "Picture";
    Picture.componentTag = "render";
    Picture.optUpdateHandlers = {
        src: "updateImage"
    };
    Picture.defaultOptions = {
        src: "avsres_texer_circle_edgeonly_19x19.bmp",
        x: 0,
        y: 0
    };
    return Picture;
}(Component_1["default"]));
exports["default"] = Picture;


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var each_1 = __webpack_require__(12);
var map_1 = __webpack_require__(13);
var Component_1 = __webpack_require__(2);
var CodeInstance_1 = __webpack_require__(84);
var compileExpr_1 = __webpack_require__(28);
var utils_1 = __webpack_require__(0);
var Buffer_1 = __webpack_require__(29);
var ShaderProgram_1 = __webpack_require__(3);
/**
 * Drawing modes for the [[SuperScope]] component
 */
var SuperScopeDrawMode;
(function (SuperScopeDrawMode) {
    SuperScopeDrawMode[SuperScopeDrawMode["LINES"] = 1] = "LINES";
    SuperScopeDrawMode[SuperScopeDrawMode["DOTS"] = 2] = "DOTS";
})(SuperScopeDrawMode || (SuperScopeDrawMode = {}));
/**
 * A generic scope, that can draw points or lines based on user code
 */
var SuperScope = /** @class */ (function (_super) {
    __extends(SuperScope, _super);
    function SuperScope(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    SuperScope.prototype.init = function () {
        var _this = this;
        this.updateDrawMode();
        this.updateSource();
        this.updateProgram();
        this.updateCode();
        this.updateClones();
        this.updateSpeed();
        this.updateColors();
        this.updateChannel();
        this.updateThickness();
        this.listenTo(this.main, "resize", function () { return _this.handleResize(); });
        this.pointBuffer = new Buffer_1["default"](this.main.getRctx());
        this.colorBuffer = new Buffer_1["default"](this.main.getRctx());
    };
    SuperScope.prototype.draw = function () {
        var _this = this;
        var color = this._makeColor();
        each_1["default"](this.code, function (code) {
            _this.drawScope(code, color, !_this.inited);
        });
        this.inited = true;
    };
    SuperScope.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.program.destroy();
        this.pointBuffer.destroy();
        this.colorBuffer.destroy();
    };
    /**
     * renders the scope
     * @memberof Webvs.SuperScope#
     */
    SuperScope.prototype.drawScope = function (code, color, runInit) {
        var gl = this.main.getRctx().getGl();
        code.red = color[0];
        code.green = color[1];
        code.blue = color[2];
        if (runInit) {
            code.init();
        }
        var beat = this.main.getAnalyser().isBeat();
        code.b = beat ? 1 : 0;
        code.perFrame();
        if (beat) {
            code.onBeat();
        }
        var nPoints = Math.floor(code.n);
        var data;
        if (this.source === utils_1.Source.SPECTRUM) {
            data = this.main.getAnalyser().getSpectrum(this.channel);
        }
        else {
            data = this.main.getAnalyser().getWaveform(this.channel);
        }
        var dots = this.drawMode === SuperScopeDrawMode.DOTS;
        var bucketSize = data.length / nPoints;
        var pbi = 0;
        var cdi = 0;
        var bufferSize;
        var thickX;
        var thickY;
        var lastX;
        var lastY;
        var lastR;
        var lastG;
        var lastB;
        if (this.veryThick) {
            bufferSize = (dots ? (nPoints * 6) : (nPoints * 6 - 6));
            thickX = this.opts.thickness / gl.drawingBufferWidth;
            thickY = this.opts.thickness / gl.drawingBufferHeight;
        }
        else {
            bufferSize = (dots ? nPoints : (nPoints * 2 - 2));
        }
        var pointBufferData = new Float32Array(bufferSize * 2);
        var colorData = new Float32Array(bufferSize * 3);
        for (var i = 0; i < nPoints; i++) {
            var value = 0;
            var size = 0;
            for (var j = Math.floor(i * bucketSize); j < (i + 1) * bucketSize; j++, size++) {
                value += data[j];
            }
            value = value / size;
            var pos = i / ((nPoints > 1) ? (nPoints - 1) : 1);
            code.i = pos;
            code.v = value;
            code.perPoint();
            code.y *= -1;
            if (this.veryThick) {
                if (dots) {
                    // just a box at current point
                    pointBufferData[pbi++] = code.x - thickX;
                    pointBufferData[pbi++] = code.y - thickY;
                    pointBufferData[pbi++] = code.x + thickX;
                    pointBufferData[pbi++] = code.y - thickY;
                    pointBufferData[pbi++] = code.x - thickX;
                    pointBufferData[pbi++] = code.y + thickY;
                    pointBufferData[pbi++] = code.x + thickX;
                    pointBufferData[pbi++] = code.y - thickY;
                    pointBufferData[pbi++] = code.x - thickX;
                    pointBufferData[pbi++] = code.y + thickY;
                    pointBufferData[pbi++] = code.x + thickX;
                    pointBufferData[pbi++] = code.y + thickY;
                    for (var j = 0; j < 6; j++) {
                        colorData[cdi++] = code.red;
                        colorData[cdi++] = code.green;
                        colorData[cdi++] = code.blue;
                    }
                }
                else {
                    if (i !== 0) {
                        var xdiff = Math.abs(lastX - code.x);
                        var ydiff = Math.abs(lastY - code.y);
                        var xoff = (xdiff <= ydiff) ? thickX : 0;
                        var yoff = (xdiff > ydiff) ? thickY : 0;
                        // a rectangle from last point to the current point
                        pointBufferData[pbi++] = lastX + xoff;
                        pointBufferData[pbi++] = lastY + yoff;
                        pointBufferData[pbi++] = code.x + xoff;
                        pointBufferData[pbi++] = code.y + yoff;
                        pointBufferData[pbi++] = lastX - xoff;
                        pointBufferData[pbi++] = lastY - yoff;
                        pointBufferData[pbi++] = code.x + xoff;
                        pointBufferData[pbi++] = code.y + yoff;
                        pointBufferData[pbi++] = lastX - xoff;
                        pointBufferData[pbi++] = lastY - yoff;
                        pointBufferData[pbi++] = code.x - xoff;
                        pointBufferData[pbi++] = code.y - yoff;
                        for (var j = 0; j < 6; j++) {
                            colorData[cdi++] = code.red;
                            colorData[cdi++] = code.green;
                            colorData[cdi++] = code.blue;
                        }
                    }
                    lastX = code.x;
                    lastY = code.y;
                    lastR = code.red;
                    lastG = code.green;
                    lastB = code.blue;
                }
            }
            else {
                if (dots) {
                    // just a point at the current point
                    pointBufferData[pbi++] = code.x;
                    pointBufferData[pbi++] = code.y;
                    colorData[cdi++] = code.red;
                    colorData[cdi++] = code.green;
                    colorData[cdi++] = code.blue;
                }
                else {
                    if (i !== 0) {
                        // lines from last point to current point
                        pointBufferData[pbi++] = lastX;
                        pointBufferData[pbi++] = lastY;
                        pointBufferData[pbi++] = code.x;
                        pointBufferData[pbi++] = code.y;
                        for (var j = 0; j < 2; j++) {
                            // use current color for both points because
                            // we dont want color interpolation between points
                            colorData[cdi++] = code.red;
                            colorData[cdi++] = code.green;
                            colorData[cdi++] = code.blue;
                        }
                    }
                    lastX = code.x;
                    lastY = code.y;
                    lastR = code.red;
                    lastG = code.green;
                    lastB = code.blue;
                }
            }
        }
        this.pointBuffer.setData(pointBufferData);
        this.colorBuffer.setData(colorData);
        this.program.run(this.parent.getTSM(), {
            colors: this.colorBuffer,
            drawTriangles: this.veryThick,
            isDots: dots,
            pointSize: this.veryThick ? 1 : this.opts.thickness,
            points: this.pointBuffer
        });
    };
    SuperScope.prototype.updateProgram = function () {
        var blendMode = utils_1.BlendMode[this.opts.blendMode];
        var program = new ShaderProgram_1["default"](this.main.getRctx(), {
            bindings: {
                attribs: {
                    colors: { name: "a_color", size: 3 },
                    points: { name: "a_position" }
                },
                uniforms: {
                    pointSize: { name: "u_pointSize", valueType: utils_1.WebGLVarType._1F }
                }
            },
            blendMode: blendMode,
            copyOnSwap: true,
            drawHook: function (values, gl) {
                var prevLineWidth;
                if (!values.isDots) {
                    prevLineWidth = gl.getParameter(gl.LINE_WIDTH);
                    gl.lineWidth(values.pointSize);
                }
                var mode;
                if (values.drawTriangles) {
                    mode = gl.TRIANGLES;
                }
                else if (values.isDots) {
                    mode = gl.POINTS;
                }
                else {
                    mode = gl.LINES;
                }
                gl.drawArrays(mode, 0, values.points.getLength() / 2);
                if (!values.isDots) {
                    gl.lineWidth(prevLineWidth);
                }
            },
            fragmentShader: "\n                varying vec3 v_color;\n                void main() {\n                    setFragColor(vec4(v_color, 1));\n                }\n            ",
            vertexShader: "\n                attribute vec2 a_position;\n                attribute vec3 a_color;\n                varying vec3 v_color;\n                uniform float u_pointSize;\n                void main() {\n                    gl_PointSize = u_pointSize;\n                    setPosition(a_position);\n                    v_color = a_color;\n                }\n            "
        });
        if (this.program) {
            this.program.destroy();
        }
        this.program = program;
    };
    SuperScope.prototype.updateCode = function () {
        var code = compileExpr_1["default"](this.opts.code, ["init", "onBeat", "perFrame", "perPoint"]).codeInst;
        code.n = 100;
        code.setup(this.main);
        this.inited = false;
        this.code = [code];
    };
    SuperScope.prototype.updateClones = function () {
        this.code = CodeInstance_1["default"].clone(this.code, this.opts.clone);
    };
    SuperScope.prototype.updateColors = function () {
        this.colors = map_1["default"](this.opts.colors, utils_1.parseColorNorm);
        this.curColorId = 0;
    };
    SuperScope.prototype.updateSpeed = function () {
        var oldMaxStep = this.maxStep;
        this.maxStep = Math.floor(1 / this.opts.cycleSpeed);
        if (this.curStep) {
            // curStep adjustment when speed changes
            this.curStep = Math.floor((this.curStep / oldMaxStep) * this.maxStep);
        }
        else {
            this.curStep = 0;
        }
    };
    SuperScope.prototype.updateChannel = function () {
        this.channel = utils_1.Channels[this.opts.channel];
    };
    SuperScope.prototype.updateSource = function () {
        this.source = utils_1.Source[this.opts.source];
    };
    SuperScope.prototype.updateDrawMode = function () {
        this.drawMode = SuperScopeDrawMode[this.opts.drawMode];
    };
    SuperScope.prototype.updateThickness = function () {
        var range;
        var gl = this.main.getRctx().getGl();
        if (this.drawMode === SuperScopeDrawMode.DOTS) {
            range = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);
        }
        else {
            range = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
        }
        if (this.opts.thickness < range[0] || this.opts.thickness > range[1]) {
            this.veryThick = true;
        }
        else {
            this.veryThick = false;
        }
    };
    SuperScope.prototype._makeColor = function () {
        if (this.colors.length === 1) {
            return this.colors[0];
        }
        else {
            var color = [0, 0, 0];
            var currentColor = this.colors[this.curColorId];
            var nextColor = this.colors[(this.curColorId + 1) % this.colors.length];
            var mix = this.curStep / this.maxStep;
            for (var i = 0; i < 3; i++) {
                color[i] = currentColor[i] * (1 - mix) + nextColor[i] * mix;
            }
            this.curStep = (this.curStep + 1) % this.maxStep;
            if (this.curStep === 0) {
                this.curColorId = (this.curColorId + 1) % this.colors.length;
            }
            return color;
        }
    };
    SuperScope.prototype.handleResize = function () {
        var _this = this;
        each_1["default"](this.code, function (code) {
            code.updateDimVars(_this.main.getRctx().getGl());
        });
    };
    SuperScope.componentName = "SuperScope";
    SuperScope.componentTag = "render";
    SuperScope.optUpdateHandlers = {
        blendMode: "updateProgram",
        channel: "updateChannel",
        clone: "updateClones",
        code: ["updateCode", "updateClones"],
        colors: "updateColors",
        cycleSpeed: "updateSpeed",
        drawMode: "updateDrawMode",
        source: "updateSource",
        thickness: "updateThickness"
    };
    SuperScope.defaultOptions = {
        blendMode: "REPLACE",
        channel: "CENTER",
        clone: 1,
        code: {
            init: "n=800",
            onBeat: "",
            perFrame: "t=t-0.05",
            perPoint: "d=i+v*0.2; r=t+i*$PI*4; x=cos(r)*d; y=sin(r)*d"
        },
        colors: ["#ffffff"],
        cycleSpeed: 0.01,
        drawMode: "LINES",
        source: "SPECTRUM",
        thickness: 1
    };
    return SuperScope;
}(Component_1["default"]));
exports["default"] = SuperScope;


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var each_1 = __webpack_require__(12);
var Component_1 = __webpack_require__(2);
var CodeInstance_1 = __webpack_require__(84);
var compileExpr_1 = __webpack_require__(28);
var utils_1 = __webpack_require__(0);
var Buffer_1 = __webpack_require__(29);
var ShaderProgram_1 = __webpack_require__(3);
// A SuperScope like component that places images at points.
var Texer = /** @class */ (function (_super) {
    __extends(Texer, _super);
    function Texer(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    Texer.prototype.handleResize = function () {
        for (var _i = 0, _a = this.code; _i < _a.length; _i++) {
            var codeInst = _a[_i];
            codeInst.updateDimVars(this.main.getRctx().getGl());
        }
    };
    Texer.prototype.init = function () {
        var _this = this;
        var rctx = this.main.getRctx();
        var gl = this.main.getRctx().getGl();
        this.program = new ShaderProgram_1["default"](rctx, {
            bindings: {
                attribs: {
                    colors: { name: "a_color", size: 3 },
                    texVertices: { name: "a_texVertex" },
                    vertices: { name: "a_vertex" }
                },
                index: {
                    drawMode: gl.TRIANGLES,
                    valueName: "indices"
                },
                uniforms: {
                    colorFilter: { name: "u_colorFilter", valueType: utils_1.WebGLVarType._1I },
                    image: { name: "u_image", valueType: utils_1.WebGLVarType.TEXTURE2D }
                }
            },
            copyOnSwap: true,
            fragmentShader: "\n                uniform bool u_colorFilter;\n                uniform sampler2D u_image;\n                varying vec2 v_texVertex;\n                varying vec3 v_color;\n                void main() {\n                   vec3 outColor = texture2D(u_image, v_texVertex).rgb;\n                   if(u_colorFilter) {\n                       outColor = outColor*v_color;\n                   }\n                   setFragColor(vec4(outColor, 1));\n                }\n            ",
            vertexShader: "\n                uniform bool u_colorFilter;\n                attribute vec2 a_texVertex;\n                attribute vec2 a_vertex;\n                attribute vec3 a_color;\n                varying vec2 v_texVertex;\n                varying vec3 v_color;\n                void main() {\n                   if(u_colorFilter) {\n                       v_color = a_color;\n                   }\n                   v_texVertex = a_texVertex;\n                   setPosition(a_vertex);\n                }\n            "
        });
        this.updateCode();
        this.updateClone();
        this.updateImage();
        this.updateSource();
        this.listenTo(this.main, "resize", function () { return _this.handleResize(); });
        this.vertexBuffer = new Buffer_1["default"](rctx);
        this.texVertexBuffer = new Buffer_1["default"](rctx);
        this.colorBuffer = new Buffer_1["default"](rctx);
        this.indexBuffer = new Buffer_1["default"](rctx, true);
    };
    Texer.prototype.draw = function () {
        var _this = this;
        each_1["default"](this.code, function (code) {
            _this._drawScope(code, !_this.inited);
        });
        this.inited = true;
    };
    Texer.prototype.destroy = function () {
        var gl = this.main.getRctx().getGl();
        _super.prototype.destroy.call(this);
        this.program.destroy();
        gl.deleteTexture(this.texture);
        this.vertexBuffer.destroy();
        this.texVertexBuffer.destroy();
        this.colorBuffer.destroy();
        this.indexBuffer.destroy();
    };
    Texer.prototype.updateCode = function () {
        var code = compileExpr_1["default"](this.opts.code, ["init", "onBeat", "perFrame", "perPoint"]).codeInst;
        code.n = 100;
        code.setup(this.main);
        this.inited = false;
        this.code = [code];
    };
    Texer.prototype.updateClone = function () {
        this.code = CodeInstance_1["default"].clone(this.code, this.opts.clone);
    };
    Texer.prototype.updateImage = function () {
        var _this = this;
        var gl = this.main.getRctx().getGl();
        this.main.getRsrcMan().getImage(this.opts.imageSrc, function (image) {
            _this.imageWidth = image.width;
            _this.imageHeight = image.height;
            if (!_this.texture) {
                _this.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, _this.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            }
            else {
                gl.bindTexture(gl.TEXTURE_2D, _this.texture);
            }
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        });
    };
    Texer.prototype.updateSource = function () {
        this.source = utils_1.Source[this.opts.source];
    };
    Texer.prototype._drawScope = function (code, runInit) {
        var gl = this.main.getRctx().getGl();
        if (runInit) {
            code.init();
        }
        var beat = this.main.getAnalyser().isBeat();
        code.b = beat ? 1 : 0;
        code.perFrame();
        if (beat) {
            code.onBeat();
        }
        var nPoints = Math.floor(code.n);
        var data;
        if (this.source === utils_1.Source.SPECTRUM) {
            data = this.main.getAnalyser().getSpectrum();
        }
        else {
            data = this.main.getAnalyser().getWaveform();
        }
        var bucketSize = data.length / nPoints;
        var vertexData = [];
        var texVertexData = [];
        var vertexIndices = [];
        var colorData = this.opts.colorFiltering ? [] : null;
        var index = 0;
        var addRect = function (cornx, corny, sizex, sizey, red, green, blue) {
            if (cornx < -1 - sizex || cornx > 1 ||
                corny < -1 - sizey || corny > 1) {
                return;
            }
            // screen coordinates
            vertexData.push(cornx, corny, cornx + sizex, corny, cornx + sizex, corny + sizey, cornx, corny + sizey);
            // texture coordinates
            texVertexData.push(0, 0, 1, 0, 1, 1, 0, 1);
            if (colorData) {
                // color data
                colorData.push(red, green, blue, red, green, blue, red, green, blue, red, green, blue);
            }
            // indices
            vertexIndices.push(index + 0, index + 1, index + 2, index + 0, index + 2, index + 3);
            index += 4;
        };
        var imageSizex = (this.imageWidth / gl.drawingBufferWidth) * 2;
        var imageSizey = (this.imageHeight / gl.drawingBufferHeight) * 2;
        for (var i = 0; i < nPoints; i++) {
            var value = 0;
            var size = 0;
            for (var j = Math.floor(i * bucketSize); j < (i + 1) * bucketSize; j++, size++) {
                value += data[j];
            }
            value = value / size;
            var pos = i / (nPoints - 1);
            code.i = pos;
            code.v = value;
            code.sizex = 1;
            code.sizey = 1;
            code.red = 1;
            code.green = 1;
            code.blue = 1;
            code.perPoint();
            var sizex = imageSizex;
            var sizey = imageSizey;
            if (this.opts.resizing) {
                sizex *= code.sizex;
                sizey *= code.sizey;
            }
            var cornx = code.x - sizex / 2;
            var corny = (-code.y) - sizey / 2;
            addRect(cornx, corny, sizex, sizey, code.red, code.green, code.blue);
            if (this.opts.wrapAround) {
                // wrapped around x value is 1-(-1-cornx) or -1-(1-cornx)
                // depending on the edge
                // ie. 2+cornx or -2+cornx
                var xwrap = (cornx < -1) ? 2 : ((cornx > (1 - sizex)) ? -2 : 0);
                var ywrap = (corny < -1) ? 2 : ((corny > (1 - sizey)) ? -2 : 0);
                if (xwrap) {
                    addRect(xwrap + cornx, corny, sizex, sizey, code.red, code.green, code.blue);
                }
                if (ywrap) {
                    addRect(cornx, ywrap + corny, sizex, sizey, code.red, code.green, code.blue);
                }
                if (xwrap && ywrap) {
                    addRect(xwrap + cornx, ywrap + corny, sizex, sizey, code.red, code.green, code.blue);
                }
            }
        }
        this.vertexBuffer.setData(vertexData);
        this.texVertexBuffer.setData(texVertexData);
        this.indexBuffer.setData(new Uint16Array(vertexIndices));
        if (colorData) {
            this.colorBuffer.setData(colorData);
        }
        this.program.run(this.parent.getTSM(), {
            colorFilter: colorData ? 1 : 0,
            colors: colorData ? this.colorBuffer : null,
            image: this.texture,
            indices: this.indexBuffer,
            texVertices: this.texVertexBuffer,
            vertices: this.vertexBuffer
        });
    };
    Texer.componentName = "Texer";
    Texer.componentTag = "render";
    Texer.optUpdateHandlers = {
        clone: "updateClone",
        code: "updateCode",
        imageSrc: "updateImage",
        source: "updateSource"
    };
    Texer.defaultOptions = {
        clone: 1,
        code: {
            init: "",
            onBeat: "",
            perFrame: "",
            perPoint: ""
        },
        colorFiltering: true,
        imageSrc: "avsres_texer_circle_edgeonly_19x19.bmp",
        resizing: false,
        source: "SPECTRUM",
        wrapAround: false
    };
    return Texer;
}(Component_1["default"]));
exports["default"] = Texer;


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var clone_1 = __webpack_require__(47);
var extend_1 = __webpack_require__(136);
var isArray_1 = __webpack_require__(1);
var pickBy_1 = __webpack_require__(283);
var Model_1 = __webpack_require__(76);
/**
 * ResourceManager manages async loading and caching of resources.
 *
 * ResourceManager Basically, it maintains a map of fileNames to URI for
 * the resource. When a request for resource fileName is received, the uri is looked up
 * and the file is either async loaded or served from cache. This also manages
 * a ready state with callbacks that tells when one or more resources are being loaded and
 * when all resources are ready.
 */
var ResourceManager = /** @class */ (function (_super) {
    __extends(ResourceManager, _super);
    function ResourceManager(packs) {
        var _this = _super.call(this) || this;
        _this.ready = true;
        _this.uris = {};
        _this.images = {};
        _this.waitImages = {};
        _this.waitCount = 0;
        if (packs) {
            if (!isArray_1["default"](packs)) {
                packs = [packs];
            }
            _this.packs = packs;
        }
        else {
            _this.packs = [];
        }
        _this.clear();
        return _this;
    }
    /**
     * Register a filename and a URI in the resource manager.
     *
     * @param fileName name of the file or map of filename: uri.
     * @param uri uri when string fileName is specified
     */
    ResourceManager.prototype.registerUri = function (fileName, uri) {
        if (typeof fileName === "string" && typeof uri === "string") {
            this.uris[fileName] = uri;
        }
        else {
            var inputUris = fileName;
            extend_1["default"](this.uris, inputUris);
        }
    };
    /**
     * Returns the attributes for this ResourceManager
     *
     * @param key the name of the attribute. Only `"uris"` is acceptable.
     */
    ResourceManager.prototype.get = function (key) {
        if (key === "uris") {
            return this.uris;
        }
    };
    /**
     * Returns JSON representation of the resource manager
     */
    ResourceManager.prototype.toJSON = function () {
        return {
            uris: clone_1["default"](this.uris)
        };
    };
    /**
     * Clears state, uri mappings and caches. Browser caches still apply.
     *
     * @param keys the keys which should be cleared. Default clears everything.
     */
    ResourceManager.prototype.clear = function (keys) {
        if (keys === void 0) { keys = null; }
        for (var fileName in this.waitImages) {
            if (!this.waitImages.hasOwnProperty(fileName)) {
                continue;
            }
            var image = this.waitImages[fileName];
            image.onload = null;
            image.onerror = null;
        }
        this.waitImages = {};
        if (keys) {
            var pickPredicate = function (val, key) { return keys.indexOf(key) === -1; };
            this.uris = pickBy_1["default"](this.uris, pickPredicate);
            this.images = pickBy_1["default"](this.images, pickPredicate);
        }
        else {
            this.uris = {};
            this.images = {};
        }
        this.waitCount = 0;
        this.ready = true;
    };
    /**
     * Loads an Image resource.
     *
     * @param fileName fileName of the image to be returned
     * @param success handler that'll be called on success
     * @param error handler that'll be called on error
     */
    ResourceManager.prototype.getImage = function (fileName, success, error) {
        var _this = this;
        var image = this.images[fileName];
        if (image) {
            if (success) {
                success(image);
            }
            return;
        }
        // load file
        var uri = this._getUri(fileName);
        if (!uri) {
            throw new Error("Unknown image file " + fileName);
        }
        image = new Image();
        if (uri.indexOf("data:") !== 0) {
            // add cross origin attribute for
            // remote images
            image.crossOrigin = "anonymous";
        }
        image.onload = function () {
            delete _this.waitImages[fileName];
            _this.images[fileName] = image;
            if (success) {
                success(image);
            }
            _this._loadEnd();
        };
        if (error) {
            image.onerror = function () {
                delete _this.waitImages[fileName];
                if (error()) {
                    // then we treat this load as complete
                    // and handled properly
                    _this._loadEnd();
                }
            };
        }
        this._loadStart();
        image.src = uri;
        this.waitImages[fileName] = image;
    };
    ResourceManager.prototype.setAttribute = function (key, value, options) {
        if (key === "uris") {
            this.uris = value;
            return true;
        }
        return false;
    };
    ResourceManager.prototype._getUri = function (fileName) {
        var uri = this.uris[fileName];
        if (uri) {
            return uri;
        }
        for (var i = this.packs.length - 1; i >= 0; i--) {
            var pack = this.packs[i];
            if (pack.fileNames.indexOf(fileName) !== -1) {
                return pack.prefix + fileName;
            }
        }
    };
    ResourceManager.prototype._loadStart = function () {
        this.waitCount++;
        if (this.waitCount === 1) {
            this.ready = false;
            this.emit("wait");
        }
    };
    ResourceManager.prototype._loadEnd = function () {
        this.waitCount--;
        if (this.waitCount === 0) {
            this.ready = true;
            this.emit("ready");
        }
    };
    return ResourceManager;
}(Model_1["default"]));
exports["default"] = ResourceManager;


/***/ }),
/* 283 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayMap_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIteratee_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__basePickBy_js__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__getAllKeysIn_js__ = __webpack_require__(66);





/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 */
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = Object(__WEBPACK_IMPORTED_MODULE_0__arrayMap_js__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_3__getAllKeysIn_js__["a" /* default */])(object), function(prop) {
    return [prop];
  });
  predicate = Object(__WEBPACK_IMPORTED_MODULE_1__baseIteratee_js__["a" /* default */])(predicate);
  return Object(__WEBPACK_IMPORTED_MODULE_2__basePickBy_js__["a" /* default */])(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}

/* harmony default export */ __webpack_exports__["default"] = (pickBy);


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var flatMap_1 = __webpack_require__(285);
var Component_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(0);
var ShaderProgram_1 = __webpack_require__(3);
/**
 * Channel shift mode for [[ChannelShift]] component
 */
var ChannelShiftMode;
(function (ChannelShiftMode) {
    ChannelShiftMode[ChannelShiftMode["RGB"] = 0] = "RGB";
    ChannelShiftMode[ChannelShiftMode["RBG"] = 1] = "RBG";
    ChannelShiftMode[ChannelShiftMode["BRG"] = 2] = "BRG";
    ChannelShiftMode[ChannelShiftMode["BGR"] = 3] = "BGR";
    ChannelShiftMode[ChannelShiftMode["GBR"] = 4] = "GBR";
    ChannelShiftMode[ChannelShiftMode["GRB"] = 5] = "GRB";
})(ChannelShiftMode || (ChannelShiftMode = {}));
var ShiftChannelsKeys = Object.keys(ChannelShiftMode).filter(function (s) { return isNaN(parseInt(s, 10)); });
/**
 * A component that swizzles the color component
 */
var ChannelShift = /** @class */ (function (_super) {
    __extends(ChannelShift, _super);
    function ChannelShift(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    ChannelShift.prototype.init = function () {
        this.program = new ShaderProgram_1["default"](this.main.getRctx(), {
            bindings: {
                uniforms: {
                    channel: { name: "u_channel", valueType: utils_1.WebGLVarType._1I }
                }
            },
            fragmentShader: "\n                uniform int u_channel;\n                void main() {\n                    vec3 color = getSrcColor().rgb;\n                    " + flatMap_1["default"](ShiftChannelsKeys, function (channel) { return "\n                            if(u_channel == " + ChannelShiftMode[channel] + ") {\n                                setFragColor(vec4(color." + channel.toLowerCase() + ", 1));\n                            }\n                        "; }).join("\n") + "\n                }\n            ",
            swapFrame: true
        });
        this.updateChannel();
    };
    ChannelShift.prototype.draw = function () {
        if (this.opts.onBeatRandom && this.main.getAnalyser().isBeat()) {
            this.channel = Math.floor(Math.random() * ShiftChannelsKeys.length);
        }
        this.program.run(this.parent.getTSM(), { channel: this.channel });
    };
    ChannelShift.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.program.destroy();
    };
    ChannelShift.prototype.updateChannel = function () {
        this.channel = ChannelShiftMode[this.opts.channel];
    };
    ChannelShift.componentName = "ChannelShift";
    ChannelShift.componentTag = "trans";
    ChannelShift.optUpdateHandlers = {
        channel: "updateChannel"
    };
    ChannelShift.defaultOptions = {
        channel: "RGB",
        onBeatRandom: false
    };
    return ChannelShift;
}(Component_1["default"]));
exports["default"] = ChannelShift;


/***/ }),
/* 285 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFlatten_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__map_js__ = __webpack_require__(13);



/**
 * Creates a flattened array of values by running each element in `collection`
 * thru `iteratee` and flattening the mapped results. The iteratee is invoked
 * with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * function duplicate(n) {
 *   return [n, n];
 * }
 *
 * _.flatMap([1, 2], duplicate);
 * // => [1, 1, 2, 2]
 */
function flatMap(collection, iteratee) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__baseFlatten_js__["a" /* default */])(Object(__WEBPACK_IMPORTED_MODULE_1__map_js__["default"])(collection, iteratee), 1);
}

/* harmony default export */ __webpack_exports__["default"] = (flatMap);


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Component_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(0);
var ShaderProgram_1 = __webpack_require__(3);
/**
 * Clipping moder for the [[ColorClip]] component
 */
var ColorClipMode;
(function (ColorClipMode) {
    ColorClipMode[ColorClipMode["BELOW"] = 0] = "BELOW";
    ColorClipMode[ColorClipMode["ABOVE"] = 1] = "ABOVE";
    ColorClipMode[ColorClipMode["NEAR"] = 2] = "NEAR";
})(ColorClipMode || (ColorClipMode = {}));
/**
 * A component that clips colors to a different color depending
 * on whether the source colors are above or below a reference color.
 */
var ColorClip = /** @class */ (function (_super) {
    __extends(ColorClip, _super);
    function ColorClip(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    ColorClip.prototype.init = function () {
        this.program = new ShaderProgram_1["default"](this.main.getRctx(), {
            bindings: {
                uniforms: {
                    color: { name: "u_color", valueType: utils_1.WebGLVarType._3FV },
                    level: { name: "u_level", valueType: utils_1.WebGLVarType._1F },
                    mode: { name: "u_mode", valueType: utils_1.WebGLVarType._1I },
                    outColor: { name: "u_outColor", valueType: utils_1.WebGLVarType._3FV }
                }
            },
            fragmentShader: "\n                uniform int u_mode;\n                uniform vec3 u_color;\n                uniform vec3 u_outColor;\n                uniform float u_level;\n\n                void main() {\n                   vec4 inColor4 = getSrcColor();\n                   vec3 inColor = inColor4.rgb;\n                   bool clip = false;\n                   if(u_mode == 0) {\n                        clip = all(lessThanEqual(inColor, u_color));\n                   }\n                   if(u_mode == 1) {\n                        clip = all(greaterThanEqual(inColor, u_color));\n                   }\n                   if(u_mode == 2) {\n                        clip = (distance(inColor, u_color) <= u_level*0.5);\n                   }\n                   if(clip) {\n                       setFragColor(vec4(u_outColor, inColor4.a));\n                   } else {\n                       setFragColor(inColor4);\n                   }\n                }\n            ",
            swapFrame: true
        });
        this.updateColor();
        this.updateMode();
    };
    ColorClip.prototype.draw = function () {
        this.program.run(this.parent.getTSM(), {
            color: this.color,
            level: this.opts.level,
            mode: this.mode,
            outColor: this.outColor
        });
    };
    ColorClip.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.program.destroy();
    };
    ColorClip.prototype.updateMode = function () {
        this.mode = ColorClipMode[this.opts.mode];
    };
    ColorClip.prototype.updateColor = function () {
        this.color = utils_1.parseColorNorm(this.opts.color);
        this.outColor = utils_1.parseColorNorm(this.opts.outColor);
    };
    ColorClip.componentName = "ColorClip";
    ColorClip.componentTag = "trans";
    ColorClip.optUpdateHandlers = {
        color: "updateColor",
        mode: "updateMode",
        outColor: "updateColor"
    };
    ColorClip.defaultOptions = {
        color: "#202020",
        level: 0,
        mode: "BELOW",
        outColor: "#202020"
    };
    return ColorClip;
}(Component_1["default"]));
exports["default"] = ColorClip;


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var each_1 = __webpack_require__(12);
var filter_1 = __webpack_require__(112);
var first_1 = __webpack_require__(288);
var last_1 = __webpack_require__(111);
var map_1 = __webpack_require__(13);
var sortBy_1 = __webpack_require__(290);
var take_1 = __webpack_require__(137);
var takeRight_1 = __webpack_require__(83);
var times_1 = __webpack_require__(138);
var uniq_1 = __webpack_require__(134);
var zip_1 = __webpack_require__(295);
var Component_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(0);
var ShaderProgram_1 = __webpack_require__(3);
/**
 * Color mapping key for [[ColorMap]] component
 */
var ColorMapKey;
(function (ColorMapKey) {
    ColorMapKey[ColorMapKey["RED"] = 0] = "RED";
    ColorMapKey[ColorMapKey["GREEN"] = 1] = "GREEN";
    ColorMapKey[ColorMapKey["BLUE"] = 2] = "BLUE";
    ColorMapKey[ColorMapKey["(R+G+B)/2"] = 3] = "(R+G+B)/2";
    ColorMapKey[ColorMapKey["(R+G+B)/3"] = 4] = "(R+G+B)/3";
    ColorMapKey[ColorMapKey["MAX"] = 5] = "MAX";
})(ColorMapKey || (ColorMapKey = {}));
/**
 * Color map cycling modes for [[ColorMap]] component
 */
var ColorMapCycleMode;
(function (ColorMapCycleMode) {
    ColorMapCycleMode[ColorMapCycleMode["SINGLE"] = 0] = "SINGLE";
    ColorMapCycleMode[ColorMapCycleMode["ONBEATRANDOM"] = 1] = "ONBEATRANDOM";
    ColorMapCycleMode[ColorMapCycleMode["ONBEATSEQUENTIAL"] = 2] = "ONBEATSEQUENTIAL";
})(ColorMapCycleMode || (ColorMapCycleMode = {}));
/**
 * A component that changes colors according to a gradient map using
 * a key generated from the source colors
 */
var ColorMap = /** @class */ (function (_super) {
    __extends(ColorMap, _super);
    function ColorMap(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    ColorMap.prototype.init = function () {
        this.program = new ShaderProgram_1["default"](this.main.getRctx(), {
            bindings: {
                uniforms: {
                    colorMap: { name: "u_colorMap", valueType: utils_1.WebGLVarType.TEXTURE2D },
                    key: { name: "u_key", valueType: utils_1.WebGLVarType._1I }
                }
            },
            dynamicBlend: true,
            fragmentShader: "\n                uniform int u_key;\n                uniform sampler2D u_colorMap;\n                void main() {\n                   vec4 srcColor = getSrcColor();\n                   float key;\n                   if(u_key == " + ColorMapKey.RED + "          ) { key = srcColor.r; }\n                   if(u_key == " + ColorMapKey.GREEN + "        ) { key = srcColor.g; }\n                   if(u_key == " + ColorMapKey.BLUE + "         ) { key = srcColor.b; }\n                   if(u_key == " + ColorMapKey["(R+G+B)/2"] + " ) { key = min((srcColor.r+srcColor.g+srcColor.b)/2.0, 1.0); }\n                   if(u_key == " + ColorMapKey["(R+G+B)/3"] + " ) { key = (srcColor.r+srcColor.g+srcColor.b)/3.0; }\n                   if(u_key == " + ColorMapKey.MAX + "          ) { key = max(srcColor.r, max(srcColor.g, srcColor.b)); }\n                   setFragColor(texture2D(u_colorMap, vec2(key, 0)));\n                }\n            ",
            swapFrame: true
        });
        this.updateMap();
        this.updateKey();
        this.updateCycleMode();
        this.updateBlendMode();
    };
    ColorMap.prototype.draw = function () {
        if (this.main.getAnalyser().isBeat()) {
            if (this.mapCycleMode === ColorMapCycleMode.ONBEATRANDOM) {
                this.currentMap = Math.floor(Math.random() * this.opts.maps.length);
            }
            else if (this.mapCycleMode === ColorMapCycleMode.ONBEATSEQUENTIAL) {
                this.currentMap = (this.currentMap + 1) % this.colorMaps.length;
            }
        }
        this.program.run(this.parent.getTSM(), {
            colorMap: this.colorMaps[this.currentMap],
            key: this.key
        }, this.blendMode);
    };
    ColorMap.prototype.destroy = function () {
        var _this = this;
        _super.prototype.destroy.call(this);
        this.program.destroy();
        each_1["default"](this.colorMaps, function (tex) {
            _this.main.getRctx().getGl().deleteTexture(tex);
        });
    };
    ColorMap.prototype.updateMap = function () {
        var _this = this;
        if (this.colorMaps) {
            each_1["default"](this.colorMaps, function (tex) {
                _this.main.getRctx().getGl().deleteTexture(tex);
            });
        }
        this.colorMaps = map_1["default"](filter_1["default"](this.opts.maps, "enabled"), function (colorMap) { return _this._buildColorMap(colorMap.colors); });
        this.currentMap = 0;
    };
    ColorMap.prototype.updateCycleMode = function () {
        this.mapCycleMode = ColorMapCycleMode[this.opts.mapCycleMode];
    };
    ColorMap.prototype.updateKey = function () {
        this.key = ColorMapKey[this.opts.key];
    };
    ColorMap.prototype.updateBlendMode = function () {
        this.blendMode = utils_1.BlendMode[this.opts.output];
    };
    ColorMap.prototype._buildColorMap = function (mapItems) {
        var gl = this.main.getRctx().getGl();
        mapItems = sortBy_1["default"](mapItems, function (mapItem) { return mapItem.position; });
        // check for repeated positions
        var positions = map_1["default"](mapItems, function (mapItem) { return mapItem.position; });
        if (uniq_1["default"](positions).length !== positions.length) {
            throw new Error("map cannot have repeated positions");
        }
        // parse all the colors
        var parsedMap = map_1["default"](mapItems, function (mapItem) {
            var color = utils_1.parseColor(mapItem.color);
            return { color: color, position: mapItem.position };
        });
        // add a cap entries at the ends
        var firstMap = first_1["default"](parsedMap);
        if (firstMap.position !== 0) {
            parsedMap.splice(0, 0, { color: firstMap.color, position: 0 });
        }
        var lastMap = last_1["default"](parsedMap);
        if (lastMap.position !== 255) {
            parsedMap.push({ color: lastMap.color, position: 255 });
        }
        // lerp intermediate values
        var colorMap = new Uint8Array(256 * 3);
        var cmi = 0;
        var pairs = zip_1["default"](take_1["default"](parsedMap, parsedMap.length - 1), takeRight_1["default"](parsedMap, parsedMap.length - 1));
        each_1["default"](pairs, function (pair) {
            var firstItem = pair[0];
            var secondItem = pair[1];
            var steps = secondItem.position - firstItem.position;
            times_1["default"](steps, function (i) {
                colorMap[cmi++] = Math.floor((firstItem.color[0] * (steps - i) + secondItem.color[0] * i) / steps);
                colorMap[cmi++] = Math.floor((firstItem.color[1] * (steps - i) + secondItem.color[1] * i) / steps);
                colorMap[cmi++] = Math.floor((firstItem.color[2] * (steps - i) + secondItem.color[2] * i) / steps);
            });
        });
        colorMap[cmi++] = lastMap.color[0];
        colorMap[cmi++] = lastMap.color[1];
        colorMap[cmi++] = lastMap.color[2];
        // put the color values into a 256x1 texture
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 256, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, colorMap);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        return texture;
    };
    ColorMap.componentName = "ColorMap";
    ColorMap.componentTag = "trans";
    ColorMap.optUpdateHandlers = {
        key: "updateKey",
        mapCycleMode: "updateCycleMode",
        maps: "updateMap",
        output: "updateBlendMode"
    };
    ColorMap.defaultOptions = {
        key: "RED",
        mapCycleMode: "SINGLE",
        maps: [
            {
                enabled: true,
                colors: [
                    { position: 0, color: "#000000" },
                    { position: 255, color: "#FFFFFF" },
                ]
            }
        ],
        output: "REPLACE"
    };
    return ColorMap;
}(Component_1["default"]));
exports["default"] = ColorMap;


/***/ }),
/* 288 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__head_js__ = __webpack_require__(289);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return __WEBPACK_IMPORTED_MODULE_0__head_js__["a"]; });



/***/ }),
/* 289 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */
function head(array) {
  return (array && array.length) ? array[0] : undefined;
}

/* harmony default export */ __webpack_exports__["a"] = (head);


/***/ }),
/* 290 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseFlatten_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseOrderBy_js__ = __webpack_require__(291);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseRest_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__isIterateeCall_js__ = __webpack_require__(70);





/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 */
var sortBy = Object(__WEBPACK_IMPORTED_MODULE_2__baseRest_js__["a" /* default */])(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && Object(__WEBPACK_IMPORTED_MODULE_3__isIterateeCall_js__["a" /* default */])(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && Object(__WEBPACK_IMPORTED_MODULE_3__isIterateeCall_js__["a" /* default */])(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return Object(__WEBPACK_IMPORTED_MODULE_1__baseOrderBy_js__["a" /* default */])(collection, Object(__WEBPACK_IMPORTED_MODULE_0__baseFlatten_js__["a" /* default */])(iteratees, 1), []);
});

/* harmony default export */ __webpack_exports__["default"] = (sortBy);


/***/ }),
/* 291 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayMap_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseIteratee_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseMap_js__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__baseSortBy_js__ = __webpack_require__(292);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__baseUnary_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__compareMultiple_js__ = __webpack_require__(293);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__identity_js__ = __webpack_require__(18);








/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = Object(__WEBPACK_IMPORTED_MODULE_0__arrayMap_js__["a" /* default */])(iteratees.length ? iteratees : [__WEBPACK_IMPORTED_MODULE_6__identity_js__["a" /* default */]], Object(__WEBPACK_IMPORTED_MODULE_4__baseUnary_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__baseIteratee_js__["a" /* default */]));

  var result = Object(__WEBPACK_IMPORTED_MODULE_2__baseMap_js__["a" /* default */])(collection, function(value, key, collection) {
    var criteria = Object(__WEBPACK_IMPORTED_MODULE_0__arrayMap_js__["a" /* default */])(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return Object(__WEBPACK_IMPORTED_MODULE_3__baseSortBy_js__["a" /* default */])(result, function(object, other) {
    return Object(__WEBPACK_IMPORTED_MODULE_5__compareMultiple_js__["a" /* default */])(object, other, orders);
  });
}

/* harmony default export */ __webpack_exports__["a"] = (baseOrderBy);


/***/ }),
/* 292 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

/* harmony default export */ __webpack_exports__["a"] = (baseSortBy);


/***/ }),
/* 293 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__compareAscending_js__ = __webpack_require__(294);


/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = Object(__WEBPACK_IMPORTED_MODULE_0__compareAscending_js__["a" /* default */])(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

/* harmony default export */ __webpack_exports__["a"] = (compareMultiple);


/***/ }),
/* 294 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__isSymbol_js__ = __webpack_require__(25);


/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = Object(__WEBPACK_IMPORTED_MODULE_0__isSymbol_js__["a" /* default */])(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = Object(__WEBPACK_IMPORTED_MODULE_0__isSymbol_js__["a" /* default */])(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

/* harmony default export */ __webpack_exports__["a"] = (compareAscending);


/***/ }),
/* 295 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__baseRest_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__unzip_js__ = __webpack_require__(296);



/**
 * Creates an array of grouped elements, the first of which contains the
 * first elements of the given arrays, the second of which contains the
 * second elements of the given arrays, and so on.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to process.
 * @returns {Array} Returns the new array of grouped elements.
 * @example
 *
 * _.zip(['a', 'b'], [1, 2], [true, false]);
 * // => [['a', 1, true], ['b', 2, false]]
 */
var zip = Object(__WEBPACK_IMPORTED_MODULE_0__baseRest_js__["a" /* default */])(__WEBPACK_IMPORTED_MODULE_1__unzip_js__["a" /* default */]);

/* harmony default export */ __webpack_exports__["default"] = (zip);


/***/ }),
/* 296 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayFilter_js__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__arrayMap_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseProperty_js__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__baseTimes_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__isArrayLikeObject_js__ = __webpack_require__(44);






/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.zip` except that it accepts an array of grouped
 * elements and creates an array regrouping the elements to their pre-zip
 * configuration.
 *
 * @static
 * @memberOf _
 * @since 1.2.0
 * @category Array
 * @param {Array} array The array of grouped elements to process.
 * @returns {Array} Returns the new array of regrouped elements.
 * @example
 *
 * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
 * // => [['a', 1, true], ['b', 2, false]]
 *
 * _.unzip(zipped);
 * // => [['a', 'b'], [1, 2], [true, false]]
 */
function unzip(array) {
  if (!(array && array.length)) {
    return [];
  }
  var length = 0;
  array = Object(__WEBPACK_IMPORTED_MODULE_0__arrayFilter_js__["a" /* default */])(array, function(group) {
    if (Object(__WEBPACK_IMPORTED_MODULE_4__isArrayLikeObject_js__["a" /* default */])(group)) {
      length = nativeMax(group.length, length);
      return true;
    }
  });
  return Object(__WEBPACK_IMPORTED_MODULE_3__baseTimes_js__["a" /* default */])(length, function(index) {
    return Object(__WEBPACK_IMPORTED_MODULE_1__arrayMap_js__["a" /* default */])(array, Object(__WEBPACK_IMPORTED_MODULE_2__baseProperty_js__["a" /* default */])(index));
  });
}

/* harmony default export */ __webpack_exports__["a"] = (unzip);


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var isArray_1 = __webpack_require__(1);
var reduce_1 = __webpack_require__(298);
var Component_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(0);
var ShaderProgram_1 = __webpack_require__(3);
/**
 * Edge handling modes for [[Convolution]] component
 */
var ConvEdgeMode;
(function (ConvEdgeMode) {
    /**
     * Extend edge value beyond edge
     */
    ConvEdgeMode[ConvEdgeMode["EXTEND"] = 0] = "EXTEND";
    /**
     * Wrap around to opposite edge
     */
    ConvEdgeMode[ConvEdgeMode["WRAP"] = 1] = "WRAP";
})(ConvEdgeMode || (ConvEdgeMode = {}));
/**
 * A component that applies a convolution kernel
 */
var Convolution = /** @class */ (function (_super) {
    __extends(Convolution, _super);
    function Convolution(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    Convolution.prototype.init = function () {
        this.updateProgram();
        this.updateScale();
    };
    Convolution.prototype.draw = function () {
        this.program.run(this.parent.getTSM(), { scale: this.scale, bias: this.opts.bias });
    };
    Convolution.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.program.destroy();
    };
    Convolution.prototype.updateScale = function () {
        var opts = this.opts;
        if (opts.autoScale) {
            this.scale = reduce_1["default"](opts.kernel, function (memo, num) { return memo + num; }, 0);
        }
        else {
            this.scale = opts.scale;
        }
    };
    Convolution.prototype.updateProgram = function () {
        var opts = this.opts;
        if (!isArray_1["default"](opts.kernel) || opts.kernel.length % 2 !== 1) {
            throw new Error("Invalid convolution kernel");
        }
        var kernelSize = Math.floor(Math.sqrt(opts.kernel.length));
        if (kernelSize * kernelSize !== opts.kernel.length) {
            throw new Error("Invalid convolution kernel");
        }
        var edgeMode = ConvEdgeMode[this.opts.edgeMode];
        // generate edge correction function
        var edgeFunc = "";
        switch (edgeMode) {
            case ConvEdgeMode.WRAP:
                edgeFunc = "pos = vec2(pos.x<0?pos.x+1.0:pos.x%1, pos.y<0?pos.y+1.0:pos.y%1);";
                break;
            case ConvEdgeMode.EXTEND:
                edgeFunc = "pos = clamp(pos, vec2(0,0), vec2(1,1));";
                break;
        }
        // generate kernel multiplication code
        var colorSumEq = [];
        var mid = Math.floor(kernelSize / 2);
        for (var i = 0; i < kernelSize; i++) {
            for (var j = 0; j < kernelSize; j++) {
                var value = opts.kernel[(i * kernelSize + j)];
                if (value === 0) {
                    continue;
                }
                colorSumEq.push("pos = v_position + texel * vec2(" + (j - mid) + "," + (mid - i) + ");");
                colorSumEq.push(edgeFunc);
                colorSumEq.push("colorSum += texture2D(u_srcTexture, pos) * " + utils_1.glslFloatRepr(value) + ";");
            }
        }
        var program = new ShaderProgram_1["default"](this.main.getRctx(), {
            bindings: {
                uniforms: {
                    bias: { name: "u_bias", valueType: utils_1.WebGLVarType._1F },
                    scale: { name: "u_scale", valueType: utils_1.WebGLVarType._1F }
                }
            },
            fragmentShader: "\n                uniform float u_scale;\n                uniform float u_bias;\n                void main() {\n                   vec2 texel = 1.0/(u_resolution-vec2(1,1));\n                   vec2 pos;\n                   vec4 colorSum = vec4(0,0,0,0);\n                   " + colorSumEq.join("\n") + "\n                   setFragColor(vec4(((colorSum+u_bias)/u_scale).rgb, 1.0));\n                }\n            ",
            swapFrame: true
        });
        if (this.program) {
            this.program.destroy();
        }
        this.program = program;
    };
    Convolution.componentName = "Convolution";
    Convolution.componentTag = "trans";
    Convolution.optUpdateHandlers = {
        edgeMode: "updateProgram",
        kernel: ["updateProgram", "updateScale"],
        scale: "updateScale"
    };
    Convolution.defaultOptions = {
        autoScale: true,
        bias: 0,
        edgeMode: "EXTEND",
        kernel: [
            0, 0, 0,
            0, 1, 0,
            0, 0, 0,
        ],
        scale: 0
    };
    return Convolution;
}(Component_1["default"]));
exports["default"] = Convolution;


/***/ }),
/* 298 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__arrayReduce_js__ = __webpack_require__(299);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__baseEach_js__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__baseIteratee_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__baseReduce_js__ = __webpack_require__(300);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__isArray_js__ = __webpack_require__(1);






/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
  var func = Object(__WEBPACK_IMPORTED_MODULE_4__isArray_js__["default"])(collection) ? __WEBPACK_IMPORTED_MODULE_0__arrayReduce_js__["a" /* default */] : __WEBPACK_IMPORTED_MODULE_3__baseReduce_js__["a" /* default */],
      initAccum = arguments.length < 3;

  return func(collection, Object(__WEBPACK_IMPORTED_MODULE_2__baseIteratee_js__["a" /* default */])(iteratee, 4), accumulator, initAccum, __WEBPACK_IMPORTED_MODULE_1__baseEach_js__["a" /* default */]);
}

/* harmony default export */ __webpack_exports__["default"] = (reduce);


/***/ }),
/* 299 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/* harmony default export */ __webpack_exports__["a"] = (arrayReduce);


/***/ }),
/* 300 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

/* harmony default export */ __webpack_exports__["a"] = (baseReduce);


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Component_1 = __webpack_require__(2);
var compileExpr_1 = __webpack_require__(28);
var utils_1 = __webpack_require__(0);
var Buffer_1 = __webpack_require__(29);
var ShaderProgram_1 = __webpack_require__(3);
/**
 * Coordinate Movement coordinate modes
 */
var DynamicMovementCoordMode;
(function (DynamicMovementCoordMode) {
    DynamicMovementCoordMode[DynamicMovementCoordMode["POLAR"] = 0] = "POLAR";
    DynamicMovementCoordMode[DynamicMovementCoordMode["RECT"] = 1] = "RECT";
})(DynamicMovementCoordMode || (DynamicMovementCoordMode = {}));
/**
 * A component that moves pixels according to user code
 */
var DynamicMovement = /** @class */ (function (_super) {
    __extends(DynamicMovement, _super);
    function DynamicMovement(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    DynamicMovement.prototype.init = function () {
        var _this = this;
        this.updateCode();
        this.updateGrid();
        this.listenTo(this.main, "resize", function () { return _this.handleResize(); });
    };
    DynamicMovement.prototype.draw = function () {
        var code = this.code;
        // run init, if required
        if (!this.inited) {
            code.init();
            this.inited = true;
        }
        var beat = this.main.getAnalyser().isBeat();
        code.b = beat ? 1 : 0;
        // run per frame
        code.perFrame();
        // run on beat
        if (beat) {
            code.onBeat();
        }
        this.program.run(this.parent.getTSM(), this.opts.noGrid ? {} : { grid: this.gridVertexBuffer });
    };
    DynamicMovement.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.program.destroy();
        if (this.gridVertexBuffer) {
            this.gridVertexBuffer.destroy();
        }
    };
    DynamicMovement.prototype.updateCode = function () {
        var compileResult = compileExpr_1["default"](this.opts.code, ["init", "onBeat", "perFrame"], ["perPixel"], ["x", "y", "d", "r", "b", "alpha"]);
        // js code
        var code = compileResult.codeInst;
        code.setup(this.main);
        this.inited = false;
        this.code = code;
        // glsl code
        this.glslCode = compileResult.glslCode;
        this.updateProgram();
    };
    DynamicMovement.prototype.updateProgram = function () {
        var _this = this;
        var opts = this.opts;
        var coordMode = DynamicMovementCoordMode[this.opts.coord];
        var rctx = this.main.getRctx();
        var programOpts = {
            blendMode: opts.blend ? utils_1.BlendMode.ALPHA : utils_1.BlendMode.REPLACE,
            drawHook: function (values, gl, dmProgram) {
                // bind values from code instance into program
                _this.code.bindUniforms(dmProgram);
                // return true to indicate unhandled draw.
                // This lets ShaderProgram handle draw calls
                return true;
            },
            fragmentShader: "",
            swapFrame: true
        };
        if (opts.noGrid) {
            programOpts.fragmentShader = "\n                " + this.glslCode + "\n                " + glslFilter(opts.bFilter, opts.compat) + "\n                void main() {\n                    " + (this.code.hasRandom ? "__randSeed = v_position;" : "") + "\n                    x = v_position.x*2.0-1.0;\n                    y = -(v_position.y*2.0-1.0);\n                    " + glslRectToPolar(coordMode) + "\n                    alpha=0.5;\n                    perPixel();\n                    " + glslPolarToRect(coordMode) + "\n                    setFragColor(vec4(filter(vec2(x, -y)), " + (opts.blend ? "alpha" : "1.0") + "));\n                }\n            ";
        }
        else {
            programOpts.bindings = {
                attribs: {
                    grid: { name: "a_position", drawMode: rctx.getGl().TRIANGLES }
                }
            };
            programOpts.vertexShader = "\n                attribute vec2 a_position;\n                varying vec2 v_newPoint;\n                varying float v_alpha;\n                " + this.glslCode + "\n                void main() {\n                    " + (this.code.hasRandom ? "__randSeed = a_position;" : "") + "\n                    x = a_position.x;\n                    y = -a_position.y;\n                    " + glslRectToPolar(coordMode) + "\n                    alpha = 0.5;\n                    perPixel();\n                    v_alpha = alpha;\n                    " + glslPolarToRect(coordMode) + "\n                    v_newPoint = vec2(x,-y);\n                    setPosition(a_position);\n                }\n            ";
            programOpts.fragmentShader = "\n                varying vec2 v_newPoint;\n                varying float v_alpha;\n                " + glslFilter(opts.bFilter, opts.compat) + "\n                void main() {\n                   setFragColor(vec4(filter(v_newPoint), " + (opts.blend ? "v_alpha" : "1.0") + "));\n                }\n            ";
        }
        var program = new ShaderProgram_1["default"](rctx, programOpts);
        if (this.program) {
            this.program.destroy();
        }
        this.program = program;
    };
    DynamicMovement.prototype.updateGrid = function () {
        var opts = this.opts;
        var gl = this.main.getRctx().getGl();
        if (!opts.noGrid) {
            var gridW = utils_1.clamp(opts.gridW, 1, gl.drawingBufferWidth);
            var gridH = utils_1.clamp(opts.gridH, 1, gl.drawingBufferHeight);
            var nGridW = (gridW / gl.drawingBufferWidth) * 2;
            var nGridH = (gridH / gl.drawingBufferHeight) * 2;
            var gridCountAcross = Math.ceil(gl.drawingBufferWidth / gridW);
            var gridCountDown = Math.ceil(gl.drawingBufferHeight / gridH);
            var gridVertices = new Float32Array(gridCountAcross * gridCountDown * 6 * 2);
            var pbi = 0;
            var curx = -1;
            var cury = -1;
            for (var i = 0; i < gridCountDown; i++) {
                for (var j = 0; j < gridCountAcross; j++) {
                    var cornx = Math.min(curx + nGridW, 1);
                    var corny = Math.min(cury + nGridH, 1);
                    gridVertices[pbi++] = curx;
                    gridVertices[pbi++] = cury;
                    gridVertices[pbi++] = cornx;
                    gridVertices[pbi++] = cury;
                    gridVertices[pbi++] = curx;
                    gridVertices[pbi++] = corny;
                    gridVertices[pbi++] = cornx;
                    gridVertices[pbi++] = cury;
                    gridVertices[pbi++] = cornx;
                    gridVertices[pbi++] = corny;
                    gridVertices[pbi++] = curx;
                    gridVertices[pbi++] = corny;
                    curx += nGridW;
                }
                curx = -1;
                cury += nGridH;
            }
            if (!this.gridVertexBuffer) {
                this.gridVertexBuffer = new Buffer_1["default"](this.main.getRctx());
            }
            this.gridVertexBuffer.setData(gridVertices);
        }
    };
    DynamicMovement.prototype.handleResize = function () {
        this.code.updateDimVars(this.main.getRctx().getGl());
    };
    DynamicMovement.componentName = "DynamicMovement";
    DynamicMovement.componentTag = "trans";
    DynamicMovement.optUpdateHandlers = {
        bFilter: "updateProgram",
        blend: "updateProgram",
        code: "updateCode",
        compat: "updateProgram",
        coord: "updateProgram",
        gridH: "updateGrid",
        gridW: "updateGrid",
        noGrid: [
            "updateProgram",
            "updateGrid",
        ]
    };
    DynamicMovement.defaultOptions = {
        bFilter: true,
        blend: false,
        code: {
            init: "",
            onBeat: "",
            perFrame: "",
            perPixel: ""
        },
        compat: false,
        coord: "POLAR",
        gridH: 16,
        gridW: 16,
        noGrid: false
    };
    return DynamicMovement;
}(Component_1["default"]));
exports["default"] = DynamicMovement;
function glslRectToPolar(coordMode) {
    if (coordMode === DynamicMovementCoordMode.POLAR) {
        return "\n            float ar = u_resolution.x/u_resolution.y;\n            x=x*ar;\n            d = distance(vec2(x, y), vec2(0,0))/sqrt(2.0);\n            r = mod(atan(y, x)+PI*0.5, 2.0*PI);\n        ";
    }
    else {
        return "";
    }
}
function glslPolarToRect(coordMode) {
    if (coordMode === DynamicMovementCoordMode.POLAR) {
        return "\n            d = d*sqrt(2.0);\n            x = d*sin(r)/ar;\n            y = -d*cos(r);\n        ";
    }
    else {
        return "";
    }
}
function glslFilter(bFilter, compat) {
    if (bFilter && !compat) {
        return "\n            vec3 filter(vec2 point) {\n               vec2 texel = 1.0/(u_resolution-vec2(1,1));\n               vec2 coord = (point+1.0)/2.0;\n               vec2 cornoff = fract(coord/texel);\n               vec2 corn = floor(coord/texel)*texel;\n\n               vec3 tl = getSrcColorAtPos(corn).rgb;\n               vec3 tr = getSrcColorAtPos(corn + vec2(texel.x, 0)).rgb;\n               vec3 bl = getSrcColorAtPos(corn + vec2(0, texel.y)).rgb;\n               vec3 br = getSrcColorAtPos(corn + texel).rgb;\n\n               vec3 pt = mix(tl, tr, cornoff.x);\n               vec3 pb = mix(bl, br, cornoff.x);\n               return mix(pt, pb, cornoff.y);\n            }\n        ";
    }
    else if (bFilter && compat) {
        return "\n            vec3 filter(vec2 point) {\n               vec2 texel = 1.0/(u_resolution-vec2(1,1));\n               vec2 coord = (point+1.0)/2.0;\n               vec2 corn = floor(coord/texel)*texel;\n\n               ivec2 cornoff = (ivec2(fract(coord/texel)*255.0));\n\n               ivec3 tl = ivec3(255.0 * getSrcColorAtPos(corn).rgb);\n               ivec3 tr = ivec3(255.0 * getSrcColorAtPos(corn + vec2(texel.x, 0)).rgb);\n               ivec3 bl = ivec3(255.0 * getSrcColorAtPos(corn + vec2(0, texel.y)).rgb);\n               ivec3 br = ivec3(255.0 * getSrcColorAtPos(corn + texel).rgb);\n\n               #define bt(i, j) int((float(i)/255.0)*float(j))\n\n               int a1 = bt(255-cornoff.x,255-cornoff.y);\n               int a2 = bt(cornoff.x    ,255-cornoff.y);\n               int a3 = bt(255-cornoff.x,cornoff.y);\n               int a4 = bt(cornoff.x    ,cornoff.y);\n               float r = float(bt(a1,tl.r) + bt(a2,tr.r) + bt(a3,bl.r) + bt(a4,br.r))/255.0;\n               float g = float(bt(a1,tl.g) + bt(a2,tr.g) + bt(a3,bl.g) + bt(a4,br.g))/255.0;\n               float b = float(bt(a1,tl.b) + bt(a2,tr.b) + bt(a3,bl.b) + bt(a4,br.b))/255.0;\n               return vec3(r,g,b);\n            }\n        ";
    }
    else {
        return "\n            vec3 filter(vec2 point) {\n               return getSrcColorAtPos((point+1.0)/2.0).rgb;\n            }\n        ";
    }
}


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Component_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(0);
var ClearScreenProgram_1 = __webpack_require__(140);
// A component that slowly fades the screen to a specified color
var FadeOut = /** @class */ (function (_super) {
    __extends(FadeOut, _super);
    function FadeOut(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    FadeOut.prototype.init = function () {
        this.program = new ClearScreenProgram_1["default"](this.main.getRctx(), utils_1.BlendMode.AVERAGE);
        this.updateSpeed();
        this.updateColor();
    };
    FadeOut.prototype.draw = function () {
        this.frameCount++;
        if (this.frameCount === this.maxFrameCount) {
            this.frameCount = 0;
            this.program.run(this.parent.getTSM(), { color: this.color });
        }
    };
    FadeOut.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.program.destroy();
    };
    FadeOut.prototype.updateSpeed = function () {
        this.frameCount = 0;
        this.maxFrameCount = Math.floor(1 / this.opts.speed);
    };
    FadeOut.prototype.updateColor = function () {
        this.color = utils_1.parseColorNorm(this.opts.color);
    };
    FadeOut.componentName = "FadeOut";
    FadeOut.componentTag = "trans";
    FadeOut.optUpdateHandlers = {
        color: "updateColor",
        speed: "updateSpeed"
    };
    FadeOut.defaultOptions = {
        color: "#000000",
        speed: 1
    };
    return FadeOut;
}(Component_1["default"]));
exports["default"] = FadeOut;


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Component_1 = __webpack_require__(2);
var ShaderProgram_1 = __webpack_require__(3);
var Invert = /** @class */ (function (_super) {
    __extends(Invert, _super);
    function Invert(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    Invert.prototype.init = function () {
        this.program = new ShaderProgram_1["default"](this.main.getRctx(), {
            fragmentShader: "\n                void main() {\n                   setFragColor(vec4(1,1,1,1)-getSrcColor());\n                }\n            ",
            swapFrame: true
        });
    };
    Invert.prototype.draw = function () {
        this.program.run(this.parent.getTSM(), null);
    };
    Invert.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.program.destroy();
    };
    Invert.componentName = "Invert";
    Invert.componentTag = "trans";
    return Invert;
}(Component_1["default"]));
exports["default"] = Invert;


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Component_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(0);
var ShaderProgram_1 = __webpack_require__(3);
// A component that mirror between quandrants
var Mirror = /** @class */ (function (_super) {
    __extends(Mirror, _super);
    function Mirror(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    Mirror.prototype._setMix = function (noTransition) {
        if (this.opts.smoothTransition && !noTransition) {
            // set mix vectors to second format if we are not already
            // in the middle of a transition
            if (this.animFrameCount === 0) {
                for (var i = 0; i < 4; i++) {
                    var quad = this.mix[i][0];
                    this.mix[i][0] = 0;
                    this.mix[i][quad] = 1;
                }
            }
            // calculate the mix delta values
            for (var i = 0; i < 4; i++) {
                for (var j = 0; j < 4; j++) {
                    var endValue = (j === this.map[i]) ? 1 : 0;
                    this.mixDelta[i][j] = (endValue - this.mix[i][j]) / this.opts.transitionDuration;
                }
            }
            this.animFrameCount = this.opts.transitionDuration;
        }
        else {
            // set mix value to first format
            for (var i = 0; i < 4; i++) {
                this.mix[i][0] = this.map[i];
                for (var j = 1; j < 4; j++) {
                    this.mix[i][j] = 0;
                }
            }
        }
    };
    Mirror.prototype.init = function () {
        this.program = new ShaderProgram_1["default"](this.main.getRctx(), {
            bindings: {
                uniforms: {
                    mix0: { name: "u_mix0", valueType: utils_1.WebGLVarType._4FV },
                    mix1: { name: "u_mix1", valueType: utils_1.WebGLVarType._4FV },
                    mix2: { name: "u_mix2", valueType: utils_1.WebGLVarType._4FV },
                    mix3: { name: "u_mix3", valueType: utils_1.WebGLVarType._4FV },
                    transition: { name: "u_mode", valueType: utils_1.WebGLVarType._1I }
                }
            },
            fragmentShader: "\n                uniform int u_mode;\n                uniform vec4 u_mix0;\n                uniform vec4 u_mix1;\n                uniform vec4 u_mix2;\n                uniform vec4 u_mix3;\n\n                #define getQuadrant(pos) ( (pos.x<0.5) ? (pos.y<0.5?2:0) : (pos.y<0.5?3:1) )\n                #define check(a,b, c,d,e,f) ( ((a==c || a==d) && (b==e || b==f)) || ((a==e || a==f) && (b==c || b==d)) )\n                #define xFlip(qa, qb) (check(qa,qb, 0,2, 1,3)?-1:1)\n                #define yFlip(qa, qb) (check(qa,qb, 0,1, 2,3)?-1:1)\n                #define mirrorPos(pos,qa,qb) ((pos-vec2(0.5,0.5))*vec2(xFlip(qa,qb),yFlip(qa,qb))+vec2(0.5,0.5))\n                #define getMirrorColor(pos,qa,qb) (getSrcColorAtPos(mirrorPos(pos,qa,qb)))\n\n                void main() {\n                    int quadrant = getQuadrant(v_position);\n                    vec4 mix;\n                    if(quadrant == 0)      { mix = u_mix0; }\n                    else if(quadrant == 1) { mix = u_mix1; }\n                    else if(quadrant == 2) { mix = u_mix2; }\n                    else if(quadrant == 3) { mix = u_mix3; }\n                    if(u_mode == 0) {\n                        int otherQuadrant = int(mix.x);\n                        setFragColor(getMirrorColor(v_position, quadrant, otherQuadrant));\n                    } else {\n                        vec4 c0 = getMirrorColor(v_position, quadrant, 0);\n                        vec4 c1 = getMirrorColor(v_position, quadrant, 1);\n                        vec4 c2 = getMirrorColor(v_position, quadrant, 2);\n                        vec4 c3 = getMirrorColor(v_position, quadrant, 3);\n\n                        setFragColor(vec4(\n                            dot(vec4(c0.r,c1.r,c2.r,c3.r), mix),\n                            dot(vec4(c0.g,c1.g,c2.g,c3.g), mix),\n                            dot(vec4(c0.b,c1.b,c2.b,c3.b), mix),\n                            1.0\n                        ));\n                    }\n                }\n            ",
            swapFrame: true
        });
        this.animFrameCount = 0;
        this.mix = [
            [0, 0, 0, 0],
            [1, 0, 0, 0],
            [2, 0, 0, 0],
            [3, 0, 0, 0],
        ];
        this.mixDelta = [
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0],
        ];
        this.updateMap();
    };
    Mirror.prototype.draw = function () {
        if (this.opts.onBeatRandom && this.main.getAnalyser().isBeat()) {
            this._setQuadrantMap(true);
        }
        this.program.run(this.parent.getTSM(), {
            mix0: this.mix[0],
            mix1: this.mix[1],
            mix2: this.mix[2],
            mix3: this.mix[3],
            transition: this._inTransition() ? 1 : 0
        });
        if (this._inTransition()) {
            this.animFrameCount--;
            if (this.animFrameCount === 0) {
                this._setMix(true);
            }
            else {
                for (var i = 0; i < 4; i++) {
                    for (var j = 0; j < 4; j++) {
                        this.mix[i][j] += this.mixDelta[i][j];
                    }
                }
            }
        }
    };
    Mirror.prototype.updateMap = function () {
        this._setQuadrantMap();
    };
    Mirror.prototype._inTransition = function () {
        return (this.opts.smoothTransition && this.animFrameCount !== 0);
    };
    Mirror.prototype._setQuadrantMap = function (random) {
        if (random === void 0) { random = false; }
        var map = [0, 1, 2, 3];
        var mirrorDirs = this.opts;
        if (random) {
            var randVal = Math.floor(Math.random() * 16);
            mirrorDirs = {
                bottomToTop: (randVal & 2) && this.opts.bottomToTop,
                leftToRight: (randVal & 4) && this.opts.leftToRight,
                rightToLeft: (randVal & 8) && this.opts.rightToLeft,
                topToBottom: (randVal & 1) && this.opts.topToBottom
            };
        }
        if (mirrorDirs.topToBottom) {
            map[2] = map[0];
            map[3] = map[1];
        }
        if (mirrorDirs.bottomToTop) {
            map[0] = map[2];
            map[1] = map[3];
        }
        if (mirrorDirs.leftToRight) {
            map[1] = map[0];
            map[3] = map[2];
        }
        if (mirrorDirs.rightToLeft) {
            map[0] = map[1];
            map[2] = map[3];
        }
        this.map = map;
        this._setMix(false);
    };
    Mirror.componentName = "Mirror";
    Mirror.componentTag = "trans";
    Mirror.optUpdateHandlers = {
        bottomToTop: "updateMap",
        leftToRight: "updateMap",
        rightToLeft: "updateMap",
        topToBottom: "updateMap"
    };
    Mirror.defaultOptions = {
        bottomToTop: false,
        leftToRight: false,
        onBeatRandom: false,
        rightToLeft: false,
        smoothTransition: false,
        topToBottom: true,
        transitionDuration: 4
    };
    return Mirror;
}(Component_1["default"]));
exports["default"] = Mirror;


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Component_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(0);
var ShaderProgram_1 = __webpack_require__(3);
var Mosaic = /** @class */ (function (_super) {
    __extends(Mosaic, _super);
    function Mosaic(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    Mosaic.prototype.init = function () {
        this.frameCount = 0;
        this.size = this.opts.squareSize;
        this.updateProgram();
    };
    Mosaic.prototype.draw = function () {
        var gl = this.main.getRctx().getGl();
        if (this.opts.onBeatSizeChange && this.main.getAnalyser().isBeat()) {
            this.size = this.opts.onBeatSquareSize;
            this.frameCount = this.opts.onBeatSizeDuration;
        }
        if (this.size !== 0) {
            var sizeX = 1 / Math.floor(this.size * (gl.drawingBufferWidth - 1) + 1);
            var sizeY = 1 / Math.floor(this.size * (gl.drawingBufferHeight - 1) + 1);
            this.program.run(this.parent.getTSM(), { size: [sizeX, sizeY] });
        }
        if (this.frameCount > 0) {
            this.frameCount--;
            if (this.frameCount === 0) {
                this.size = this.opts.squareSize;
            }
            else {
                var incr = Math.abs(this.opts.squareSize - this.opts.onBeatSquareSize) /
                    this.opts.onBeatSizeDuration;
                this.size += incr * (this.opts.onBeatSquareSize > this.opts.squareSize ? -1 : 1);
            }
        }
    };
    Mosaic.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.program.destroy();
    };
    Mosaic.prototype.updateProgram = function () {
        var blendMode = utils_1.BlendMode[this.opts.blendMode];
        var program = new ShaderProgram_1["default"](this.main.getRctx(), {
            bindings: {
                uniforms: {
                    size: { name: "u_size", valueType: utils_1.WebGLVarType._2FV }
                }
            },
            blendMode: blendMode,
            fragmentShader: "\n                uniform vec2 u_size;\n                void main() {\n                    vec2 samplePos = u_size * ( floor(v_position/u_size) + vec2(0.5,0.5) );\n                    setFragColor(getSrcColorAtPos(samplePos));\n                }\n            ",
            swapFrame: true
        });
        if (this.program) {
            this.program.destroy();
        }
        this.program = program;
    };
    Mosaic.componentName = "Mosaic";
    Mosaic.componentTag = "trans";
    Mosaic.defaultOptions = {
        blendMode: "REPLACE",
        onBeatSizeChange: false,
        onBeatSizeDuration: 10,
        onBeatSquareSize: 1,
        squareSize: 0.5
    };
    Mosaic.optUpdateHandlers = {
        blendMode: "updateProgram"
    };
    return Mosaic;
}(Component_1["default"]));
exports["default"] = Mosaic;


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var Component_1 = __webpack_require__(2);
var utils_1 = __webpack_require__(0);
var ShaderProgram_1 = __webpack_require__(3);
// A Component that applies a unique color tone
var UniqueTone = /** @class */ (function (_super) {
    __extends(UniqueTone, _super);
    function UniqueTone(main, parent, opts) {
        return _super.call(this, main, parent, opts) || this;
    }
    UniqueTone.prototype.init = function () {
        this.updateColor();
        this.updateProgram();
    };
    UniqueTone.prototype.draw = function () {
        this.program.run(this.parent.getTSM(), {
            invert: this.opts.invert ? 1 : 0,
            tone: this.tone
        });
    };
    UniqueTone.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.program.destroy();
    };
    UniqueTone.prototype.updateColor = function () {
        this.tone = utils_1.parseColorNorm(this.opts.color);
    };
    UniqueTone.prototype.updateProgram = function () {
        var blendMode = utils_1.BlendMode[this.opts.blendMode];
        var program = new ShaderProgram_1["default"](this.main.getRctx(), {
            bindings: {
                uniforms: {
                    invert: { name: "u_invert", valueType: utils_1.WebGLVarType._1F },
                    tone: { name: "u_tone", valueType: utils_1.WebGLVarType._3FV }
                }
            },
            blendMode: blendMode,
            fragmentShader: "\n                uniform vec3 u_tone;\n                uniform bool u_invert;\n                void main() {\n                   vec4 srcColor = getSrcColor();\n                   float depth = max(srcColor.r, max(srcColor.g, srcColor.b));\n                   if(u_invert) {\n                       depth = 1.0-depth;\n                   }\n                   setFragColor(vec4(depth*u_tone, 1));\n                }\n            ",
            swapFrame: true
        });
        if (this.program) {
            this.program.destroy();
        }
        this.program = program;
    };
    UniqueTone.componentName = "UniqueTone";
    UniqueTone.componentTag = "trans";
    UniqueTone.defaultOptions = {
        blendMode: "REPLACE",
        color: "#ffffff",
        invert: false
    };
    UniqueTone.optUpdateHandlers = {
        blendMode: "updateProgram",
        color: "updateColor"
    };
    return UniqueTone;
}(Component_1["default"]));
exports["default"] = UniqueTone;


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var utils_1 = __webpack_require__(0);
var ShaderProgram_1 = __webpack_require__(3);
/**
 * A Shader that copies given texture onto current buffer
 */
var CopyProgram = /** @class */ (function (_super) {
    __extends(CopyProgram, _super);
    /**
     * Creates new ClearScreenProgram
     * @param rctx the rendering context in which to create this shader
     * @param dynamicBlend enable or disable dynamicBlend
     */
    function CopyProgram(rctx, dynamicBlend) {
        if (dynamicBlend === void 0) { dynamicBlend = false; }
        return _super.call(this, rctx, {
            bindings: {
                uniforms: {
                    srcTexture: { name: "u_copySource", valueType: utils_1.WebGLVarType.TEXTURE2D }
                }
            },
            dynamicBlend: dynamicBlend,
            fragmentShader: "\n                uniform sampler2D u_copySource;\n                void main() {\n                setFragColor(texture2D(u_copySource, v_position));\n                }\n            "
        }) || this;
    }
    return CopyProgram;
}(ShaderProgram_1["default"]));
exports["default"] = CopyProgram;


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
/**
 * Rendering Context wraps WebGLRenderingContext and
 * a cache for shared Buffers.
 */
var RenderingContext = /** @class */ (function () {
    /**
     * Creates a new RenderingContext
     * @param gl the WebGLRenderingContext to be used
     */
    function RenderingContext(gl) {
        this.gl = gl;
        this.buffers = {};
    }
    /**
     * Returns the WebGLRenderingContext
     */
    RenderingContext.prototype.getGl = function () {
        return this.gl;
    };
    /**
     * Caches given buffer in this context
     * @param name cache key for the buffer
     * @param buffer the buffer to be cached
     */
    RenderingContext.prototype.cacheBuffer = function (name, buffer) {
        this.buffers[name] = buffer;
    };
    /**
     * Returns a buffer that was previously cached with a
     * [[RenderingContext.cacheBuffer]] call
     * @param name cache key
     */
    RenderingContext.prototype.getBuffer = function (name) {
        return this.buffers[name];
    };
    RenderingContext.prototype.destroy = function () {
        for (var bufName in this.buffers) {
            if (!this.buffers.hasOwnProperty(bufName)) {
                continue;
            }
            this.buffers[bufName].destroy();
        }
    };
    return RenderingContext;
}());
exports["default"] = RenderingContext;


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var defaults_1 = __webpack_require__(24);
var utils_1 = __webpack_require__(0);
var AnalyserAdapter_1 = __webpack_require__(141);
/**
 * WebAudioAnalyser is an AnalyserAdapter that supports `audio` tag sources
 */
var WebAudioAnalyser = /** @class */ (function (_super) {
    __extends(WebAudioAnalyser, _super);
    /**
     * Initializes a WebAudioAnalyser
     * @param options options for analyser
     */
    function WebAudioAnalyser(options) {
        var _this = _super.call(this) || this;
        _this.movingThreshold = 0;
        options = defaults_1["default"](options || {}, {
            decay: 0.02,
            fftSize: 512,
            threshold: 0.125
        });
        if (options.context) {
            _this.context = options.context;
        }
        else if (window.webkitAudioContext) {
            _this.context = new window.webkitAudioContext();
        }
        else if (window.AudioContext) {
            _this.context = new window.AudioContext();
        }
        else {
            throw new Error("Cannot create webaudio context");
        }
        _this.fftSize = options.fftSize;
        _this.threshold = options.threshold;
        _this.decay = options.decay;
        _this.visData = [null, null, null];
        for (var ch = 0; ch < 3; ch++) {
            var spectrum = new Float32Array(_this.fftSize / 2);
            var waveform = new Float32Array(_this.fftSize);
            _this.visData[ch] = { spectrum: spectrum, waveform: waveform };
        }
        return _this;
    }
    /**
     * Connect this analyser to any WebAudio Node
     * @param sourceNode node which will be used as audio source
     */
    WebAudioAnalyser.prototype.connectToNode = function (sourceNode) {
        this.source = sourceNode;
        // this gain node simply up/down mixes input source to stereo output
        this.gain = this.context.createGain();
        this.gain.channelCountMode = "explicit";
        this.gain.channelCount = 2;
        this.source.connect(this.gain);
        // split the stereo output into respective mono channels
        this.channelSplit = this.context.createChannelSplitter(2);
        this.gain.connect(this.channelSplit);
        // analser node for each channel
        this.analysers = [null, null];
        for (var ch = 0; ch < 2; ch++) {
            var analyser = this.context.createAnalyser();
            analyser.fftSize = this.fftSize;
            this.channelSplit.connect(analyser, ch);
            this.analysers[ch] = analyser;
        }
    };
    // Called every frame. Override and implement analyser code
    WebAudioAnalyser.prototype.update = function () {
        if (!this.analysers) {
            return; // analysers not ready. nothing update
        }
        var byteBuffer = new Uint8Array(this.fftSize);
        for (var ch = 0; ch < 2; ch++) {
            var visData = this.visData[ch + 1];
            var analyser = this.analysers[ch];
            analyser.getByteFrequencyData(byteBuffer);
            for (var i = 0; i < visData.spectrum.length; i++) {
                visData.spectrum[i] = byteBuffer[i] / 255;
            }
            analyser.getByteTimeDomainData(byteBuffer);
            for (var i = 0; i < visData.waveform.length; i++) {
                visData.waveform[i] = (byteBuffer[i] / 255) * 2 - 1;
            }
        }
        // center channel is average of left and right
        var centerVisData = this.visData[0];
        for (var i = 0; i < centerVisData.spectrum.length; i++) {
            centerVisData.spectrum[i] = (this.visData[1].spectrum[i] / 2 + this.visData[2].spectrum[i] / 2);
        }
        for (var i = 0; i < centerVisData.waveform.length; i++) {
            centerVisData.waveform[i] = (this.visData[1].waveform[i] / 2 + this.visData[2].waveform[i] / 2);
        }
        // Simple kick detection
        this.beat = false;
        var peakLeft = 0;
        var peakRight = 0;
        for (var i = 0; i < this.fftSize; i++) {
            peakLeft += Math.abs(this.visData[1].waveform[i]);
            peakRight += Math.abs(this.visData[2].waveform[i]);
        }
        var peak = Math.max(peakLeft, peakRight) / this.fftSize;
        if (peak >= this.movingThreshold && peak >= this.threshold) {
            this.movingThreshold = peak;
            this.beat = true;
        }
        else {
            this.movingThreshold = this.movingThreshold * (1 - this.decay) + peak * this.decay;
        }
    };
    /**
     * Helper for Webvs.WebAudioAnalyser#connectToNode. This creates Audio object
     * for the audio file and connects this analyser to its mediaElementSource
     * @param source source for the audio. Use an audio tag element or a url
     * @param readyFunc a callback that'll be called when ready to play
     */
    WebAudioAnalyser.prototype.load = function (source, readyFunc) {
        var _this = this;
        var element;
        if (source instanceof HTMLMediaElement) {
            element = source;
            this.source = this.context.createMediaElementSource(element);
        }
        else {
            element = new Audio();
            element.src = source;
            this.source = this.context.createMediaElementSource(element);
        }
        var onCanPlay = function () {
            _this.connectToNode(_this.source);
            _this.source.connect(_this.context.destination);
            if (readyFunc) {
                readyFunc(element);
            }
            element.removeEventListener("canplay", onCanPlay);
        };
        if (element.readyState < 3) {
            element.addEventListener("canplay", onCanPlay);
        }
        else {
            onCanPlay();
        }
        return element;
    };
    // Returns array of waveform values
    WebAudioAnalyser.prototype.getWaveform = function (channel) {
        if (channel === void 0) { channel = utils_1.Channels.CENTER; }
        return this.visData[channel].waveform;
    };
    // Returns array of spectrum values
    WebAudioAnalyser.prototype.getSpectrum = function (channel) {
        if (channel === void 0) { channel = utils_1.Channels.CENTER; }
        return this.visData[channel].spectrum;
    };
    // boolean value indicating whether a beat
    // is in progress or not
    WebAudioAnalyser.prototype.isBeat = function () {
        return this.beat;
    };
    return WebAudioAnalyser;
}(AnalyserAdapter_1["default"]));
exports["default"] = WebAudioAnalyser;


/***/ })
/******/ ])["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2VidnMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjIyMjE5MDRhNDQ5YTI0MmIzY2QiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQ29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy93ZWJnbC9TaGFkZXJQcm9ncmFtLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE5hdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9lYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdFBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9LZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0ludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9lcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXRlcmF0ZWUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4cHIvY29tcGlsZUV4cHIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3dlYmdsL0J1ZmZlci50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19MaXN0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNzb2NJbmRleE9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXBEYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5c0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQ3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9mbGF0dGVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1NldENhY2hlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTbGljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQ3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yZXBsYWNlSG9sZGVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Nsb25lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N0YWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlFYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weUFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlQdXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRBbGxLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcHBseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mbGF0UmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL01vZGVsLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0xvZGFzaFdyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUxvZGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXREYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0xhenlXcmFwcGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldEhvbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3Rha2VSaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXhwci9Db2RlSW5zdGFuY2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3dlYmdsL2dlb21ldHJpZXMudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUNsb25lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUFzc2lnblZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fV2Vha01hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19VaW50OEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Nob3J0T3V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvcGljay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUGlja0J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9oYXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEFycmF5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVW5kZWZpbmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJbmRleE9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nhc3RGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Zsb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWV0YU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL25vb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0RnVuY05hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNMYXppYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTnVtYmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9wYXJ0aWFsUmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNldERhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlSHlicmlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvbXBvc2VBcmdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvbXBvc2VBcmdzUmlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlUmVjdXJyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXREYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldFdyYXBUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVW5pcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3VuaXEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4cHIvQXN0LnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXh0ZW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGFrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RpbWVzLmpzIiwid2VicGFjazovLy8uL3NyYy93ZWJnbC9UZXh0dXJlU2V0TWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvd2ViZ2wvQ2xlYXJTY3JlZW5Qcm9ncmFtLnRzIiwid2VicGFjazovLy8uL3NyYy9hbmFseXNlci9BbmFseXNlckFkYXB0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL01haW4udHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzTWFza2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19IYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQXNzaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUFzc2lnbkluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5c0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlTeW1ib2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbml0Q2xvbmVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbml0Q2xvbmVCeVRhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZURhdGFWaWV3LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lUmVnRXhwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lU3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbml0Q2xvbmVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc01hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1NldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVBpY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaW5nVG9QYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21lbW9pemVDYXBwZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9tZW1vaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VIYXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0ZsYXR0ZW5hYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdGF0cy5qcy9idWlsZC9zdGF0cy5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2J1aWx0aW5SZXNvdXJjZVBhY2sudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NvbXBvbmVudFJlZ2lzdHJ5LnRzIiwid2VicGFjazovLy8uL3NyYy9FZmZlY3RMaXN0LnRzIiwid2VicGFjazovLy8uL3NyYy9Db250YWluZXIudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzRXF1YWxEZWVwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldENhY2hlQWRkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5U29tZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEJ5VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxPYmplY3RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvb21pdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVW5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcGFyZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2N1c3RvbU9taXRDbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy91bmlxdWVJZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGb3JPd24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUZvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUJhc2VFYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNYXRjaGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc01hdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE1hdGNoRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2RpZmZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZURpZmZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNOYU4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaWN0SW5kZXhPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2ZvckVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlRmxvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yZWFsTmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy93cmFwcGVyTG9kYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3dyYXBwZXJDbG9uZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2ludGVyc2VjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSW50ZXJzZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nhc3RBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlV3JhcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUN1cnJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvdW50SG9sZGVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRXcmFwRGV0YWlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbnNlcnRXcmFwRGV0YWlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL191cGRhdGVXcmFwRGV0YWlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yZW9yZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZVBhcnRpYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWVyZ2VEYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9GaW5pdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3VuaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3ZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZHJvcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Fzc2lnbkluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUFzc2lnbmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4cHIvRXhwckdyYW1tYXIucGVnanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21pc2MvQnVmZmVyU2F2ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbWlzYy9HbG9iYWxWYXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlci9DbGVhclNjcmVlbi50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlci9Nb3ZpbmdQYXJ0aWNsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyL1BpY3R1cmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlbmRlci9TdXBlclNjb3BlLnRzIiwid2VicGFjazovLy8uL3NyYy9yZW5kZXIvVGV4ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1Jlc291cmNlTWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3BpY2tCeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdHJhbnMvQ2hhbm5lbFNoaWZ0LnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZmxhdE1hcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdHJhbnMvQ29sb3JDbGlwLnRzIiwid2VicGFjazovLy8uL3NyYy90cmFucy9Db2xvck1hcC50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2ZpcnN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaGVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3NvcnRCeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlT3JkZXJCeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU29ydEJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvbXBhcmVNdWx0aXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb21wYXJlQXNjZW5kaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvemlwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdW56aXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RyYW5zL0NvbnZvbHV0aW9uLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvcmVkdWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5UmVkdWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VSZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RyYW5zL0R5bmFtaWNNb3ZlbWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdHJhbnMvRmFkZU91dC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdHJhbnMvSW52ZXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy90cmFucy9NaXJyb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3RyYW5zL01vc2FpYy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdHJhbnMvVW5pcXVlVG9uZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvd2ViZ2wvQ29weVByb2dyYW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3dlYmdsL1JlbmRlcmluZ0NvbnRleHQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FuYWx5c2VyL1dlYkF1ZGlvQW5hbHlzZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTQyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBiMjIyMTkwNGE0NDlhMjQyYjNjZCIsImltcG9ydCBmbG93IGZyb20gXCJsb2Rhc2gtZXMvZmxvd1wiO1xuaW1wb3J0IG1hcCBmcm9tIFwibG9kYXNoLWVzL21hcFwiO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyBwciB9IGZyb20gXCJsb2Rhc2gtZXMvcGFydGlhbFJpZ2h0XCI7XG5pbXBvcnQgdGFrZVJpZ2h0IGZyb20gXCJsb2Rhc2gtZXMvdGFrZVJpZ2h0XCI7XG5cbi8qKlxuICogQSBOby1PcCBmdW5jdGlvblxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZW1wdHlcbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge31cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gb2JqZWN0IGNvbnRhaW5zIHRoZSByZXF1aXJlZCBwcm9wZXJ0aWVzLiBUaHJvd3MgYW4gZXJyb3JcbiAqIGZvciBtaXNzaW5nIG9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIGJlIGNoZWNrZWRcbiAqIEBwYXJhbSByZXF1aXJlZE9wdGlvbnMgc2V0IG9mIHJlcXVpcmVkIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRPcHRpb25zKG9wdGlvbnM6IGFueSwgcmVxdWlyZWRPcHRpb25zOiBzdHJpbmdbXSk6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgb3B0aW9uTmFtZSBvZiByZXF1aXJlZE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEob3B0aW9uTmFtZSBpbiBvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZWQgb3B0aW9uIFwiICsgb3B0aW9uTmFtZSArIFwiIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQgdmFsdWUgcmVwcmVzZW50YXRpb24gb2YgYSBudW1iZXJcbiAqIGVtYmVkZGFibGUgaW4gZ2xzbCBzaGFkZXIgY29kZVxuICogQHBhcmFtIHZhbCB2YWx1ZSB0byBiZSBjb252ZXJ0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdsc2xGbG9hdFJlcHIodmFsKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdmFsICsgKHBhcnNlRmxvYXQodmFsKSAlIDEgPT09IDAgPyBcIi4wXCIgOiBcIlwiKTtcbn1cblxuLyoqXG4gKiBDb2xvciB0eXBlLiBSLCBHLCBCXG4gKi9cbmV4cG9ydCB0eXBlIENvbG9yID0gW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgYXJndW1lbnQgaXMgYSBDb2xvciBvciBub3RcbiAqIEBwYXJhbSBjb2xvciBjb2xvciB0byBiZSBjaGVja2VkXG4gKi9cbmZ1bmN0aW9uIGlzQ29sb3IoY29sb3I6IHN0cmluZyB8IENvbG9yKTogY29sb3IgaXMgQ29sb3Ige1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGNvbG9yKSAmJiBjb2xvci5sZW5ndGggPT09IDM7XG59XG5cbi8qKlxuICogUGFyc2UgY3NzIGNvbG9yIHN0cmluZyAjUlJHR0JCIG9yIHJnYihyLCBnLCBiKVxuICogQHBhcmFtIGNvbG9yIHRoZSBjb2xvciB2YWx1ZSB0byBiZSBwYXJzZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29sb3IoY29sb3I6IHN0cmluZyB8IENvbG9yKTogQ29sb3Ige1xuICAgIGlmIChpc0NvbG9yKGNvbG9yKSkge1xuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3IgPSBjb2xvci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBjb2xvci5tYXRjaCgvXiMoW2EtZjAtOV17Mn0pKFthLWYwLTldezJ9KShbYS1mMC05XXsyfSkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZsb3coW1xuICAgICAgICAgICAgICAgIHByKHRha2VSaWdodCwgMyksXG4gICAgICAgICAgICAgICAgcHIobWFwLCAoY2hhbm5lbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoY2hhbm5lbCwgMTYpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSkobWF0Y2gpIGFzIENvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0Y2ggPSBjb2xvci5tYXRjaCgvXnJnYlxcKFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqXFwpJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmbG93KFtcbiAgICAgICAgICAgICAgICBwcih0YWtlUmlnaHQsIDMpLFxuICAgICAgICAgICAgICAgIHByKG1hcCwgKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHBhcnNlSW50KGNoYW5uZWwsIDEwKSwgMjU1KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pKG1hdGNoKSBhcyBDb2xvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIENvbG9yIEZvcm1hdFwiKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBjc3MgY29sb3Igc3RyaW5nIGFuZCByZXR1cm4gbm9ybWFsaXplcyBDb2xvciB2YWx1ZVxuICogQHBhcmFtIGNvbG9yIHRoZSBjb2xvciB2YWx1ZSB0byBiZSBwYXJzZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29sb3JOb3JtKGNvbG9yOiBzdHJpbmcgfCBDb2xvcik6IENvbG9yIHtcbiAgICByZXR1cm4gbWFwKHBhcnNlQ29sb3IoY29sb3IpLCAodmFsdWUpID0+IHZhbHVlIC8gMjU1KSBhcyBDb2xvcjtcbn1cblxuLyoqXG4gKiBQYXJzZXMgc2hhZGVyIGVycm9yIG1lc3NhZ2UgYW5kIGRpc3BsYXlzIHJlYWRhYmxlIGluZm9ybWF0aW9uXG4gKiBAcGFyYW0gc3JjIHNvdXJjZSBvZiB0aGUgc2hhZGVyXG4gKiBAcGFyYW0gZXJyb3IgZXJyb3IgbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9nU2hhZGVyRXJyb3Ioc3JjOiBzdHJpbmcsIGVycm9yOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBsaW5lcyA9IHNyYy5zcGxpdChcIlxcblwiKTtcbiAgICBjb25zdCBuZGlnaXRzID0gbGluZXMubGVuZ3RoLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gICAgY29uc3QgZXJyb3JQb3NNYXRjaCA9IGVycm9yLm1hdGNoKC8oXFxkKyk6KFxcZCspLyk7XG4gICAgbGV0IGVycm9yUG9zOiBbbnVtYmVyLCBudW1iZXJdO1xuICAgIGlmIChlcnJvclBvc01hdGNoKSB7XG4gICAgICAgIGVycm9yUG9zID0gW3BhcnNlSW50KGVycm9yUG9zTWF0Y2hbMV0sIDEwKSwgcGFyc2VJbnQoZXJyb3JQb3NNYXRjaFsyXSwgMTApXTtcbiAgICB9XG5cbiAgICBjb25zdCBudW1iZXJlZExpbmVzID0gbWFwKGxpbmVzLCAobGluZSwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBsaW5lTnVtYmVyID0gKGluZGV4ICsgMSkgKyBcIlwiO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgKG5kaWdpdHMgLSBsaW5lTnVtYmVyLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgbGluZU51bWJlciA9IFwiMFwiICsgbGluZU51bWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBlcnJvckluZGljYXRvciA9IFwiXCI7XG4gICAgICAgIGlmIChlcnJvclBvcyAmJiBlcnJvclBvc1sxXSA9PT0gaW5kZXggKyAxKSB7XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlcnJvclBvc1swXSArIG5kaWdpdHMgKyAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbmRlbnQgKz0gXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvckluZGljYXRvciA9IFwiXFxuXCIgKyBpbmRlbnQgKyBcIl5cXG5cIiArIGluZGVudCArIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lTnVtYmVyICsgXCI6IFwiICsgbGluZSArIGVycm9ySW5kaWNhdG9yO1xuICAgIH0pLmpvaW4oXCJcXG5cIik7XG5cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKFwiU2hhZGVyIEVycm9yIDogXFxuXCIgKyBudW1iZXJlZExpbmVzKTtcbn1cblxuLyoqXG4gKiBCbGVuZCBNb2Rlc1xuICovXG5leHBvcnQgZW51bSBCbGVuZE1vZGUge1xuICAgIFJFUExBQ0UgPSAxLFxuICAgIE1BWElNVU0sXG4gICAgQVZFUkFHRSxcbiAgICBBRERJVElWRSxcbiAgICBTVUJUUkFDVElWRTEsXG4gICAgU1VCVFJBQ1RJVkUyLFxuICAgIE1VTFRJUExZLFxuICAgIE1VTFRJUExZMixcbiAgICBBREpVU1RBQkxFLFxuICAgIEFMUEhBLFxufVxuXG4vKipcbiAqIENoYW5uZWxzXG4gKi9cbmV4cG9ydCBlbnVtIENoYW5uZWxzIHtcbiAgICBDRU5URVIgPSAwLFxuICAgIExFRlQsXG4gICAgUklHSFQsXG59XG5cbi8qKlxuICogU291cmNlXG4gKi9cbmV4cG9ydCBlbnVtIFNvdXJjZSB7XG4gICAgU1BFQ1RSVU0gPSAxLFxuICAgIFdBVkVGT1JNLFxufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gc3RyaW5nIG9mIGdpdmVuIGxlbmd0aFxuICogQHBhcmFtIGNvdW50IG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gKiBAcGFyYW0gY2hhcnMgY2hhcmFjdGVyIHNldCB0byBjaG9vc2UgZnJvbVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZFN0cmluZyhjb3VudDogbnVtYmVyLCBjaGFyczogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCByYW5kU3RyID0gW107XG4gICAgY2hhcnMgPSBjaGFycyB8fCBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHJhbmRTdHIucHVzaChjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZFN0ci5qb2luKFwiXCIpO1xufVxuXG4vKipcbiAqIFdlYkdMIGRhdGEgdHlwZXNcbiAqL1xuZXhwb3J0IGVudW0gV2ViR0xWYXJUeXBlIHtcbiAgICBURVhUVVJFMkQgPSBcInRleHR1cmUyRFwiLFxuICAgIF8xRiA9IFwiMWZcIiwgXzJGID0gXCIyZlwiLCBfM0YgPSBcIjNmXCIsIF80RiA9IFwiNGZcIixcbiAgICBfMUkgPSBcIjFpXCIsIF8ySSA9IFwiMmlcIiwgXzNJID0gXCIzaVwiLCBfNEkgPSBcIjRpXCIsXG4gICAgXzFGViA9IFwiMWZ2XCIsIF8yRlYgPSBcIjJmdlwiLCBfM0ZWID0gXCIzZnZcIiwgXzRGViA9IFwiNGZ2XCIsXG4gICAgXzFJViA9IFwiMWl2XCIsIF8ySVYgPSBcIjJpdlwiLCBfM0lWID0gXCIzaXZcIiwgXzRJViA9IFwiNGl2XCIsXG59XG5cbmV4cG9ydCB0eXBlIEZsb2F0QXJyYXkgPSBudW1iZXJbXSB8IEZsb2F0MzJBcnJheSB8IEZsb2F0NjRBcnJheTtcbmV4cG9ydCB0eXBlIFR5cGVkQXJyYXkgPSBJbnQ4QXJyYXkgfCBVaW50OEFycmF5IHwgVWludDhDbGFtcGVkQXJyYXkgfCBJbnQxNkFycmF5IHwgVWludDE2QXJyYXkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgIEludDMyQXJyYXkgfCBVaW50MzJBcnJheSB8IEZsb2F0MzJBcnJheSB8IEZsb2F0NjRBcnJheTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZWRBcnJheShhcnJheTogYW55KTogYXJyYXkgaXMgVHlwZWRBcnJheSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgYXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHxcbiAgICAgICAgYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIGFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgfHxcbiAgICAgICAgYXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8XG4gICAgICAgIGFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkgfHxcbiAgICAgICAgYXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8XG4gICAgICAgIGFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHxcbiAgICAgICAgYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXlcbiAgICApO1xufVxuXG4vKipcbiAqIENsYW1wIG51bWJlciBiZXR3ZWVuIHJhbmdlXG4gKiBAcGFyYW0gbnVtIG51bWJlciB0byBjbGFtcFxuICogQHBhcmFtIG1pbiBtaW4gdmFsdWUgb2YgdGhlIHJhbmdlXG4gKiBAcGFyYW0gbWF4IG1heCB2YWx1ZSBvZiB0aGUgcmFuZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKG51bTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtLCBtaW4pLCBtYXgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHByb3BlcnR5IGdpdmVuIGl0cyAoZG90IHNlcGFyYXRlZCkgcGF0aCBpbiBhbiBvYmplY3RcbiAqIEBwYXJhbSBvYmogb2JqZWN0IHdpdGggdGhlIHByb3BlcnR5XG4gKiBAcGFyYW0gbmFtZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvcGVydHkob2JqOiBhbnksIG5hbWU6IHN0cmluZyB8IHN0cmluZ1tdKTogYW55IHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IG9ialtuYW1lLnNoaWZ0KCldO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UHJvcGVydHkodmFsdWUsIG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFNldHMgYSBwcm9wZXJ0eSwgZ2l2ZW4gaXRzIChkb3Qgc2VwYXJhdGVkKSBwYXRoIGluIGFuIG9iamVjdFxuICogQHBhcmFtIG9iaiB0aGUgb2JqZWN0IGluIHdoaWNoIHRoZSBwcm9wZXJ0eSBpcyB0byBiZSBzZXRcbiAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4gKiBAcGFyYW0gdmFsdWUgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wZXJ0eShvYmo6IGFueSwgbmFtZTogc3RyaW5nIHwgc3RyaW5nW10sIHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBuYW1lLnNoaWZ0KCk7XG4gICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG9ialtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2V0UHJvcGVydHkob2JqW3Byb3BlcnR5TmFtZV0sIG5hbWUsIHZhbHVlKTtcbiAgICB9XG59XG5cbi8qKlxuICogZmxhdHRlbnMgYXJyYXkgb2Ygc3RyaW5ncyB0byBzaW5nbGUgc3RyaW5nXG4gKiBAcGFyYW0gdmFsdWUgc3RyaW5nIG9yIGxpc3Qgb2Ygc3RyaW5ncyB0byBiZSBmbGF0dGVuZWRcbiAqIEBwYXJhbSBzZXAgc2VwcmF0b3IgdG8gZmxhdHRlbiB0aGUgc3RyaW5ncyB3aXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGF0U3RyaW5nKHZhbHVlOiBzdHJpbmcgfCBzdHJpbmdbXSwgc2VwOiBzdHJpbmcgPSBcIlxcblwiKTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmpvaW4oc2VwKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMudHMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGNsb25lIGZyb20gXCJsb2Rhc2gtZXMvY2xvbmVcIjtcbmltcG9ydCBkZWZhdWx0cyBmcm9tIFwibG9kYXNoLWVzL2RlZmF1bHRzXCI7XG5pbXBvcnQgZmxhdHRlbiBmcm9tIFwibG9kYXNoLWVzL2ZsYXR0ZW5cIjtcbmltcG9ydCBpc0VxdWFsIGZyb20gXCJsb2Rhc2gtZXMvaXNFcXVhbFwiO1xuaW1wb3J0IGlzVW5kZWZpbmVkIGZyb20gXCJsb2Rhc2gtZXMvaXNVbmRlZmluZWRcIjtcbmltcG9ydCBvbWl0IGZyb20gXCJsb2Rhc2gtZXMvb21pdFwiO1xuaW1wb3J0IHVuaXF1ZUlkIGZyb20gXCJsb2Rhc2gtZXMvdW5pcXVlSWRcIjtcbmltcG9ydCBJTWFpbiBmcm9tIFwiLi9JTWFpblwiO1xuaW1wb3J0IE1vZGVsIGZyb20gXCIuL01vZGVsXCI7XG5pbXBvcnQgVGV4dHVyZVNldE1hbmFnZXIgZnJvbSBcIi4vd2ViZ2wvVGV4dHVyZVNldE1hbmFnZXJcIjtcblxuLyoqXG4gKiBDb21wb25lbnQgQ2xhc3MgQ29uc3RydWN0b3IgaW50ZXJmYWNlLiBUaGlzIGRlY2xhcmVzIHN0YXRpYyBtZW1iZXJcbiAqIGFuZCBjb25zdHJ1Y3RvciBzaWduYXR1cmUgZm9yIGEgQ29tcG9uZW50IGNsYXNzIGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNvbXBvbmVudENvbnN0cnVjdG9yIHtcbiAgICAvKipcbiAgICAgKiBDb21wb25lbnQgY2xhc3MgY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBuZXcobWFpbjogSU1haW4sIHBhcmVudDogSUNvbnRhaW5lciwgb3B0czogYW55KTogQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0Q29tcG9uZW50TmFtZSgpOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHRhZyB0aGF0IGNhdGVnb3JpemVzIHRoZSBjb21wb25lbnQuIGUuZy4gdHJhbnMsIHJlbmRlclxuICAgICAqL1xuICAgIGdldENvbXBvbmVudFRhZygpOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ29uYWluZXIgaW50ZXJmYWNlLiBUaGlzIGRlY2xhcmVzIG1lbWJlcnMgZm9yXG4gKiBDb250YWluZXIgQ29tcG9uZW50cy4gc2VlIFtbQ29udGFpbmVyXV0gZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJQ29udGFpbmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBnZXRUU00oKTogVGV4dHVyZVNldE1hbmFnZXI7XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIENvbXBvbmVudHMuXG4gKlxuICogV2VidnMgcmVuZGVycyB2aXN1YWxpemF0aW9ucyBieSBsYXllcmluZyBkaWZmZXJlbnQgQ29tcG9uZW50cyBvciBlZmZlY3RzXG4gKiBvbmUgYWZ0ZXIgdGhlIG90aGVyLiBFYWNoIENvbXBvbmVudCB0eXBlIHdpbGwgaGF2ZSBhIGRpZmZlcmVudCByZW5kZXJpbmdcbiAqIGJlaGF2aW91ciB3aGljaCBjYW4gYmUgY29uZmlndXJlZCB0aHJvdWdoIHRoZSBjb21wb25lbnQgb3B0aW9ucy4gU29tZVxuICogY29tcG9uZW50cyBtYXkgaGF2ZSBzdWIgY29tcG9uZW50cywgaW4gd2hpY2ggY2FzZSB0aGUgcmVuZGVyaW5nIG9mIGFsbFxuICogdGhlIHN1YmNvbXBvbmVudHMgaXMgbW9kaWZpZWQvY29udHJvbGxlZCBpbiBzb21lIG1hbm5lciBieSB0aGUgcGFyZW50LlxuICogZWcuIFtbRWZmZWN0TGlzdF1dLCB3aGljaCByZW5kZXJzIGEgc2V0IG9mIGNvbXBvbmVudHMgaW50byBhIHNlcGFyYXRlXG4gKiBidWZmZXIgd2hpY2ggaXMgdGhlbiBibGVuZGVkIGJhY2sgaW50byB0aGUgbWFpbiByZW5kZXIuXG4gKlxuICogT3B0aW9ucyBvbiBjb21wb25lbnRzIGNhbiBiZSBtb2RpZmllZCB3aXRoIGEgW1tNb2RlbC5zZXRdXSBjYWxsLiBUaGlzXG4gKiBhbGxvd3MgQ29tcG9uZW50cyB0byByZXNwb25kIHRvIGNoYW5nZXMgaW4gb3B0aW9ucyBpbiByZWFsLXRpbWUuXG4gKiBFZzogQ2hhbmdpbmcgY29sb3JzLCBDb2RlIGV0Yy4gVGhpcyBmZWF0dXJlIGNhbiBiZSB1c2VkIHRvIGJ1aWxkXG4gKiBMaXZlLUVkaXQgVXNlciBJbnRlcmZhY2VzIGZvciBwcmVzZXRzIGRldmVsb3BtZW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBDb21wb25lbnQgZXh0ZW5kcyBNb2RlbCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb21wb25lbnROYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudE5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyB0YWcgdGhhdCBjYXRlZ29yaXplcyB0aGUgY29tcG9uZW50LiBlLmcuIHRyYW5zLCByZW5kZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldENvbXBvbmVudFRhZygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzdGF0aWMgY29tcG9uZW50TmFtZTogc3RyaW5nID0gXCJDb21wb25lbnRcIjtcblxuICAgIC8qKlxuICAgICAqIEEgc3RyaW5nIHRhZyB0aGF0IGNhdGVnb3JpemVzIHRoZSBjb21wb25lbnQuIGUuZy4gdHJhbnMsIHJlbmRlclxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzdGF0aWMgY29tcG9uZW50VGFnOiBzdHJpbmcgPSBcIlwiO1xuXG4gICAgLyoqXG4gICAgICogTWFwIGZyb20gb3B0aW9uIG5hbWUgdG8gaGFuZGxlciBtZXRob2RzLiBUaGUgaGFuZGxlciBtZXRob2RzIGFyZVxuICAgICAqIGNhbGxlZCBpbiBvcmRlciB3aGVuIG9uIGFuIG9wdGlvbiBpcyB1cGRhdGVkIHdpdGggYSBbW01vZGVsLnNldF1dIGNhbGwuXG4gICAgICogVGhpcyBhbGxvd3MgY29tcG9uZW50IHRvIHJlc3BvbmQgdG8gb3B0aW9uIGNoYW5nZXMgbGl2ZS4gZS5nLiBJbiBhIExpdmUtRWRpdFxuICAgICAqIFVzZXIgSW50ZXJmYWNlIGZvciBwcmVzZXQgZGV2ZWxvcG1lbnQuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBvcHRVcGRhdGVIYW5kbGVyczoge1trZXk6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdIH0gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIGNvbXBvbmVudFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzdGF0aWMgZGVmYXVsdE9wdGlvbnM6IGFueSA9IHt9O1xuXG4gICAgcHVibGljIFtcImNvbnN0cnVjdG9yXCJdOiB0eXBlb2YgQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogY3VycmVudCBvcHRpb25zIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb3B0czogYW55O1xuICAgIC8qKlxuICAgICAqIFRoZSBtYWluIGluc3RhbmNlIHRoYXQgbWFuYWdlcyB0aGlzIGNvbXBvbmVudFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBtYWluOiBJTWFpbjtcbiAgICAvKipcbiAgICAgKiBUaGUgcGFyZW50IGNvbXBvbmVudCB0aGF0IG1hbmFnZXMgdGhpcyBjb21wb25lbnRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcGFyZW50OiBJQ29udGFpbmVyO1xuXG4gICAgcHJpdmF0ZSBpZDogc3RyaW5nO1xuICAgIHByaXZhdGUgZW5hYmxlZDogYm9vbGVhbjtcbiAgICBwcml2YXRlIGxhc3RFcnJvcjogYW55O1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBuZXcgQ29tcG9uZW50LiBDb21wb25lbnRzIGFyZSB1c3VhbGx5IGluc3RhbnRhdGVkIGJ5IGEgW1tDb250YWluZXJdXSBjb21wb25lbnRcbiAgICAgKiBvciBbW01haW5dXSBpbiB0aGUgY2FzZSBvZiB0aGUgcm9vdCBbW0VmZmVjdExpc3RdXS5cbiAgICAgKiBAcGFyYW0gbWFpbiB0aGUgbWFpbiBvYmplY3QgdGhhdCBtYW5hZ2VzIHRoaXMgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHBhcmVudCB0aGUgcGFyZW50IHRoYXQgbWFuYWdlcyB0aGlzIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSBvcHRpb25zIHRoZSBpbml0aWFsIG9wdGlvbnMgZm9yIHRoaXMgY29tcG9uZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWFpbjogSU1haW4sIHBhcmVudDogSUNvbnRhaW5lciwgb3B0aW9uczogYW55KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWFpbiA9IG1haW47XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkOyAvLyBUT0RPOiBjaGVjayBmb3IgaWQgdW5pcXVlbmVzc1xuICAgICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB1bmlxdWVJZCh0aGlzLmNvbnN0cnVjdG9yLmNvbXBvbmVudE5hbWUgICsgXCJfXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGlzVW5kZWZpbmVkKG9wdGlvbnMuZW5hYmxlZCkgPyB0cnVlIDogb3B0aW9ucy5lbmFibGVkO1xuXG4gICAgICAgIHRoaXMub3B0cyA9IG9taXQob3B0aW9ucywgW1wiaWRcIiwgXCJlbmFibGVkXCJdKTtcblxuICAgICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIGlmIChkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRzID0gZGVmYXVsdHModGhpcy5vcHRzLCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgaW5pdGlhbGl6YXRpb24gZm9yIHRoZVxuICAgICAqIGNvbXBvbmVudC4gVHlwaWNhbGx5IHlvdSdkIGNhbGwgc29tZSB1cGRhdGVIYW5kbGVycyBoZXJlIHRvIGluaXRpYWxpemUgc3RhdGVzXG4gICAgICogZnJvbSB0aGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGluaXQoKTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGRyYXdpbmcgb3BlcmF0aW9ucy4gT3ZlcnJpZGUgdG8gaW1wbGVtZW50IGRyYXdpbmcgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAqIFR5cGljYWxseSB5b3UnZCBtYWtlIHNvbWUgV2ViR0wgb3BlcmF0aW9ucyB0byByZW5kZXIgdG8gdGhlIGZyYW1lYnVmZmVyIG1hbmFnZXJcbiAgICAgKiBvZiB0aGlzIGNvbXBvbmVudHMgcGFyZW50LlxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBkcmF3KCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBjb21wb25lbnQgaXMgZW5hYmxlZCBvciBub3RcbiAgICAgKi9cbiAgICBwdWJsaWMgaXNFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmFibGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlkIG9mIHRoaXMgY29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldElkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhc3QgZXJyb3IuIFRoYXQgcmFpc2VkIGFuIGBlcnJvcjoqYCBldmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRMYXN0RXJyb3IoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdEVycm9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFuZCBjbGVhbnN1cCByZXNvdXJjZXMuIFBsZWFzZSBvdmVycmlkZSB0b1xuICAgICAqIGNsZWFudXAgY29tcG9uZW50IHNwZWNpZmljIHJlc291cmNlcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcGFyZW50IG9mIHRoaXMgY29tcG9uZW50XG4gICAgICogQHBhcmFtIG5ld1BhcmVudCB0aGUgbmV3IHBhcmVudCBvZiB0aGlzIGNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRQYXJlbnQobmV3UGFyZW50OiBJQ29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbmV3UGFyZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbXBvbmVudCBvcHRpb25zLlxuICAgICAqXG4gICAgICogVGhpcyB2YWx1ZSBpZiBwYXNzZWQgaW50byBjb25zdHJ1Y3RvciB3aWxsIGluc3RhbnRpYXRlIGEgY29tcG9uZW50XG4gICAgICogdGhhdCBiZWhhdmVzIHRoZSBzYW1lIGFzIHRoaXMgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHB1YmxpYyB0b0pTT04oKTogYW55IHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGNsb25lKHRoaXMub3B0cyk7XG4gICAgICAgIG9wdHMuaWQgPSB0aGlzLmlkO1xuICAgICAgICBvcHRzLnR5cGUgPSB0aGlzLmNvbnN0cnVjdG9yLmNvbXBvbmVudE5hbWU7XG4gICAgICAgIG9wdHMuZW5hYmxlZCA9IHRoaXMuZW5hYmxlZDtcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBhIGNvbXBvbmVudCBvcHRpb25zIGdpdmVuIG5hbWVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0KG5hbWU6IHN0cmluZyk6IGFueSB7XG4gICAgICAgIGlmIChuYW1lID09PSBcImVuYWJsZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZDtcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBcImlkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0c1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgL2AgcGF0aCB0byB0aGUgY29tcG9uZW50IGZyb20gdGhlIHJvb3QuXG4gICAgICovXG4gICAgcHVibGljIGdldFBhdGgoKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLnBhcmVudCkgJiYgIWlzVW5kZWZpbmVkKHRoaXMuaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0UGF0aCgpICsgXCIvXCIgKyB0aGlzLmNvbnN0cnVjdG9yLmNvbXBvbmVudE5hbWUgKyBcIiNcIiArIHRoaXMuaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jb21wb25lbnROYW1lICsgXCIjTWFpblwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldEF0dHJpYnV0ZShrZXk6IHN0cmluZywgdmFsdWU6IGFueSwgb3B0aW9uczogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJ0eXBlXCIgfHwgaXNFcXVhbCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIHByb3BlcnR5XG4gICAgICAgIGlmIChrZXkgPT09IFwiZW5hYmxlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwiaWRcIikge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGwgYWxsIG9uY2hhbmdlIGhhbmRsZXJzXG4gICAgICAgIC8vIHdlIGp1c3QgY2FsbCB0aGVzZSBtYW51YWxseSBoZXJlIG5vIG5lZWQgdG9cbiAgICAgICAgLy8gZ28gdGhyb3VnaCBldmVudCB0cmlnZ2Vyc1xuICAgICAgICBjb25zdCBvcHRVcGRhdGVIYW5kbGVycyA9IHRoaXMuY29uc3RydWN0b3Iub3B0VXBkYXRlSGFuZGxlcnM7XG4gICAgICAgIGlmIChvcHRVcGRhdGVIYW5kbGVycykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbkNoYW5nZSA9IGZsYXR0ZW4oW1xuICAgICAgICAgICAgICAgICAgICBvcHRVcGRhdGVIYW5kbGVyc1trZXldIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICBvcHRVcGRhdGVIYW5kbGVyc1tcIipcIl0gfHwgW10sXG4gICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9uQ2hhbmdlSGFuZGxlciBvZiBvbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW29uQ2hhbmdlSGFuZGxlcl0uY2FsbCh0aGlzLCB2YWx1ZSwga2V5LCBvbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgb2xkIHZhbHVlIGluIGNhc2UgYW55IG9mIHRoZSBvbkNoYW5nZSBoYW5kbGVycyBmYWlsXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJlbmFibGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwiaWRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzW2tleV0gPSBvbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3I6XCIgKyBrZXksIHRoaXMsIHZhbHVlLCBvcHRpb25zLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Db21wb25lbnQudHMiLCJpbXBvcnQgZGVmYXVsdHMgZnJvbSBcImxvZGFzaC1lcy9kZWZhdWx0c1wiO1xuaW1wb3J0IGVhY2ggZnJvbSBcImxvZGFzaC1lcy9lYWNoXCI7XG5pbXBvcnQgaW5kZXhPZiBmcm9tIFwibG9kYXNoLWVzL2luZGV4T2ZcIjtcbmltcG9ydCB7IEJsZW5kTW9kZSwgZmxhdFN0cmluZywgbG9nU2hhZGVyRXJyb3IsIFdlYkdMVmFyVHlwZSB9IGZyb20gXCIuLi91dGlsc1wiO1xuaW1wb3J0IEJ1ZmZlciBmcm9tIFwiLi9CdWZmZXJcIjtcbmltcG9ydCB7IHNxdWFyZUdlb21ldHJ5IH0gZnJvbSBcIi4vZ2VvbWV0cmllc1wiO1xuaW1wb3J0IFJlbmRlcmluZ0NvbnRleHQgZnJvbSBcIi4vUmVuZGVyaW5nQ29udGV4dFwiO1xuaW1wb3J0IFRleHR1cmVTZXRNYW5hZ2VyIGZyb20gXCIuL1RleHR1cmVTZXRNYW5hZ2VyXCI7XG5cbi8qKlxuICogQXR0cmlidXRlIGJpbmRpbmcuIFRoZSBwcm9wZXJ0aWVzIGhlcmUgYXJlIGJhc2ljYWxseSBqdXN0XG4gKiBwYXNzZWQgaW4gYXMgYXJndW1lbnRzIHRvIGEgYGdsLnZlcnRpeEF0dHJpYlBvaW50ZXJgIGNhbGwuXG4gKi9cbmludGVyZmFjZSBJQXR0cmlidXRlQmluZGluZyB7XG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICovXG4gICAgbmFtZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIHZlY3RvciBzaXplIG9mIHRoZSBhdHRyaWJ1dGUuIERlZmF1bHQ6IDJcbiAgICAgKi9cbiAgICBzaXplPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIHR5cGUgb2YgdGhlIHZhbHVlcy4gRGVmYXVsdDogYGdsLkZMT0FUYFxuICAgICAqL1xuICAgIHZhbHVlVHlwZT86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBpbnRlZ2VyIGRhdGEgdmFsaXVlcyBzaG91bGQgYmUgbm9ybWFsaXplZFxuICAgICAqL1xuICAgIG5vcm1hbGl6ZWQ/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFN0cmlkZSBmb3IgYXR0cmlidXRlIHBhY2tpbmdcbiAgICAgKi9cbiAgICBzdHJpZGU/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogT2Zmc2V0IHRvIGZpcnN0IHZhbHVlXG4gICAgICovXG4gICAgb2Zmc2V0PzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIElmIHNwZWNpZmllZCB0aGVuIHRoaXMgYXR0cmlidXRlcyBsZW5ndGggaXMgdG8gbWFrZVxuICAgICAqIGEgZGVmYXVsdCBkcmF3IGNhbGwgdXNpbmcgdGhpcyBkcmF3TW9kZVxuICAgICAqL1xuICAgIGRyYXdNb2RlPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIFVuaWZvcm0gYmluZGluZy5cbiAqL1xuaW50ZXJmYWNlIElVbmlmb3JtQmluZGluZyB7XG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgdW5pZm9ybVxuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIHRoZSB1bmlmb3JtXG4gICAgICovXG4gICAgdmFsdWVUeXBlPzogV2ViR0xWYXJUeXBlO1xufVxuXG4vKipcbiAqIEJpbmRpbmcgZm9yIGluZGV4IGFycmF5LlxuICovXG5pbnRlcmZhY2UgSW5kZXhCaW5kaW5nIHtcbiAgICAvKipcbiAgICAgKiBOYW1lIHVuZGVyIHdoaWNoIHRoZSBpbmRleCBhcnJheSB3aWxsIGJlIHBhc3NlZCBpblxuICAgICAqIHRvIHRoZSBbW1NoYWRlclByb2dyYW0ucnVuXV0gY2FsbFxuICAgICAqL1xuICAgIHZhbHVlTmFtZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllZCB0aGUgZHJhd21vZGUgZm9yIHRoZSBgZ2wuZHJhd0VsZW1lbnRzYCBjYWxsXG4gICAgICovXG4gICAgZHJhd01vZGU/OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBJQmluZGluZ3Mge1xuICAgIC8qKlxuICAgICAqIEJpbmRpbmdzIGZvciB1bmlmb3Jtc1xuICAgICAqL1xuICAgIHVuaWZvcm1zPzoge1tuYW1lOiBzdHJpbmddOiBJVW5pZm9ybUJpbmRpbmd9O1xuICAgIC8qKlxuICAgICAqIEJpbmRpbmdzIGZvciBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgYXR0cmlicz86IHtbbmFtZTogc3RyaW5nXTogSUF0dHJpYnV0ZUJpbmRpbmd9O1xuICAgIC8qKlxuICAgICAqIEluZGV4IGFycmF5IGJpbmRpbmdcbiAgICAgKi9cbiAgICBpbmRleD86IEluZGV4QmluZGluZztcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBbW1NoYWRlclByb2dyYW1dXVxuICpcbiAqIENvbW1vbiBmdW5jdGlvbnMsIHZhcmlhYmxlcyBhbmQgY29uc3RhbnRzIGF2aWFsYWJsZSBpblxuICogYm90aCBmcmFnbWVudCBhbmQgdmVydGV4IHNoYWRlcnM6XG4gKlxuICogKyBgUElgOiBUaGUgY29uc3RhbnQgcGlcbiAqICsgYHVfcmVzb2x1dGlvbmA6IGEgYHZlYzJgIHdpdGggdGhlIGZyYW1lJ3Mgd2lkdGggYW5kIGhlaWdodFxuICogKyBgdV9zcmNUZXh0dXJlYDogd2hlbiBgc3dhcEZyYW1lYCBpcyB0cnVlIHRoZW4gdGhpcyBpcyBhXG4gKiAgIHJlZmVyZW5jZSB0byB0aGUgcHJldmlvdXMgdGV4dHVyZVxuICogKyBgZ2V0U3JjQ29sb3JBdFBvcyh2ZWMyIHBvcylgOiB3aGVuIGBzd2FwRnJhbWVgIGlzIHRydWUsIHRoaXMgZ2l2ZXNcbiAqICAgdGhlIGNvbG9yIGF0IGdpdmVuIHBvc2l0aW9uIGluIHRoZSBwcmV2aW91cyB0ZXh0dXJlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSVNoYWRlck9wdHM8VmFsdWVUeXBlID0gYW55PiB7XG4gICAgLyoqXG4gICAgICogU291cmNlIGZvciBmcmFnbWVudCBzaGFkZXIuXG4gICAgICpcbiAgICAgKiB2YXJpYWJsZXMgYW5kIGZ1bmN0aW9ucyBhdmFpbGFibGUgaW4gZnJhZ21lbnQgc2hhZGVyczpcbiAgICAgKiArIGB2X3Bvc2l0aW9uYDogYSBbMC0xLDAtMV0gdmFyeWluZyBvZiB0aGUgcG9zaXRpb25cbiAgICAgKiArIGBnZXRTcmNDb2xvcigpYDogZXF1aXZhbGVudCB0byBgZ2V0U3JjQ29sb3JBdFBvcyh2X3Bvc2l0aW9uKWBcbiAgICAgKiArIGBzZXRGcmFnQ29sb3IodmVjMyBjb2xvcilgOiBzZXRzIGdsX0ZyYWdDb2xvciB3aXRoIGNvcnJlY3QgYmxlbmRpbmdcbiAgICAgKi9cbiAgICBmcmFnbWVudFNoYWRlcjogc3RyaW5nIHwgc3RyaW5nW107XG4gICAgLyoqXG4gICAgICogU291cmNlIGZvciB2ZXJ0ZXggc2hhZGVyLiBJZiBubyB2ZXJ0ZXggc2hhZGVyIGlzIHByb3ZpZGVkIHRoZW4gYVxuICAgICAqIGEgZGVmYXVsdCB2ZXJ0ZXggc2hhZGVyIHdpdGggc3F1YXJlR2VvbWV0cnkgdmFsdWVzIGlzIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogdmFyaWFibGVzIGFuZCBmdW5jdGlvbnMgYXZhaWxhYmxlIGluIGZyYWdtZW50IHNoYWRlcnM6XG4gICAgICogKyBgdl9wb3NpdGlvbmA6IGEgWzAtMSwwLTFdIHZhcnlpbmcgb2YgdGhlIHBvc2l0aW9uXG4gICAgICogKyBgc2V0UG9zaXRpb24odmVjMiBwb3NpdGlvbilgOiBjb3JyZWN0bHkgc2V0cyB0aGUgYGdsX3Bvc2l0aW9uYFxuICAgICAqL1xuICAgIHZlcnRleFNoYWRlcj86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgZGVmYXVsdCBibGVuZCBtb2RlIGZvciB0aGlzIHNoYWRlci5cbiAgICAgKi9cbiAgICBibGVuZE1vZGU/OiBCbGVuZE1vZGU7XG4gICAgLyoqXG4gICAgICogSWYgZW5hYmxlZCB0aGVuIGV2ZXJ5dGltZSB0aGlzIHNoYWRlciBpcyBydW4sIHdlIGN5Y2xlIHRvIG5leHQgZnJhbWVcbiAgICAgKiBpbiB0aGUgVGV4dHVyZVNldE1hbmFnZXIgdGhhdCdzIHBhc3NlZCBpbiB0byB0aGUgcnVuIGNhbGwuIFRoZSBzaGFkZXJcbiAgICAgKiBwcm9ncmFtIG1heSBhbHNvIGNob29zZSB0byBkbyB0aGlzIGlmIGEgYmxlbmRNb2RlIGlzIG5vdCBzdXBwb3J0ZWQgYnlcbiAgICAgKiBgZ2wuQmxlbmRGdW5jYFxuICAgICAqL1xuICAgIHN3YXBGcmFtZT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSWYgZW5hYmxlZCwgdGhlbiBpbW1lZGlhdGVseSBhZnRlciBhIGZyYW1lIHN3YXAgb24gdGhlIFRleHR1cmVTZXRNYW5hZ2VyXG4gICAgICogd2UgYWxzbyBjb3B5IHRoZSBwcmV2aW91cyBmcmFtZSBpbnRvIGN1cnJlbnQgZnJhbWVcbiAgICAgKi9cbiAgICBjb3B5T25Td2FwPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBJZiBlbmFibGVkIHRoZW4gZGVmYXVsdCBibGVuZE1vZGUgaXMgbm90IGJha2VkIGludG8gdGhlIHNoYWRlclxuICAgICAqIGFuZCBibGVuZE1vZGUgY2FuIGJlIHNldCBvbiBbW1NoYWRlclByb2dyYW0ucnVuXV0gY2FsbFxuICAgICAqL1xuICAgIGR5bmFtaWNCbGVuZD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBibGVuZFZhbHVlIHdoZW4gZGVmYXVsdEJsZW5kIG1vZGUgaXMgYEFESlVTVEFCTEVgXG4gICAgICovXG4gICAgYmxlbmRWYWx1ZT86IDAuNTtcbiAgICAvKipcbiAgICAgKiBWYXJpYWJsZSBiaW5kaW5ncyBmb3IgdGhlIHNoYWRlci5cbiAgICAgKi9cbiAgICBiaW5kaW5ncz86IElCaW5kaW5ncztcbiAgICAvKipcbiAgICAgKiBBIGhvb2sgZnVuY3Rpb24gdGhhdCdkIGNhbGxlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGRyYXcgY2FsbCBiZWhhdmlvci5cbiAgICAgKiBkcmF3SG9vayBjYW4gYWxzbyByZXR1cm4gYSBmYWxzeSB2YWx1ZSB0byBpbmRpY2F0ZSB0aGF0IGRyYXcgaGFzIG5vdCBiZWVuXG4gICAgICogaGFuZGxlZCwgY2F1c2luZyB0aGUgc2hhZGVyIHRvIGZhbGxiYWNrIHRvIGRlZmF1bHQgZHJhdyBjYWxsIGJlaGF2aW9yLlxuICAgICAqL1xuICAgIGRyYXdIb29rPzogKHZhbHVlczogVmFsdWVUeXBlLCBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBzaGFkZXI6IFNoYWRlclByb2dyYW0pID0+IGFueTtcbn1cblxuLyoqXG4gKiBTaGFkZXJQcm9ncmFtIGlzIGFuIGFic3RyYWN0aW9uIGZvciBTaGFkZXJzIFByb2dyYW1zIHRoYXQgcHJvdmlkZXMsXG4gKiBibGVuZGVkIG91dHB1dCwgZWFzaWVyIHZhcmlhYmxlIGJpbmRpbmdzIGFuZCBvdGhlciBuaWNlIGZlYXR1cmVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFkZXJQcm9ncmFtPFZhbHVlVHlwZSA9IGFueT4ge1xuICAgIC8vIHRoZXNlIGFyZSBibGVuZCBtb2RlcyBub3Qgc3VwcG9ydGVkIHdpdGggZ2wuQkxFTkRcbiAgICAvLyBhbmQgdGhlIGZvcm11bGEgdG8gYmUgdXNlZCBpbnNpZGUgc2hhZGVyXG4gICAgcHJpdmF0ZSBzdGF0aWMgc2hhZGVyQmxlbmRFcSA9IHtcbiAgICAgICAgW0JsZW5kTW9kZS5NQVhJTVVNXTogXCJtYXgoY29sb3IsIHRleHR1cmUyRCh1X3NyY1RleHR1cmUsIHZfcG9zaXRpb24pKVwiLFxuICAgICAgICBbQmxlbmRNb2RlLk1VTFRJUExZXTogXCJjbGFtcChjb2xvciAqIHRleHR1cmUyRCh1X3NyY1RleHR1cmUsIHZfcG9zaXRpb24pICogMjU2LjAsIDAuMCwgMS4wKVwiLFxuICAgIH07XG5cbiAgICBwcml2YXRlIHJjdHg6IFJlbmRlcmluZ0NvbnRleHQ7XG4gICAgcHJpdmF0ZSBzd2FwRnJhbWU6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBjb3B5T25Td2FwOiBib29sZWFuO1xuICAgIHByaXZhdGUgYmxlbmRWYWx1ZTogbnVtYmVyO1xuICAgIHByaXZhdGUgYmxlbmRNb2RlOiBCbGVuZE1vZGU7XG4gICAgcHJpdmF0ZSBkeW5hbWljQmxlbmQ6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBmcmFnbWVudFNyYzogc3RyaW5nO1xuICAgIHByaXZhdGUgdmVydGV4U3JjOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBmcmFnbWVudDogV2ViR0xTaGFkZXI7XG4gICAgcHJpdmF0ZSB2ZXJ0ZXg6IFdlYkdMU2hhZGVyO1xuICAgIHByaXZhdGUgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xuICAgIHByaXZhdGUgZHJhd0hvb2s6ICh2YWx1ZXM6IFZhbHVlVHlwZSwgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgc2hhZGVyOiBTaGFkZXJQcm9ncmFtKSA9PiBhbnk7XG4gICAgcHJpdmF0ZSBiaW5kaW5nczogSUJpbmRpbmdzO1xuICAgIHByaXZhdGUgbG9jYXRpb25zOiB7W2tleTogc3RyaW5nXTogbnVtYmVyIHwgV2ViR0xVbmlmb3JtTG9jYXRpb259O1xuICAgIHByaXZhdGUgdGV4dHVyZVZhcnM6IHN0cmluZ1tdO1xuICAgIHByaXZhdGUgZW5hYmxlZEF0dHJpYnM6IG51bWJlcltdO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzaGFkZXIgYW5kIGNvbXBpbGVzIHRoZSBzb3VyY2VcbiAgICAgKiBAcGFyYW0gcmN0eCB0aGUgcmVuZGVyaW5nIGNvbnRleHQgdW5kZXIgd2hpY2ggdGhlIHNoYWRlciBwcm9ncmFtIHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIEBwYXJhbSBvcHRzIHNoYWRlciBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmN0eDogUmVuZGVyaW5nQ29udGV4dCwgb3B0czogSVNoYWRlck9wdHM8VmFsdWVUeXBlPikge1xuICAgICAgICBvcHRzID0gZGVmYXVsdHMob3B0cywge1xuICAgICAgICAgICAgYmxlbmRNb2RlOiBCbGVuZE1vZGUuUkVQTEFDRSxcbiAgICAgICAgICAgIGJsZW5kVmFsdWU6IDAuNSxcbiAgICAgICAgICAgIGNvcHlPblN3YXA6IGZhbHNlLFxuICAgICAgICAgICAgZHluYW1pY0JsZW5kOiBmYWxzZSxcbiAgICAgICAgICAgIHN3YXBGcmFtZTogZmFsc2UsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHZzcmMgPSBbYFxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdl9wb3NpdGlvbjtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3NyY1RleHR1cmU7XG5cbiAgICAgICAgICAgICNkZWZpbmUgUEkgJHtNYXRoLlBJfVxuICAgICAgICAgICAgI2RlZmluZSBnZXRTcmNDb2xvckF0UG9zKHBvcykgKHRleHR1cmUyRCh1X3NyY1RleHR1cmUsIHBvcykpXG4gICAgICAgICAgICAjZGVmaW5lIHNldFBvc2l0aW9uKHBvcykgKHZfcG9zaXRpb24gPSAoKChwb3MpKzEuMCkvMi4wKSxnbF9Qb3NpdGlvbiA9IHZlYzQoKHBvcyksIDAsIDEpKVxuICAgICAgICBgXTtcblxuICAgICAgICBjb25zdCBmc3JjID0gW2BcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZfcG9zaXRpb247XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9zcmNUZXh0dXJlO1xuXG4gICAgICAgICAgICAjZGVmaW5lIFBJICR7TWF0aC5QSX1cbiAgICAgICAgICAgICNkZWZpbmUgZ2V0U3JjQ29sb3JBdFBvcyhwb3MpICh0ZXh0dXJlMkQodV9zcmNUZXh0dXJlLCBwb3MpKVxuICAgICAgICAgICAgI2RlZmluZSBnZXRTcmNDb2xvcigpICh0ZXh0dXJlMkQodV9zcmNUZXh0dXJlLCB2X3Bvc2l0aW9uKSlcbiAgICAgICAgYF07XG5cbiAgICAgICAgdGhpcy5yY3R4ID0gcmN0eDtcbiAgICAgICAgdGhpcy5zd2FwRnJhbWUgPSBvcHRzLnN3YXBGcmFtZTtcbiAgICAgICAgdGhpcy5jb3B5T25Td2FwID0gb3B0cy5jb3B5T25Td2FwO1xuICAgICAgICB0aGlzLmJsZW5kVmFsdWUgPSBvcHRzLmJsZW5kVmFsdWU7XG4gICAgICAgIHRoaXMuYmxlbmRNb2RlID0gb3B0cy5ibGVuZE1vZGU7XG4gICAgICAgIHRoaXMuZHluYW1pY0JsZW5kID0gb3B0cy5keW5hbWljQmxlbmQ7XG5cbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY0JsZW5kKSB7XG4gICAgICAgICAgICBmc3JjLnB1c2goYFxuICAgICAgICAgICAgICAgIHVuaWZvcm0gaW50IHVfYmxlbmRNb2RlO1xuICAgICAgICAgICAgICAgIHZvaWQgc2V0RnJhZ0NvbG9yKHZlYzQgY29sb3IpIHtcbiAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgZWFjaChTaGFkZXJQcm9ncmFtLnNoYWRlckJsZW5kRXEsIChlcSwgbW9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGZzcmMucHVzaChgXG4gICAgICAgICAgICAgICAgICAgIGlmKHVfYmxlbmRNb2RlID09ICR7bW9kZX0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9ICgke2VxfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmc3JjLnB1c2goYFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2hhZGVyQmxlbmQodGhpcy5ibGVuZE1vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXEgPSBTaGFkZXJQcm9ncmFtLnNoYWRlckJsZW5kRXFbdGhpcy5ibGVuZE1vZGVdO1xuICAgICAgICAgICAgICAgIGZzcmMucHVzaChgI2RlZmluZSBzZXRGcmFnQ29sb3IoY29sb3IpIChnbF9GcmFnQ29sb3IgPSAoJHtlcX0pKWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmc3JjLnB1c2goXCIjZGVmaW5lIHNldEZyYWdDb2xvcihjb2xvcikgKGdsX0ZyYWdDb2xvciA9IGNvbG9yKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJhd0hvb2sgPSBvcHRzLmRyYXdIb29rO1xuICAgICAgICB0aGlzLnZlcnRleFNyYyA9IHZzcmMuam9pbihcIlxcblwiKSArIFwiXFxuXCI7XG4gICAgICAgIGlmIChvcHRzLnZlcnRleFNoYWRlcikge1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhTcmMgKz0gZmxhdFN0cmluZyhvcHRzLnZlcnRleFNoYWRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleFNyYyArPSBgXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgc2V0UG9zaXRpb24oYV9wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIGNvbnN0IG9sZERyYXdIb29rID0gdGhpcy5kcmF3SG9vaztcbiAgICAgICAgICAgIHRoaXMuZHJhd0hvb2sgPSAodmFsdWVzLCBnbCwgc2hhZGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZERyYXdIb29rKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZERyYXdIb29rKHZhbHVlcywgZ2wsIHNoYWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmliKFwiYV9wb3NpdGlvblwiLCBzcXVhcmVHZW9tZXRyeSh0aGlzLnJjdHgpKTtcbiAgICAgICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgNik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mcmFnbWVudFNyYyA9IGZzcmMuam9pbihcIlxcblwiKSArIFwiXFxuXCIgKyBmbGF0U3RyaW5nKG9wdHMuZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgICB0aGlzLmxvY2F0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLnRleHR1cmVWYXJzID0gW107XG4gICAgICAgIHRoaXMuZW5hYmxlZEF0dHJpYnMgPSBbXTtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IG9wdHMuYmluZGluZ3MgfHwge307XG5cbiAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIHNoYWRlciBwcm9ncmFtXG4gICAgICogQHBhcmFtIHRzbSB0aGUgdGV4dHVyZSBzZXQgaW4gd2hpY2ggdGhlIHJlbmRlcmluZyB3aWxsIGJlIG1hZGVcbiAgICAgKiBAcGFyYW0gdmFsdWVzIGFuIG9iamVjdCBjb250YWluaW5nIHZhbHVlcyBmb3IgdmFyaWFibGVzIHNwZWNpZmllZCBpbiB0aGUgYmluZGluZ3NcbiAgICAgKiBAcGFyYW0gYmxlbmRNb2RlIHRoZSBibGVuZE1vZGUgZm9yIHRoaXMgcmVuZGVyXG4gICAgICogQHBhcmFtIGJsZW5kVmFsdWUgYmxlbmRWYWx1ZSB3aGVuIGJsZW5kTW9kZSBpcyBgQURKVVNUQUJMRWBcbiAgICAgKi9cbiAgICBwdWJsaWMgcnVuKHRzbTogVGV4dHVyZVNldE1hbmFnZXIsIHZhbHVlczogVmFsdWVUeXBlLCBibGVuZE1vZGU6IEJsZW5kTW9kZSA9IG51bGwsIGJsZW5kVmFsdWU6IG51bWJlciA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnJjdHguZ2V0R2woKTtcbiAgICAgICAgY29uc3Qgb2xkUHJvZ3JhbSA9IGdsLmdldFBhcmFtZXRlcihnbC5DVVJSRU5UX1BST0dSQU0pO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG5cbiAgICAgICAgaWYgKGJsZW5kTW9kZSAmJiAhdGhpcy5keW5hbWljQmxlbmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgYmxlbmRtb2RlIGF0IHJ1bnRpbWUuIFVzZSBkeW5hbWljQmxlbmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYmxlbmRNb2RlID0gYmxlbmRNb2RlIHx8IHRoaXMuYmxlbmRNb2RlO1xuICAgICAgICBibGVuZFZhbHVlID0gdHlwZW9mKGJsZW5kVmFsdWUpID09PSBcIm51bWJlclwiID8gYmxlbmRWYWx1ZSA6IHRoaXMuYmxlbmRWYWx1ZTtcblxuICAgICAgICBpZiAodHNtKSB7XG4gICAgICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1X3Jlc29sdXRpb25cIiwgV2ViR0xWYXJUeXBlLl8yRiwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN3YXBGcmFtZSB8fCB0aGlzLl9pc1NoYWRlckJsZW5kKGJsZW5kTW9kZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1X3NyY1RleHR1cmVcIiwgV2ViR0xWYXJUeXBlLlRFWFRVUkUyRCwgdHNtLmdldEN1cnJlbnRUZXh0dXJlKCkpO1xuICAgICAgICAgICAgICAgIHRzbS5zd2l0Y2hUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29weU9uU3dhcCkge1xuICAgICAgICAgICAgICAgICAgICB0c20uY29weU92ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZHluYW1pY0JsZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidV9zcmNUZXh0dXJlXCIsIFdlYkdMVmFyVHlwZS5URVhUVVJFMkQsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY0JsZW5kKSB7XG4gICAgICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1X2JsZW5kTW9kZVwiLCBXZWJHTFZhclR5cGUuXzFJLCBibGVuZE1vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0R2xCbGVuZE1vZGUoYmxlbmRNb2RlLCBibGVuZFZhbHVlKTtcbiAgICAgICAgdGhpcy5kcmF3KHZhbHVlcyk7XG4gICAgICAgIC8vIGRpc2FibGUgYWxsIGVuYWJsZWQgYXR0cmlidXRlc1xuICAgICAgICB3aGlsZSAodGhpcy5lbmFibGVkQXR0cmlicy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmVuYWJsZWRBdHRyaWJzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgICAgICBnbC51c2VQcm9ncmFtKG9sZFByb2dyYW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIGEgdW5pZm9ybSBvciBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBMb2NhdGlvbnMgYXJlIGNhY2hlZFxuICAgICAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIHZhcmlhYmxlXG4gICAgICogQHBhcmFtIGF0dHJpYiBpZiB0cnVlIHRoZW4gbmFtZSBpcyBhc3N1bWVkIHRvIGJlIGFuIGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRMb2NhdGlvbihuYW1lOiBzdHJpbmcsIGF0dHJpYjogYm9vbGVhbiA9IGZhbHNlKTogbnVtYmVyIHwgV2ViR0xVbmlmb3JtTG9jYXRpb24ge1xuICAgICAgICBsZXQgbG9jYXRpb24gPSB0aGlzLmxvY2F0aW9uc1tuYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnJjdHguZ2V0R2woKTtcbiAgICAgICAgICAgIGlmIChhdHRyaWIpIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uc1tuYW1lXSA9IGxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhIHRleHR1cmUuIEFzc2lnbnMgaWQgaWYgbm90IGFscmVhZHkgYXNzaWduZWQuXG4gICAgICogQHBhcmFtIG5hbWUgbmFtZSBvZiB0aGUgdGV4dHVyZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRUZXh0dXJlSWQobmFtZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGlkID0gaW5kZXhPZih0aGlzLnRleHR1cmVWYXJzLCBuYW1lKTtcbiAgICAgICAgaWYgKGlkID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlVmFycy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgaWQgPSB0aGlzLnRleHR1cmVWYXJzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIHZhbHVlIG9mIGEgdW5pZm9ybSB2YXJpYWJsZSBpbiB0aGlzIHByb2dyYW0uXG4gICAgICogQHBhcmFtIG5hbWUgbmFtZSBvZiB0aGUgdW5pZm9ybWEgdmFyaWFibGVcbiAgICAgKiBAcGFyYW0gdHlwZSB0eXBlIG9mIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB2YWx1ZXMgdmFsdWUocykgdG8gYmUgYm91bmRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0VW5pZm9ybShuYW1lOiBzdHJpbmcsIHR5cGU6IFdlYkdMVmFyVHlwZSwgLi4udmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nZXRMb2NhdGlvbihuYW1lKTtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnJjdHguZ2V0R2woKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dHVyZTJEXCI6XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLmdldFRleHR1cmVJZChuYW1lKTtcbiAgICAgICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsW1wiVEVYVFVSRVwiICsgaWRdKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB2YWx1ZXNbMF0pO1xuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgaWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIjFmXCI6IGNhc2UgXCIyZlwiOiBjYXNlIFwiM2ZcIjogY2FzZSBcIjRmXCI6XG4gICAgICAgICAgICBjYXNlIFwiMWlcIjogY2FzZSBcIjJpXCI6IGNhc2UgXCIzaVwiOiBjYXNlIFwiNGlcIjpcbiAgICAgICAgICAgICAgICBnbFtcInVuaWZvcm1cIiArIHR5cGVdLmFwcGx5KGdsLCBbbG9jYXRpb25dLmNvbmNhdCh2YWx1ZXMpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCIxZnZcIjogY2FzZSBcIjJmdlwiOiBjYXNlIFwiM2Z2XCI6IGNhc2UgXCI0ZnZcIjpcbiAgICAgICAgICAgIGNhc2UgXCIxaXZcIjogY2FzZSBcIjJpdlwiOiBjYXNlIFwiM2l2XCI6IGNhc2UgXCI0aXZcIjpcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdsW1widW5pZm9ybVwiICsgdHlwZV0uY2FsbChnbCwgbG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIGdpdmVuIGJ1ZmZlciBhcyB0aGUgYEVMRU1FTlRfQVJSQVlfQlVGRkVSYFxuICAgICAqIEBwYXJhbSBidWZmZXIgYnVmZmVyIHRvIGJlIGJvdW5kIGFzIGluZGV4XG4gICAgICovXG4gICAgcHVibGljIHNldEluZGV4KGJ1ZmZlcjogQnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5yY3R4LmdldEdsKCk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlci5nZXRHbEJ1ZmZlcigpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBhbiBhdHRyaWJ1dGUgYnVmZmVyIGFuZCBzZXRzIHVwIHZlcnRleCBwb2ludGVyXG4gICAgICogQHBhcmFtIG5hbWUgbmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICogQHBhcmFtIGJ1ZmZlciBidWZmZXIgdG8gYmUgYm91bmRcbiAgICAgKiBAcGFyYW0gc2l6ZSBzaXplIG9mIHZhbHVlc1xuICAgICAqIEBwYXJhbSB0eXBlIHR5cGUgb2YgdmFsdWVzXG4gICAgICogQHBhcmFtIG5vcm1hbGl6ZWQgZW5hYmxlcyBub3JtYWxpemF0aW9uIGZvciBpbnRlZ2Vyc1xuICAgICAqIEBwYXJhbSBzdHJpZGUgYXJyYXkgdmFsdWUgc3RyaWRlXG4gICAgICogQHBhcmFtIG9mZnNldCBvZmZzZXQgb2YgZmlyc3QgdmFsdWVcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0QXR0cmliKFxuICAgICAgICBuYW1lOiBzdHJpbmcsXG4gICAgICAgIGJ1ZmZlcjogQnVmZmVyLFxuICAgICAgICBzaXplOiBudW1iZXIgPSAyLFxuICAgICAgICB0eXBlOiBudW1iZXIgPSB0aGlzLnJjdHguZ2V0R2woKS5GTE9BVCxcbiAgICAgICAgbm9ybWFsaXplZDogYm9vbGVhbiA9IGZhbHNlLFxuICAgICAgICBzdHJpZGU6IG51bWJlciA9IDAsXG4gICAgICAgIG9mZnNldDogbnVtYmVyID0gMCxcbiAgICApIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnJjdHguZ2V0R2woKTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdldExvY2F0aW9uKG5hbWUsIHRydWUpIGFzIG51bWJlcjtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlci5nZXRHbEJ1ZmZlcigpKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihsb2NhdGlvbiwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQpO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XG4gICAgICAgIHRoaXMuZW5hYmxlZEF0dHJpYnMucHVzaChsb2NhdGlvbik7XG4gICAgfVxuXG4gICAgcHVibGljIGRpc2FibGVBdHRyaWIobmFtZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nZXRMb2NhdGlvbihuYW1lLCB0cnVlKSBhcyBudW1iZXI7XG4gICAgICAgIHRoaXMucmN0eC5nZXRHbCgpLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYWxsIHdlYmdsIHJlc291cmNlc1xuICAgICAqL1xuICAgIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMucmN0eC5nZXRHbCgpO1xuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleCk7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdtZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pc1NoYWRlckJsZW5kKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIChtb2RlIGluIFNoYWRlclByb2dyYW0uc2hhZGVyQmxlbmRFcSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY29tcGlsZSgpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnJjdHguZ2V0R2woKTtcbiAgICAgICAgY29uc3QgdmVydGV4ID0gdGhpcy5fY29tcGlsZVNoYWRlcih0aGlzLnZlcnRleFNyYywgZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5fY29tcGlsZVNoYWRlcih0aGlzLmZyYWdtZW50U3JjLCBnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgICAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4KTtcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50KTtcbiAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAgICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbSBsaW5rIEVycm9yOiBcIiArIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmVydGV4ID0gdmVydGV4O1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY29tcGlsZVNoYWRlcihzaGFkZXJTcmM6IHN0cmluZywgdHlwZTogbnVtYmVyKTogV2ViR0xTaGFkZXIge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMucmN0eC5nZXRHbCgpO1xuICAgICAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNyYyk7XG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgICAgIGxvZ1NoYWRlckVycm9yKHNoYWRlclNyYywgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNoYWRlciBjb21waWxhdGlvbiBFcnJvcjogXCIgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmF3KHZhbHVlczogVmFsdWVUeXBlKSB7XG4gICAgICAgIGNvbnN0IGVycm9ySWZOb3RCdWZmZXIgPSAodmFsdWUsIHZhbHVlTmFtZSk6IEJ1ZmZlciA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgXCIke3ZhbHVlTmFtZX1cIiBzaG91bGQgYmUgYSBCdWZmZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBiaW5kIHZhcmlhYmxlc1xuICAgICAgICBsZXQgaXNFbGVtZW50czogYm9vbGVhbiA9IGZhbHNlO1xuICAgICAgICBsZXQgZHJhd01vZGU6IG51bWJlciA9IG51bGw7XG4gICAgICAgIGxldCBkcmF3Q291bnQ6IG51bWJlciA9IG51bGw7XG5cbiAgICAgICAgZm9yIChjb25zdCBiaW5kaW5nVHlwZSBpbiB0aGlzLmJpbmRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoYmluZGluZ1R5cGUgPT09IFwiaW5kZXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZm4gPSB0aGlzLmJpbmRpbmdzW2JpbmRpbmdUeXBlXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZU5hbWUgPSBkZWZuLnZhbHVlTmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1t2YWx1ZU5hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4QnVmZmVyID0gZXJyb3JJZk5vdEJ1ZmZlcih2YWx1ZSwgdmFsdWVOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEluZGV4KGluZGV4QnVmZmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmbi5kcmF3TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBkcmF3Q291bnQgPSBpbmRleEJ1ZmZlci5nZXRMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICAgICAgZHJhd01vZGUgPSBkZWZuLmRyYXdNb2RlO1xuICAgICAgICAgICAgICAgICAgICBpc0VsZW1lbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWVOYW1lIGluIHRoaXMuYmluZGluZ3NbYmluZGluZ1R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5iaW5kaW5nc1tiaW5kaW5nVHlwZV0uaGFzT3duUHJvcGVydHkodmFsdWVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbdmFsdWVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmRpbmdUeXBlID09PSBcImF0dHJpYnNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmbiA9IHRoaXMuYmluZGluZ3NbYmluZGluZ1R5cGVdW3ZhbHVlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlQXR0cmliKGRlZm4ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYkJ1ZmZlciA9IGVycm9ySWZOb3RCdWZmZXIodmFsdWUsIHZhbHVlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm4ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmliQnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZuLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm4udmFsdWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZuLm5vcm1hbGl6ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZm4uc3RyaWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZuLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZuLmRyYXdNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdDb3VudCA9IGF0dHJpYkJ1ZmZlci5nZXRMZW5ndGgoKSAvIChkZWZuLnNpemUgfHwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdNb2RlID0gZGVmbi5kcmF3TW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IFwidW5pZm9ybXNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmbiA9IHRoaXMuYmluZGluZ3NbYmluZGluZ1R5cGVdW3ZhbHVlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFVuaWZvcm0oZGVmbi5uYW1lLCBkZWZuLnZhbHVlVHlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnJjdHguZ2V0R2woKTtcbiAgICAgICAgbGV0IGRyYXdIYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmRyYXdIb29rKSB7XG4gICAgICAgICAgICBkcmF3SGFuZGxlZCA9ICF0aGlzLmRyYXdIb29rKHZhbHVlcywgZ2wsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZHJhd0hhbmRsZWQpIHtcbiAgICAgICAgICAgIGlmIChkcmF3TW9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0VsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhkcmF3TW9kZSwgZHJhd0NvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhkcmF3TW9kZSwgMCwgZHJhd0NvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRyYXcgdW5oYW5kbGVkIGFuZCBubyBiaW5kaW5ncyBjb250YWluaW5nIGRyYXdNb2RlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX3NldEdsQmxlbmRNb2RlKG1vZGUsIGJsZW5kVmFsdWUpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnJjdHguZ2V0R2woKTtcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEJsZW5kTW9kZS5BRERJVElWRTpcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORSk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbihnbC5GVU5DX0FERCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJsZW5kTW9kZS5TVUJUUkFDVElWRTE6XG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb24oZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNUKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmxlbmRNb2RlLlNVQlRSQUNUSVZFMjpcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORSk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbihnbC5GVU5DX1NVQlRSQUNUKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmxlbmRNb2RlLkFMUEhBOlxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbihnbC5GVU5DX0FERCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJsZW5kTW9kZS5NVUxUSVBMWTI6XG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuRFNUX0NPTE9SLCBnbC5aRVJPKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmxlbmRNb2RlLkFESlVTVEFCTEU6XG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZENvbG9yKDAsIDAsIDAsIGJsZW5kVmFsdWUpO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhnbC5DT05TVEFOVF9BTFBIQSwgZ2wuT05FX01JTlVTX0NPTlNUQU5UX0FMUEhBKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmxlbmRNb2RlLkFWRVJBR0U6XG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgICAgICBnbC5ibGVuZENvbG9yKDAuNSwgMC41LCAwLjUsIDEpO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhnbC5DT05TVEFOVF9DT0xPUiwgZ2wuQ09OU1RBTlRfQ09MT1IpO1xuICAgICAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb24oZ2wuRlVOQ19BREQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gc2hhZGVyIGJsZW5kaW5nIGNhc2VzXG4gICAgICAgICAgICBjYXNlIEJsZW5kTW9kZS5SRVBMQUNFOlxuICAgICAgICAgICAgY2FzZSBCbGVuZE1vZGUuTVVMVElQTFk6XG4gICAgICAgICAgICBjYXNlIEJsZW5kTW9kZS5NQVhJTVVNOlxuICAgICAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJsZW5kIG1vZGUgXCIgKyBtb2RlICsgXCIgaW4gc2hhZGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3dlYmdsL1NoYWRlclByb2dyYW0udHMiLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheU1hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCBvdmVyUmVzdCBmcm9tICcuL19vdmVyUmVzdC5qcyc7XG5pbXBvcnQgc2V0VG9TdHJpbmcgZnJvbSAnLi9fc2V0VG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVJlc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VSZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VJc05hdGl2ZSBmcm9tICcuL19iYXNlSXNOYXRpdmUuanMnO1xuaW1wb3J0IGdldFZhbHVlIGZyb20gJy4vX2dldFZhbHVlLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TmF0aXZlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXROYXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL2ZvckVhY2guanMnXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZWFjaC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGJhc2VNYXAgZnJvbSAnLi9fYmFzZU1hcC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdXG4gKlxuICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICovXG5mdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL21hcC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBhc3NpZ25WYWx1ZSBmcm9tICcuL19hc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgYmFzZUFzc2lnblZhbHVlIGZyb20gJy4vX2Jhc2VBc3NpZ25WYWx1ZS5qcyc7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5T2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5T2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVVuYXJ5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVW5hcnkuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlkZW50aXR5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lkZW50aXR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNLZXkgZnJvbSAnLi9faXNLZXkuanMnO1xuaW1wb3J0IHN0cmluZ1RvUGF0aCBmcm9tICcuL19zdHJpbmdUb1BhdGguanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjYXN0UGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdFBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9LZXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RvS2V5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCB0b0Zpbml0ZSBmcm9tICcuL3RvRmluaXRlLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9JbnRlZ2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvSW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXEuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0luZGV4O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlUmVzdCBmcm9tICcuL19iYXNlUmVzdC5qcyc7XG5pbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5pbXBvcnQgaXNJdGVyYXRlZUNhbGwgZnJvbSAnLi9faXNJdGVyYXRlZUNhbGwuanMnO1xuaW1wb3J0IGtleXNJbiBmcm9tICcuL2tleXNJbi5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xudmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xO1xuICB2YXIgbGVuZ3RoID0gc291cmNlcy5sZW5ndGg7XG4gIHZhciBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICBsZW5ndGggPSAxO1xuICB9XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgdmFyIHByb3BzID0ga2V5c0luKHNvdXJjZSk7XG4gICAgdmFyIHByb3BzSW5kZXggPSAtMTtcbiAgICB2YXIgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytwcm9wc0luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1twcm9wc0luZGV4XTtcbiAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIChlcSh2YWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZGVmYXVsdHMuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1N5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYXJyYXlQdXNoIGZyb20gJy4vX2FycmF5UHVzaC5qcyc7XG5pbXBvcnQgaXNGbGF0dGVuYWJsZSBmcm9tICcuL19pc0ZsYXR0ZW5hYmxlLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGbGF0dGVuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRmxhdHRlbi5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZU1hdGNoZXMgZnJvbSAnLi9fYmFzZU1hdGNoZXMuanMnO1xuaW1wb3J0IGJhc2VNYXRjaGVzUHJvcGVydHkgZnJvbSAnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IHByb3BlcnR5IGZyb20gJy4vcHJvcGVydHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXRlcmF0ZWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJdGVyYXRlZS5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgZGlmZmVyZW5jZSBmcm9tIFwibG9kYXNoLWVzL2RpZmZlcmVuY2VcIjtcbmltcG9ydCBlYWNoIGZyb20gXCJsb2Rhc2gtZXMvZWFjaFwiO1xuaW1wb3J0IGZsYXR0ZW4gZnJvbSBcImxvZGFzaC1lcy9mbGF0dGVuXCI7XG5pbXBvcnQgZmxvdyBmcm9tIFwibG9kYXNoLWVzL2Zsb3dcIjtcbmltcG9ydCBpbnRlcnNlY3Rpb24gZnJvbSBcImxvZGFzaC1lcy9pbnRlcnNlY3Rpb25cIjtcbmltcG9ydCBpc0FycmF5IGZyb20gXCJsb2Rhc2gtZXMvaXNBcnJheVwiO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSBcImxvZGFzaC1lcy9pc0VxdWFsXCI7XG5pbXBvcnQgaXNOdW1iZXIgZnJvbSBcImxvZGFzaC1lcy9pc051bWJlclwiO1xuaW1wb3J0IGtleXMgZnJvbSBcImxvZGFzaC1lcy9rZXlzXCI7XG5pbXBvcnQgbWFwIGZyb20gXCJsb2Rhc2gtZXMvbWFwXCI7XG5pbXBvcnQgeyBkZWZhdWx0IGFzIHByIH0gZnJvbSBcImxvZGFzaC1lcy9wYXJ0aWFsUmlnaHRcIjtcbmltcG9ydCBwaWNrIGZyb20gXCJsb2Rhc2gtZXMvcGlja1wiO1xuaW1wb3J0IHRha2VSaWdodCBmcm9tIFwibG9kYXNoLWVzL3Rha2VSaWdodFwiO1xuaW1wb3J0IHVuaW9uIGZyb20gXCJsb2Rhc2gtZXMvdW5pb25cIjtcbmltcG9ydCB1bmlxIGZyb20gXCJsb2Rhc2gtZXMvdW5pcVwiO1xuaW1wb3J0IHZhbHVlcyBmcm9tIFwibG9kYXNoLWVzL3ZhbHVlc1wiO1xuaW1wb3J0IHtnbHNsRmxvYXRSZXByLCBub29wfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi9Bc3RcIjtcbmltcG9ydCBDb2RlSW5zdGFuY2UgZnJvbSBcIi4vQ29kZUluc3RhbmNlXCI7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gXCIuL0V4cHJHcmFtbWFyLnBlZ2pzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUNvbXBpbGVSZXN1bHQge1xuICAgIGNvZGVJbnN0OiBDb2RlSW5zdGFuY2U7XG4gICAgZ2xzbENvZGU6IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcGlsZUV4cHIoXG4gICAgY29kZVNyYzoge1tuYW1lOiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXX0sXG4gICAganNGdW5jczogc3RyaW5nW10gPSBbXSxcbiAgICBnbHNsRnVuY3M6IHN0cmluZ1tdID0gW10sXG4gICAgbm9uVW5pZm9ybXM6IHN0cmluZ1tdID0gW10sXG4pOiBJQ29tcGlsZVJlc3VsdCB7XG4gICAgY29uc3QgY29kZVN0cmluZ3M6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBjb2RlU3JjKSB7XG4gICAgICAgIGlmICghY29kZVNyYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvZGVTdHJpbmcgPSBjb2RlU3JjW25hbWVdO1xuICAgICAgICBpZiAoaXNBcnJheShjb2RlU3RyaW5nKSkge1xuICAgICAgICAgICAgY29kZVN0cmluZyA9IGNvZGVTdHJpbmcuam9pbihcIlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlU3RyaW5nLnRyaW0oKTtcbiAgICAgICAgaWYgKGNvZGVTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlU3RyaW5nc1tuYW1lXSA9IGNvZGVTdHJpbmc7XG4gICAgfVxuXG4gICAgLy8gMSkgUGFyc2UgdGhlIGNvZGVcbiAgICBjb25zdCBjb2RlQXN0ID0gcGFyc2VDb2RlKGNvZGVTdHJpbmdzKTtcbiAgICAvLyAyKSBQcm9jZXNzIHRoZSBBU1RcbiAgICBjb25zdCB0YWJsZXMgPSBwcm9jZXNzQXN0KGNvZGVBc3QsIGpzRnVuY3MsIGdsc2xGdW5jcywgbm9uVW5pZm9ybXMpO1xuICAgIC8vIDMpIEdlbmVyYXRlIGNvZGVcbiAgICBjb25zdCBjb2RlSW5zdCA9IGdlbmVyYXRlSnMoY29kZUFzdCwgdGFibGVzLCBqc0Z1bmNzKTtcbiAgICBjb25zdCBnbHNsQ29kZSA9IGdlbmVyYXRlR2xzbChjb2RlQXN0LCB0YWJsZXMsIGdsc2xGdW5jcyk7XG5cbiAgICByZXR1cm4ge2NvZGVJbnN0LCBnbHNsQ29kZX07XG59XG5cbmludGVyZmFjZSBJQ29kZUFzdCB7W25hbWU6IHN0cmluZ106IEFzdC5Qcm9ncmFtOyB9XG5cbmZ1bmN0aW9uIHBhcnNlQ29kZShjb2RlU3JjOiB7W25hbWU6IHN0cmluZ106IHN0cmluZ30pOiBJQ29kZUFzdCB7XG4gICAgY29uc3QgY29kZUFzdDogSUNvZGVBc3QgPSB7fTsgLy8gYWJzdHJhY3Qgc3ludGF4IHRyZWVcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gY29kZVNyYykge1xuICAgICAgICBpZiAoIWNvZGVTcmMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb2RlQXN0W25hbWVdID0gcGFyc2UoY29kZVNyY1tuYW1lXSkgYXMgQXN0LlByb2dyYW07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHBhcnNpbmcgXCIgKyBuYW1lICsgXCIgKFwiICsgZS5saW5lICsgXCI6XCIgKyBlLmNvbHVtbiArIFwiKVwiICsgXCIgOiBcIiArIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2RlQXN0O1xufVxuXG5mdW5jdGlvbiBpc1N0YXRpY0V4cHJMaXN0KGV4cHJzOiBBc3QuRXhwcmVzc2lvbltdKTogZXhwcnMgaXMgQXN0LlByaW1hcnlFeHByW10ge1xuICAgIHJldHVybiBleHBycy5ldmVyeSgoZXhwcikgPT4ge1xuICAgICAgICByZXR1cm4gZXhwciBpbnN0YW5jZW9mIEFzdC5QcmltYXJ5RXhwcjtcbiAgICB9KTtcbn1cblxuaW50ZXJmYWNlIElTeW1ib2xUYWJsZXMge1xuICAgIHJlZ2lzdGVyOiB7W25hbWU6IHN0cmluZ106IHN0cmluZ1tdfTtcbiAgICBwcmVDb21wdXRlOiB7W3VuaWZvcm1OYW1lOiBzdHJpbmddOiBzdHJpbmdbXX07XG4gICAganNWYXJzOiBzdHJpbmdbXTtcbiAgICBnbHNsVmFyczogc3RyaW5nW107XG4gICAgbm9uVW5pZm9ybXM6IHN0cmluZ1tdO1xuICAgIHVuaWZvcm1zOiBzdHJpbmdbXTtcbiAgICBnbHNsVXNlZEZ1bmNzOiBzdHJpbmdbXTtcbiAgICBnbHNsUmVnaXN0ZXJzOiBzdHJpbmdbXTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0FzdChcbiAgICBjb2RlQXN0OiBJQ29kZUFzdCxcbiAgICBqc0Z1bmNzOiBzdHJpbmdbXSxcbiAgICBnbHNsRnVuY3M6IHN0cmluZ1tdLFxuICAgIGV4dHJhTm9uVW5pZm9ybXM6IHN0cmluZ1tdLFxuKTogSVN5bWJvbFRhYmxlcyB7XG4gICAgY29uc3QgZnVuY0NhbGw6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nW119ID0ge307XG4gICAgY29uc3QgdmFyaWFibGU6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nW119ID0ge307XG4gICAgY29uc3QgcmVnaXN0ZXI6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nW119ID0ge307XG4gICAgY29uc3QgcHJlQ29tcHV0ZToge1t1bmlmb3JtTmFtZTogc3RyaW5nXTogc3RyaW5nW119ID0ge307XG5cbiAgICBsZXQgcHJlQ29tcHV0ZUNvdW50ZXIgPSAwO1xuXG4gICAgY29uc3QgcHJvY2Vzc05vZGUgPSAoYXN0LCBuYW1lKSA9PiB7XG4gICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBBc3QuUHJvZ3JhbSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdGF0ZW1lbnQgb2YgYXN0LnN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzTm9kZShzdGF0ZW1lbnQsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIEFzdC5CaW5hcnlFeHByKSB7XG4gICAgICAgICAgICBwcm9jZXNzTm9kZShhc3QubGVmdE9wZXJhbmQsIG5hbWUpO1xuICAgICAgICAgICAgcHJvY2Vzc05vZGUoYXN0LnJpZ2h0T3BlcmFuZCwgbmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXN0IGluc3RhbmNlb2YgQXN0LlVuYXJ5RXhwcikge1xuICAgICAgICAgICAgcHJvY2Vzc05vZGUoYXN0Lm9wZXJhbmQsIG5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIEFzdC5GdW5jQ2FsbCkge1xuICAgICAgICAgICAgY2hlY2tGdW5jKGFzdCk7XG5cbiAgICAgICAgICAgIC8vIGlmIGl0cyBhIHByZWNvbXB1dGFibGUgZnVuY3Rpb24gdG8gYmUgZ2VuZXJhdGVkIGluIGdsc2xcbiAgICAgICAgICAgIC8vIHRoZW4gYnVpbGQgYSB0YWJsZSBlbnRyeVxuICAgICAgICAgICAgaWYgKGdsc2xGdW5jcy5pbmRleE9mKG5hbWUpID49IDAgJiYgZ2xzbFByZUNvbXB1dGVGdW5jcy5pbmRleE9mKGFzdC5mdW5jTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBhc3QuYXJncztcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RhdGljRXhwckxpc3QoYXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgYE5vbiBQcmUtQ29tcHV0YWJsZSBhcmd1bWVudHMgZm9yICR7YXN0LmZ1bmNOYW1lfSBpbiBzaGFkZXIgY29kZSwgdXNlIHZhcmlhYmxlcyBvciBjb25zdGFudHNgLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IFthc3QuZnVuY05hbWVdLmNvbmNhdChtYXAoYXJncywgKGFyZykgPT4gYXJnLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgbGV0IHVuaWZvcm1OYW1lO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByZUNvbXB1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXF1YWwocHJlQ29tcHV0ZVtrZXldLCBlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWZvcm1OYW1lID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF1bmlmb3JtTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlmb3JtTmFtZSA9IFwiX19QQ19cIiArICBhc3QuZnVuY05hbWUgKyBcIl9cIiArIHByZUNvbXB1dGVDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgIHByZUNvbXB1dGVbdW5pZm9ybU5hbWVdID0gZW50cnk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXN0LnByZUNvbXB1dGVVbmlmb3JtTmFtZSA9IHVuaWZvcm1OYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jQ2FsbFtuYW1lXS5wdXNoKGFzdC5mdW5jTmFtZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBhc3QuYXJncykge1xuICAgICAgICAgICAgICAgcHJvY2Vzc05vZGUoYXJnLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChhc3QgaW5zdGFuY2VvZiBBc3QuQXNzaWdubWVudCkge1xuICAgICAgICAgICAgcHJvY2Vzc05vZGUoYXN0LmxocywgbmFtZSk7XG4gICAgICAgICAgICBwcm9jZXNzTm9kZShhc3QuZXhwciwgbmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXN0IGluc3RhbmNlb2YgQXN0LlByaW1hcnlFeHByICYmIGFzdC50eXBlID09PSBcIklEXCIpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlW25hbWVdLnB1c2goYXN0LnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChhc3QgaW5zdGFuY2VvZiBBc3QuUHJpbWFyeUV4cHIgJiYgYXN0LnR5cGUgPT09IFwiUkVHXCIpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyW25hbWVdLnB1c2goYXN0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gY29kZUFzdCkge1xuICAgICAgICBpZiAoIWNvZGVBc3QuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmNDYWxsW25hbWVdID0gW107XG4gICAgICAgIHZhcmlhYmxlW25hbWVdID0gW107XG4gICAgICAgIHJlZ2lzdGVyW25hbWVdID0gW107XG5cbiAgICAgICAgcHJvY2Vzc05vZGUoY29kZUFzdFtuYW1lXSwgbmFtZSk7XG5cbiAgICAgICAgZnVuY0NhbGxbbmFtZV0gPSB1bmlxKGZ1bmNDYWxsW25hbWVdKTtcbiAgICAgICAgdmFyaWFibGVbbmFtZV0gPSB1bmlxKHZhcmlhYmxlW25hbWVdKTtcbiAgICAgICAgcmVnaXN0ZXJbbmFtZV0gPSB1bmlxKHJlZ2lzdGVyW25hbWVdKTtcbiAgICB9XG5cbiAgICBjb25zdCBqc1ZhcnM6IHN0cmluZ1tdID0gZmxvdyhbcHIocGljaywganNGdW5jcyksIHZhbHVlcywgZmxhdHRlbiwgdW5pcV0pKHZhcmlhYmxlKTtcbiAgICBjb25zdCBnbHNsVmFyczogc3RyaW5nW10gPSBmbG93KFtwcihwaWNrLCBnbHNsRnVuY3MpLCB2YWx1ZXMsIGZsYXR0ZW4sIHVuaXFdKSh2YXJpYWJsZSk7XG4gICAgY29uc3Qgbm9uVW5pZm9ybXM6IHN0cmluZ1tdID0gZmxvdyhbcHIoZGlmZmVyZW5jZSwganNWYXJzKSwgcHIodW5pb24sIGV4dHJhTm9uVW5pZm9ybXMpLCB1bmlxXSkoZ2xzbFZhcnMpO1xuICAgIGNvbnN0IHVuaWZvcm1zOiBzdHJpbmdbXSAgPSBpbnRlcnNlY3Rpb24oZ2xzbFZhcnMsIGpzVmFycyk7XG4gICAgY29uc3QgZ2xzbFVzZWRGdW5jczogc3RyaW5nW10gPSBmbG93KFtwcihwaWNrLCBnbHNsRnVuY3MpLCB2YWx1ZXMsIGZsYXR0ZW4sIHVuaXFdKShmdW5jQ2FsbCk7XG4gICAgY29uc3QgZ2xzbFJlZ2lzdGVyczogc3RyaW5nW10gPSBmbG93KFtwcihwaWNrLCBnbHNsRnVuY3MpLCB2YWx1ZXMsIGZsYXR0ZW4sIHVuaXFdKShyZWdpc3Rlcik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnbHNsUmVnaXN0ZXJzLCBnbHNsVXNlZEZ1bmNzLCBnbHNsVmFycywganNWYXJzLCBub25Vbmlmb3JtcywgcHJlQ29tcHV0ZSwgcmVnaXN0ZXIsIHVuaWZvcm1zLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlSnMoY29kZUFzdDogSUNvZGVBc3QsIHRhYmxlczogSVN5bWJvbFRhYmxlcywganNGdW5jczogc3RyaW5nW10pOiBDb2RlSW5zdGFuY2Uge1xuICAgIGNvbnN0IGdlbmVyYXRlTm9kZSA9IChhc3QpID0+IHtcbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIEFzdC5CaW5hcnlFeHByKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIoXCIgKyBnZW5lcmF0ZU5vZGUoYXN0LmxlZnRPcGVyYW5kKSArIGFzdC5vcGVyYXRvciArIGdlbmVyYXRlTm9kZShhc3QucmlnaHRPcGVyYW5kKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBBc3QuVW5hcnlFeHByKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIoXCIgKyBhc3Qub3BlcmF0b3IgKyBnZW5lcmF0ZU5vZGUoYXN0Lm9wZXJhbmQpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIEFzdC5GdW5jQ2FsbCkge1xuICAgICAgICAgICAgc3dpdGNoIChhc3QuZnVuY05hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYWJvdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiKFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVOb2RlKGFzdC5hcmdzWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVOb2RlKGFzdC5hcmdzWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPzE6MClcIixcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJiZWxvd1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU5vZGUoYXN0LmFyZ3NbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCI8XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU5vZGUoYXN0LmFyZ3NbMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCI/MTowKVwiLFxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVxdWFsXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIihcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTm9kZShhc3QuYXJnc1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcIj09XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU5vZGUoYXN0LmFyZ3NbMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCI/MTowKVwiLFxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImlmXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIihcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTm9kZShhc3QuYXJnc1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiE9PTA/XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU5vZGUoYXN0LmFyZ3NbMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCI6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU5vZGUoYXN0LmFyZ3NbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIpXCIsXG4gICAgICAgICAgICAgICAgICAgIF0uam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBbXCIoKGZ1bmN0aW9uKCkge1wiXTtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5wdXNoKFwic3dpdGNoKFwiICsgZ2VuZXJhdGVOb2RlKGFzdC5hcmdzWzBdKSArIFwiKSB7XCIpO1xuICAgICAgICAgICAgICAgICAgICBlYWNoKHRha2VSaWdodChhc3QuYXJncywgYXN0LmFyZ3MubGVuZ3RoIC0gMSksIChhcmcsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUucHVzaChcImNhc2UgXCIgKyBpICsgXCI6IHJldHVybiBcIiArIGdlbmVyYXRlTm9kZShhcmcpICsgXCI7XCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5wdXNoKFwiZGVmYXVsdCA6IHRocm93IG5ldyBFcnJvcignVW5rbm93biBzZWxlY3RvciB2YWx1ZSBpbiBzZWxlY3QnKTtcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUucHVzaChcIn19KS5jYWxsKHRoaXMpKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3FyXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIihNYXRoLnBvdygoXCIgKyBnZW5lcmF0ZU5vZGUoYXN0LmFyZ3NbMF0pICsgXCIpLDIpKVwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJiYW5kXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIigoKFwiICsgZ2VuZXJhdGVOb2RlKGFzdC5hcmdzWzBdKSArIFwiKSYmKFwiICsgZ2VuZXJhdGVOb2RlKGFzdC5hcmdzWzFdKSArIFwiKSk/MTowKVwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib3JcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiKCgoXCIgKyBnZW5lcmF0ZU5vZGUoYXN0LmFyZ3NbMF0pICsgXCIpfHwoXCIgKyBnZW5lcmF0ZU5vZGUoYXN0LmFyZ3NbMV0pICsgXCIpKT8xOjApXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJub3RcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiKCghKFwiICsgZ2VuZXJhdGVOb2RlKGFzdC5hcmdzWzBdKSArIFwiKSk/MTowKVwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpbnZzcXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIigxL01hdGguc3FydChcIiArIGdlbmVyYXRlTm9kZShhc3QuYXJnc1swXSkgKyBcIikpXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcImF0YW4yXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIihNYXRoLmF0YW4oKFwiICsgZ2VuZXJhdGVOb2RlKGFzdC5hcmdzWzBdKSArIFwiKS8oXCIgKyBnZW5lcmF0ZU5vZGUoYXN0LmFyZ3NbMV0pICsgXCIpKSlcIjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsZXQgcHJlZml4O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gbWFwKGFzdC5hcmdzLCAoYXJnKSA9PiBnZW5lcmF0ZU5vZGUoYXJnKSkuam9pbihcIixcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc01hdGhGdW5jcy5pbmRleE9mKGFzdC5mdW5jTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gXCJNYXRoLlwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gXCJ0aGlzLlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIihcIiArIHByZWZpeCArIGFzdC5mdW5jTmFtZSArIFwiKFwiICsgYXJncyArIFwiKSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN0IGluc3RhbmNlb2YgQXN0LkFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZU5vZGUoYXN0LmxocykgKyBcIj1cIiArIGdlbmVyYXRlTm9kZShhc3QuZXhwcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIEFzdC5Qcm9ncmFtKSB7XG4gICAgICAgICAgICBjb25zdCBzdG10cyA9IG1hcChhc3Quc3RhdGVtZW50cywgKHN0bXQpID0+IGdlbmVyYXRlTm9kZShzdG10KSk7XG4gICAgICAgICAgICByZXR1cm4gc3RtdHMuam9pbihcIjtcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIEFzdC5QcmltYXJ5RXhwciAmJiBhc3QudHlwZSA9PT0gXCJWQUxVRVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN0LnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIEFzdC5QcmltYXJ5RXhwciAmJiBhc3QudHlwZSA9PT0gXCJDT05TVFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRlQ29uc3RhbnRzKGFzdC52YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN0IGluc3RhbmNlb2YgQXN0LlByaW1hcnlFeHByICYmIGFzdC50eXBlID09PSBcIklEXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcInRoaXMuXCIgKyBhc3QudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIEFzdC5QcmltYXJ5RXhwciAmJiBhc3QudHlwZSA9PT0gXCJSRUdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwidGhpcy5yZWdpc3RlckJhbmtbXFxcIlwiICsgYXN0LnZhbHVlICsgXCJcXFwiXVwiO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyVXNhZ2VzID0gZmxvdyhbdmFsdWVzLCBmbGF0dGVuLCB1bmlxXSkodGFibGVzLnJlZ2lzdGVyKTtcbiAgICBjb25zdCBoYXNSYW5kb20gPSB0YWJsZXMuZ2xzbFVzZWRGdW5jcy5pbmRleE9mKFwicmFuZFwiKSA+PSAwO1xuICAgIGNvbnN0IGNvZGVJbnN0ID0gbmV3IENvZGVJbnN0YW5jZShcbiAgICAgICAgcmVnaXN0ZXJVc2FnZXMsXG4gICAgICAgIHRhYmxlcy5nbHNsUmVnaXN0ZXJzLFxuICAgICAgICBoYXNSYW5kb20sXG4gICAgICAgIHRhYmxlcy51bmlmb3JtcyxcbiAgICAgICAgdGFibGVzLnByZUNvbXB1dGUsXG4gICAgKTtcblxuICAgIC8vIGNsZWFyIGFsbCB2YXJpYWJsZXNcbiAgICBmb3IgKGNvbnN0IGpzVmFyIG9mIHRhYmxlcy5qc1ZhcnMpIHtcbiAgICAgICAgY29kZUluc3RbanNWYXJdID0gMDtcbiAgICB9XG5cbiAgICAvLyBnZW5lcmF0ZSBjb2RlXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGpzRnVuY3MpIHtcbiAgICAgICAgY29uc3QgYXN0ID0gY29kZUFzdFtuYW1lXTtcbiAgICAgICAgaWYgKGFzdCkge1xuICAgICAgICAgICAgY29uc3QganNDb2RlU3RyaW5nID0gZ2VuZXJhdGVOb2RlKGFzdCk7XG4gICAgICAgICAgICBjb2RlSW5zdFtuYW1lXSA9IG5ldyBGdW5jdGlvbihqc0NvZGVTdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZUluc3RbbmFtZV0gPSBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvZGVJbnN0O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUdsc2woY29kZUFzdDogSUNvZGVBc3QsIHRhYmxlczogSVN5bWJvbFRhYmxlcywgZ2xzbEZ1bmNzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gICAgY29uc3QgZ2VuZXJhdGVOb2RlID0gKGFzdCkgPT4ge1xuICAgICAgICBpZiAoYXN0IGluc3RhbmNlb2YgQXN0LkJpbmFyeUV4cHIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIihcIiArIGdlbmVyYXRlTm9kZShhc3QubGVmdE9wZXJhbmQpICsgYXN0Lm9wZXJhdG9yICsgZ2VuZXJhdGVOb2RlKGFzdC5yaWdodE9wZXJhbmQpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIEFzdC5VbmFyeUV4cHIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIihcIiArIGFzdC5vcGVyYXRvciArIGdlbmVyYXRlTm9kZShhc3Qub3BlcmFuZCkgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN0IGluc3RhbmNlb2YgQXN0LkZ1bmNDYWxsKSB7XG4gICAgICAgICAgICBpZiAoYXN0LnByZUNvbXB1dGVVbmlmb3JtTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIihcIiArIGFzdC5wcmVDb21wdXRlVW5pZm9ybU5hbWUgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoYXN0LmZ1bmNOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFib3ZlXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIihcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTm9kZShhc3QuYXJnc1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcIj5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTm9kZShhc3QuYXJnc1sxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcIj8xLjA6MC4wKVwiLFxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJlbG93XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIihcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTm9kZShhc3QuYXJnc1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTm9kZShhc3QuYXJnc1sxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcIj8xLjA6MC4wKVwiLFxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVxdWFsXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIihcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTm9kZShhc3QuYXJnc1swXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcIj09XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU5vZGUoYXN0LmFyZ3NbMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCI/MS4wOjAuMClcIixcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpZlwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZU5vZGUoYXN0LmFyZ3NbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIhPTAuMD9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTm9kZShhc3QuYXJnc1sxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTm9kZShhc3QuYXJnc1syXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcIilcIixcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RcIjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RFeHByID0gZ2VuZXJhdGVOb2RlKGFzdC5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVTZWxlY3QgPSAoYXJncywgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlTm9kZShhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoKFwiICsgc2VsZWN0RXhwciArIFwiID09PSBcIiArIGkgKyBcIik/XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKFwiICsgZ2VuZXJhdGVOb2RlKGFyZ3NbMF0pICsgXCIpOlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIiArIGdlbmVyYXRlU2VsZWN0KHRha2VSaWdodChhcmdzLCBhcmdzLmxlbmd0aCAtIDEpLCBpICsgMSkgKyBcIikpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVTZWxlY3QodGFrZVJpZ2h0KGFzdC5hcmdzLCBhc3QuYXJncy5sZW5ndGggLSAxKSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJzcXJcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiKHBvdygoXCIgKyBnZW5lcmF0ZU5vZGUoYXN0LmFyZ3NbMF0pICsgXCIpLCAyKSlcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmFuZFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIoZmxvYXQoKFwiICsgZ2VuZXJhdGVOb2RlKGFzdC5hcmdzWzBdKSArIFwiKSYmKFwiICsgZ2VuZXJhdGVOb2RlKGFzdC5hcmdzWzFdKSArIFwiKSkpXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvclwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIoZmxvYXQoKFwiICsgZ2VuZXJhdGVOb2RlKGFzdC5hcmdzWzBdKSArIFwiKXx8KFwiICsgZ2VuZXJhdGVOb2RlKGFzdC5hcmdzWzFdKSArIFwiKSkpXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJub3RcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiKGZsb2F0KCEoXCIgKyBnZW5lcmF0ZU5vZGUoYXN0LmFyZ3NbMF0pICsgXCIpKSlcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW52c3FydFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIoMS9zcXJ0KFwiICsgZ2VuZXJhdGVOb2RlKGFzdC5hcmdzWzBdKSArIFwiKSlcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXRhbjJcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiKGF0YW4oKFwiICsgZ2VuZXJhdGVOb2RlKGFzdC5hcmdzWzBdKSArIFwiKSwoXCIgKyBnZW5lcmF0ZU5vZGUoYXN0LmFyZ3NbMV0pICsgXCIpKVwiO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IG1hcChhc3QuYXJncywgKGFyZykgPT4gZ2VuZXJhdGVOb2RlKGFyZykpLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIoXCIgKyBhc3QuZnVuY05hbWUgKyBcIihcIiArIGFyZ3MgKyBcIikpXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBBc3QuQXNzaWdubWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlTm9kZShhc3QubGhzKSArIFwiPVwiICsgZ2VuZXJhdGVOb2RlKGFzdC5leHByKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN0IGluc3RhbmNlb2YgQXN0LlByb2dyYW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0bXRzID0gbWFwKGFzdC5zdGF0ZW1lbnRzLCAoc3RtdCkgPT4gZ2VuZXJhdGVOb2RlKHN0bXQpKTtcbiAgICAgICAgICAgIHJldHVybiBzdG10cy5qb2luKFwiO1xcblwiKSArIFwiO1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBBc3QuUHJpbWFyeUV4cHIgJiYgYXN0LnR5cGUgPT09IFwiVkFMVUVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGdsc2xGbG9hdFJlcHIoYXN0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN0IGluc3RhbmNlb2YgQXN0LlByaW1hcnlFeHByICYmIGFzdC50eXBlID09PSBcIkNPTlNUXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVDb25zdGFudHMoYXN0LnZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBBc3QuUHJpbWFyeUV4cHIgJiYgKGFzdC50eXBlID09PSBcIklEXCIgfHwgYXN0LnR5cGUgPT09IFwiUkVHXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN0LnZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGxldCBnbHNsQ29kZSA9IFtdO1xuXG4gICAgLy8gZ2xzbCB2YXJpYWJsZSBkZWNsYXJhdGlvbnNcbiAgICBnbHNsQ29kZSA9IGdsc2xDb2RlLmNvbmNhdChtYXAodGFibGVzLm5vblVuaWZvcm1zLCAobmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gXCJmbG9hdCBcIiArIG5hbWUgKyBcIiA9IDAuMDtcIjtcbiAgICB9KSk7XG4gICAgZ2xzbENvZGUgPSBnbHNsQ29kZS5jb25jYXQobWFwKHRhYmxlcy51bmlmb3JtcywgKG5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIFwidW5pZm9ybSBmbG9hdCBcIiArIG5hbWUgKyBcIjtcIjtcbiAgICB9KSk7XG4gICAgLy8gaW5jbHVkZSByZXF1aXJlZCBmdW5jdGlvbnMgaW4gZ2xzbFxuICAgIGdsc2xDb2RlID0gZ2xzbENvZGUuY29uY2F0KGZsb3coW1xuICAgICAgICBwcihtYXAsIChuYW1lKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKChuYW1lIGluIGdsc2xGdW5jQ29kZSkgPyAoZ2xzbEZ1bmNDb2RlW25hbWVdKSA6IFtdKTtcbiAgICAgICAgfSksXG4gICAgICAgIGZsYXR0ZW4sXG4gICAgXSkodGFibGVzLmdsc2xVc2VkRnVuY3MpKTtcblxuICAgIC8vIGRlY2xhcmF0aW9ucyBmb3IgcHJlY29tcHV0ZWQgZnVuY3Rpb25zXG4gICAgZ2xzbENvZGUgPSBnbHNsQ29kZS5jb25jYXQoZmxvdyhbXG4gICAgICAgIGtleXMsXG4gICAgICAgIHByKG1hcCwgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBcInVuaWZvcm0gZmxvYXQgXCIgKyBuYW1lICsgXCI7XCI7XG4gICAgICAgIH0pLFxuICAgIF0pKHRhYmxlcy5wcmVDb21wdXRlKSk7XG5cbiAgICAvLyBhZGQgdGhlIGZ1bmN0aW9uc1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBnbHNsRnVuY3MpIHtcbiAgICAgICAgY29uc3QgYXN0ID0gY29kZUFzdFtuYW1lXTtcbiAgICAgICAgaWYgKGFzdCkge1xuICAgICAgICAgICAgY29uc3QgY29kZVN0cmluZyA9IGdlbmVyYXRlTm9kZShhc3QpO1xuICAgICAgICAgICAgZ2xzbENvZGUucHVzaChcInZvaWQgXCIgKyBuYW1lICsgXCIoKSB7XCIpO1xuICAgICAgICAgICAgZ2xzbENvZGUucHVzaChjb2RlU3RyaW5nKTtcbiAgICAgICAgICAgIGdsc2xDb2RlLnB1c2goXCJ9XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xzbENvZGUucHVzaChcInZvaWQgXCIgKyBuYW1lICsgXCIoKSB7fVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnbHNsQ29kZS5qb2luKFwiXFxuXCIpO1xufVxuXG50eXBlIEFyZ0xlbmd0aCA9IG51bWJlciB8IHttaW46IG51bWJlcn07XG5jb25zdCBmdW5jQXJnTGVuZ3Roczoge1tmdW5jTmFtZTogc3RyaW5nXTogQXJnTGVuZ3RofSA9IHtcbiAgICBhYm92ZTogMixcbiAgICBhYnM6IDEsXG4gICAgYWNvczogMSxcbiAgICBhc2luOiAxLFxuICAgIGF0YW46IDEsXG4gICAgYXRhbjI6IDIsXG4gICAgYmFuZDogMixcbiAgICBiZWxvdzogMixcbiAgICBibm90OiAxLFxuICAgIGJvcjogMixcbiAgICBjZWlsOiAxLFxuICAgIGNvczogMSxcbiAgICBlcXVhbDogMixcbiAgICBmbG9vcjogMSxcbiAgICBnZXRvc2M6IDMsXG4gICAgZ2V0dGltZTogMSxcbiAgICBpZjogMyxcbiAgICBpbnZzcXJ0OiAxLFxuICAgIGxvZzogMSxcbiAgICBtYXg6IDIsXG4gICAgbWluOiAyLFxuICAgIHBvdzogMixcbiAgICByYW5kOiAxLFxuICAgIHNlbGVjdDoge1xuICAgICAgICBtaW46IDIsXG4gICAgfSxcbiAgICBzaW46IDEsXG4gICAgc3FyOiAxLFxuICAgIHNxcnQ6IDEsXG4gICAgdGFuOiAxLFxufTtcblxuY29uc3QganNNYXRoRnVuY3MgPSBbXG4gICAgXCJtaW5cIiwgXCJtYXhcIiwgXCJzaW5cIiwgXCJjb3NcIiwgXCJhYnNcIiwgXCJ0YW5cIiwgXCJhc2luXCIsIFwiYWNvc1wiLFxuICAgIFwiYXRhblwiLCBcImxvZ1wiLCBcInBvd1wiLCBcInNxcnRcIiwgXCJmbG9vclwiLCBcImNlaWxcIixcbl07XG5cbmNvbnN0IGdsc2xQcmVDb21wdXRlRnVuY3MgPSBbXCJnZXRvc2NcIiwgXCJnZXR0aW1lXCJdO1xuXG5jb25zdCBnbHNsRnVuY0NvZGUgPSB7XG4gICAgcmFuZDogW1xuICAgICAgICBcInVuaWZvcm0gdmVjMiBfX3JhbmRTdGVwO1wiLFxuICAgICAgICBcInZlYzIgX19yYW5kU2VlZDtcIixcbiAgICAgICAgXCJmbG9hdCByYW5kKGZsb2F0IG1heCkge1wiLFxuICAgICAgICBcIiAgIF9fcmFuZFNlZWQgKz0gX19yYW5kU3RlcDtcIixcbiAgICAgICAgXCIgICBmbG9hdCB2YWwgPSBmcmFjdChzaW4oZG90KF9fcmFuZFNlZWQueHkgLHZlYzIoMTIuOTg5OCw3OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTtcIixcbiAgICAgICAgXCIgICByZXR1cm4gKGZsb29yKHZhbCptYXgpKzEpO1wiLFxuICAgICAgICBcIn1cIixcbiAgICBdLmpvaW4oXCJcXG5cIiksXG59O1xuXG5mdW5jdGlvbiBjaGVja0Z1bmMoYXN0OiBBc3QuRnVuY0NhbGwpIHtcbiAgICBjb25zdCByZXF1aXJlZEFyZ0xlbmd0aCA9IGZ1bmNBcmdMZW5ndGhzW2FzdC5mdW5jTmFtZV07XG4gICAgaWYgKHJlcXVpcmVkQXJnTGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIGZ1bmN0aW9uIFwiICsgYXN0LmZ1bmNOYW1lKTtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKHJlcXVpcmVkQXJnTGVuZ3RoKSkge1xuICAgICAgICBpZiAoYXN0LmFyZ3MubGVuZ3RoICE9PSByZXF1aXJlZEFyZ0xlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYXN0LmZ1bmNOYW1lICsgXCIgYWNjZXB0cyBcIiArIHJlcXVpcmVkQXJnTGVuZ3RoICsgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChyZXF1aXJlZEFyZ0xlbmd0aC5taW4pIHtcbiAgICAgICAgaWYgKGFzdC5hcmdzLmxlbmd0aCA8IHJlcXVpcmVkQXJnTGVuZ3RoLm1pbikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYXN0LmZ1bmNOYW1lICsgXCIgYWNjZXB0cyBhdGxlYXN0IFwiICsgcmVxdWlyZWRBcmdMZW5ndGgubWluICsgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVDb25zdGFudHModmFsdWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlIFwicGlcIjogcmV0dXJuIE1hdGguUEk7XG4gICAgICAgIGNhc2UgXCJlXCI6IHJldHVybiBNYXRoLkU7XG4gICAgICAgIGNhc2UgXCJwaGlcIjogcmV0dXJuIDEuNjE4MDMzOTg4NztcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb25zdGFudCBcIiArIHZhbHVlKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZXhwci9jb21waWxlRXhwci50cyIsImltcG9ydCB7IGlzVHlwZWRBcnJheSwgVHlwZWRBcnJheSB9IGZyb20gXCIuLi91dGlsc1wiO1xuaW1wb3J0IFJlbmRlcmluZ0NvbnRleHQgZnJvbSBcIi4vUmVuZGVyaW5nQ29udGV4dFwiO1xuXG4vKipcbiAqIEJ1ZmZlciBpcyBhIHdyYXBwZXIgYXJvdW5kIFdlYkdMQnVmZmVyIHdpdGggdHlwZSBhbmQgc2l6ZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnVmZmVyIHtcbiAgICBwcml2YXRlIGxlbmd0aDogbnVtYmVyO1xuICAgIHByaXZhdGUgdHlwZTogbnVtYmVyO1xuICAgIHByaXZhdGUgcmN0eDogUmVuZGVyaW5nQ29udGV4dDtcbiAgICBwcml2YXRlIGdsQnVmZmVyOiBXZWJHTEJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IEJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHJjdHggdGhlIHJlbmRlcmluZyBjb250ZXh0IGluIHdoaWNoIHRoZSBidWZmZXIgc2hvdWxkIGJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0gaXNFbGVtQXJyYXkgaWYgdHJ1ZSB0aGVuIGEgYGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSYCBpcyBjcmVhdGVkIGVsc2UgYSBgZ2wuQVJSQVlfQlVGRkVSYFxuICAgICAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVmZmVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmN0eDogUmVuZGVyaW5nQ29udGV4dCwgaXNFbGVtQXJyYXk6IGJvb2xlYW4gPSBmYWxzZSwgZGF0YT86IG51bWJlcltdIHwgVHlwZWRBcnJheSkge1xuICAgICAgICBjb25zdCBnbCA9IHJjdHguZ2V0R2woKTtcbiAgICAgICAgdGhpcy50eXBlID0gaXNFbGVtQXJyYXkgPyBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiA6IGdsLkFSUkFZX0JVRkZFUjtcbiAgICAgICAgdGhpcy5yY3R4ID0gcmN0eDtcbiAgICAgICAgdGhpcy5nbEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJyYXkgdGhlIGRhdGEgdG8gYmUgc3RvcmVkIGluIHRoZSBidWZmZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0RGF0YShhcnJheTogbnVtYmVyW10gfCBUeXBlZEFycmF5KSB7XG4gICAgICAgIGlmICghaXNUeXBlZEFycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnbCA9IHRoaXMucmN0eC5nZXRHbCgpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcih0aGlzLnR5cGUsIHRoaXMuZ2xCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKHRoaXMudHlwZSwgYXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBXZWJHTEJ1ZmZlciBmb3IgdGhpcyBCdWZmZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0R2xCdWZmZXIoKTogV2ViR0xCdWZmZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5nbEJ1ZmZlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGRhdGFcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0TGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgYnVmZmVyXG4gICAgICovXG4gICAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmN0eC5nZXRHbCgpLmRlbGV0ZUJ1ZmZlcih0aGlzLmdsQnVmZmVyKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvd2ViZ2wvQnVmZmVyLnRzIiwiaW1wb3J0IGxpc3RDYWNoZUNsZWFyIGZyb20gJy4vX2xpc3RDYWNoZUNsZWFyLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVEZWxldGUgZnJvbSAnLi9fbGlzdENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVHZXQgZnJvbSAnLi9fbGlzdENhY2hlR2V0LmpzJztcbmltcG9ydCBsaXN0Q2FjaGVIYXMgZnJvbSAnLi9fbGlzdENhY2hlSGFzLmpzJztcbmltcG9ydCBsaXN0Q2FjaGVTZXQgZnJvbSAnLi9fbGlzdENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBMaXN0Q2FjaGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0xpc3RDYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc29jSW5kZXhPZjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNzb2NJbmRleE9mLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlQ3JlYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVDcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGlzS2V5YWJsZSBmcm9tICcuL19pc0tleWFibGUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE1hcERhdGE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE1hcERhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXNJbiBmcm9tICcuL19iYXNlS2V5c0luLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IERhdGFWaWV3IGZyb20gJy4vX0RhdGFWaWV3LmpzJztcbmltcG9ydCBNYXAgZnJvbSAnLi9fTWFwLmpzJztcbmltcG9ydCBQcm9taXNlIGZyb20gJy4vX1Byb21pc2UuanMnO1xuaW1wb3J0IFNldCBmcm9tICcuL19TZXQuanMnO1xuaW1wb3J0IFdlYWtNYXAgZnJvbSAnLi9fV2Vha01hcC5qcyc7XG5pbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCB0b1NvdXJjZSBmcm9tICcuL190b1NvdXJjZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFRhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZUNyZWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgY2FzdFBhdGggZnJvbSAnLi9fY2FzdFBhdGguanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldC5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUZsYXR0ZW4gZnJvbSAnLi9fYmFzZUZsYXR0ZW4uanMnO1xuXG4vKipcbiAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZmxhdHRlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9mbGF0dGVuLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBNYXBDYWNoZSBmcm9tICcuL19NYXBDYWNoZS5qcyc7XG5pbXBvcnQgc2V0Q2FjaGVBZGQgZnJvbSAnLi9fc2V0Q2FjaGVBZGQuanMnO1xuaW1wb3J0IHNldENhY2hlSGFzIGZyb20gJy4vX3NldENhY2hlSGFzLmpzJztcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5leHBvcnQgZGVmYXVsdCBTZXRDYWNoZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU2V0Q2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhY2hlSGFzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jYWNoZUhhcy5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gIH1cbiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5ndGg7XG4gIH1cbiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTbGljZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNsaWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlRm9yT3duIGZyb20gJy4vX2Jhc2VGb3JPd24uanMnO1xuaW1wb3J0IGNyZWF0ZUJhc2VFYWNoIGZyb20gJy4vX2NyZWF0ZUJhc2VFYWNoLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VFYWNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRWFjaC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUluZGV4T2YgZnJvbSAnLi9fYmFzZUluZGV4T2YuanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUluY2x1ZGVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUluY2x1ZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlQ3JlYXRlIGZyb20gJy4vX2Jhc2VDcmVhdGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIGFuIGluc3RhbmNlIG9mIGBDdG9yYCByZWdhcmRsZXNzIG9mXG4gKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAvLyBVc2UgYSBgc3dpdGNoYCBzdGF0ZW1lbnQgdG8gd29yayB3aXRoIGNsYXNzIGNvbnN0cnVjdG9ycy4gU2VlXG4gICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDdG9yO1xuICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgY2FzZSA3OiByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgfVxuICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLFxuICAgICAgICByZXN1bHQgPSBDdG9yLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcblxuICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cbiAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVDdG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVDdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKiBVc2VkIGFzIHRoZSBpbnRlcm5hbCBhcmd1bWVudCBwbGFjZWhvbGRlci4gKi9cbnZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuLyoqXG4gKiBSZXBsYWNlcyBhbGwgYHBsYWNlaG9sZGVyYCBlbGVtZW50cyBpbiBgYXJyYXlgIHdpdGggYW4gaW50ZXJuYWwgcGxhY2Vob2xkZXJcbiAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHZhbHVlID09PSBwbGFjZWhvbGRlciB8fCB2YWx1ZSA9PT0gUExBQ0VIT0xERVIpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlcGxhY2VIb2xkZXJzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yZXBsYWNlSG9sZGVycy5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUNsb25lIGZyb20gJy4vX2Jhc2VDbG9uZS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZURlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Nsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcbmltcG9ydCBzdGFja0NsZWFyIGZyb20gJy4vX3N0YWNrQ2xlYXIuanMnO1xuaW1wb3J0IHN0YWNrRGVsZXRlIGZyb20gJy4vX3N0YWNrRGVsZXRlLmpzJztcbmltcG9ydCBzdGFja0dldCBmcm9tICcuL19zdGFja0dldC5qcyc7XG5pbXBvcnQgc3RhY2tIYXMgZnJvbSAnLi9fc3RhY2tIYXMuanMnO1xuaW1wb3J0IHN0YWNrU2V0IGZyb20gJy4vX3N0YWNrU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBTdGFjaztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3RhY2suanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5leHBvcnQgZGVmYXVsdCBNYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcC5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNGdW5jdGlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBtYXBDYWNoZUNsZWFyIGZyb20gJy4vX21hcENhY2hlQ2xlYXIuanMnO1xuaW1wb3J0IG1hcENhY2hlRGVsZXRlIGZyb20gJy4vX21hcENhY2hlRGVsZXRlLmpzJztcbmltcG9ydCBtYXBDYWNoZUdldCBmcm9tICcuL19tYXBDYWNoZUdldC5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVIYXMgZnJvbSAnLi9fbWFwQ2FjaGVIYXMuanMnO1xuaW1wb3J0IG1hcENhY2hlU2V0IGZyb20gJy4vX21hcENhY2hlU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IE1hcENhY2hlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19NYXBDYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5RWFjaDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlFYWNoLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduVmFsdWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc2lnblZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUaW1lcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlSXNBcmd1bWVudHMgZnJvbSAnLi9fYmFzZUlzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcmd1bWVudHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5pbXBvcnQgc3R1YkZhbHNlIGZyb20gJy4vc3R1YkZhbHNlLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5leHBvcnQgZGVmYXVsdCBpc0J1ZmZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0J1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XHJcblx0aWYoIW9yaWdpbmFsTW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiZXhwb3J0c1wiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9oYXJtb255LW1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTGVuZ3RoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVVdGlsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19ub2RlVXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUHJvdG90eXBlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weUFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGFycmF5RmlsdGVyIGZyb20gJy4vX2FycmF5RmlsdGVyLmpzJztcbmltcG9ydCBzdHViQXJyYXkgZnJvbSAnLi9zdHViQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdldFN5bWJvbHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFN5bWJvbHMuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUZpbHRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVB1c2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5UHVzaC5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldFByb3RvdHlwZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UHJvdG90eXBlLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlR2V0QWxsS2V5cyBmcm9tICcuL19iYXNlR2V0QWxsS2V5cy5qcyc7XG5pbXBvcnQgZ2V0U3ltYm9sc0luIGZyb20gJy4vX2dldFN5bWJvbHNJbi5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0QWxsS2V5c0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRBbGxLZXlzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IFVpbnQ4QXJyYXkgZnJvbSAnLi9fVWludDhBcnJheS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVBcnJheUJ1ZmZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVBcnJheUJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFwcGx5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcHBseS5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZVNldFRvU3RyaW5nIGZyb20gJy4vX2Jhc2VTZXRUb1N0cmluZy5qcyc7XG5pbXBvcnQgc2hvcnRPdXQgZnJvbSAnLi9fc2hvcnRPdXQuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5leHBvcnQgZGVmYXVsdCBzZXRUb1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0VG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJdGVyYXRlZUNhbGw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSXRlcmF0ZWVDYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzS2V5LmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBmbGF0dGVuIGZyb20gJy4vZmxhdHRlbi5qcyc7XG5pbXBvcnQgb3ZlclJlc3QgZnJvbSAnLi9fb3ZlclJlc3QuanMnO1xuaW1wb3J0IHNldFRvU3RyaW5nIGZyb20gJy4vX3NldFRvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmbGF0UmVzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZmxhdFJlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3RyaW5nKDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUlzRXF1YWxEZWVwIGZyb20gJy4vX2Jhc2VJc0VxdWFsRGVlcC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0VxdWFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNFcXVhbC5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRUb0FycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRUb0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCAqIGFzIEV2ZW50RW1pdHRlciBmcm9tIFwiZXZlbnRlbWl0dGVyM1wiO1xuaW1wb3J0IGZpbHRlciBmcm9tIFwibG9kYXNoLWVzL2ZpbHRlclwiO1xuXG5pbnRlcmZhY2UgSVN1YnNjcmlwdGlvbiB7XG4gICAgZW1pdHRlcjogRXZlbnRFbWl0dGVyO1xuICAgIGV2ZW50OiBzdHJpbmc7XG4gICAgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBNb2RlbCBpcyBhIGJhc2UgZm9yIE1vZGVsLUxpa2Ugb2JqZWN0cy5cbiAqXG4gKiBNb2RlbCBwcm92aWRlcyBzb21lIGV2ZW50LW1vZGVsIGFuZCBnZW5lcmFsIGF0dHJpYnV0ZSBtYW5hZ2VtZW50XG4gKiBmYWNpbGl0aWVzLiBNb2RlbCBiYXNpY2FsbHkgcHJvdmlkZXMgZ2V0dGVyLCBzZXR0ZXIgbWV0aG9kcyBmb3JcbiAqIGF0dHJpYnV0ZXMgYW5kIGFuIGV2ZW50IHN1YnNjcmlwdGlvbiBzeXN0ZW0gdG8gbm90aWZ5IG9mIGF0dHJpYnV0ZVxuICogY2hhbmdlcyBvciBvdGhlciBjdXN0b20gZXZlbnRzLiBNb2RlbCBpcyB1c2VkIG1haW5seSBieSBDb21wb25lbnRzXG4gKiB0byBtb2RlbCBjb21wb25lbnQgb3B0aW9ucyBhbmQgdGh1cyBhbGxvdyBlZGl0b3JzIHRvIHRyZWF0IGVhY2hcbiAqIGNvbXBvbmVudCBhcyBhIERhdGEgTW9kZWwgb2JqZWN0IHRvIGRyaXZlIHVzZXIgaW50ZXJmYWNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBNb2RlbCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBJU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIE92ZXJyaWRlIHRvIGltcGxlbWVudCBnZXR0ZXIgZm9yIGF0dHJpYnV0ZXNcbiAgICAgKiBAcGFyYW0ga2V5IGF0dHJpYnV0ZSBuYW1lXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGdldChrZXk6IHN0cmluZyk6IGFueTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIE92ZXJyaWRlIHRvIGltcGxlbWVudCBhIEpTT04gZ2VuZXJhdGlvbiBsb2dpY1xuICAgICAqIEBwYXJhbSBrZXkgYXR0cmlidXRlIG5hbWVcbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgdG9KU09OKGtleTogc3RyaW5nKTogYW55O1xuXG4gICAgLyoqXG4gICAgICogU2FmZWx5IHNldCBhbiBhdHRyaWJ1dGUocykuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYXR0cmlidXRlIHNldCBzdWNjZWVkcywgYSBgY2hhbmdlOlthdHRyaWJ1dGUgbmFtZV1gIGV2ZW50IGlzIGZpcmVkLlxuICAgICAqIGBjaGFuZ2U6W2F0dHJpYnV0ZSBuYW1lXWAgZXZlbnQgaGFuZGxlciByZWNlaXZlcyBgdGhpc2Agb2JqZWN0LCB0aGUgbmV3IGB2YWx1ZWBcbiAgICAgKiBhbmQgYG9wdGlvbnNgIGFzIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEFkZGl0aW9uYWxseSBhIGBjaGFuZ2VgIGV2ZW50IGlzIGFsc28gZmlyZWQgd2hlbiBhbGwgY2hhbmdlcyBzdWNjZWVkLiBUaGUgYGNoYW5nZWBcbiAgICAgKiBldmVudCByZWNlaXZlcyBgdGhpc2Agb2JqZWN0IGFuZCB0aGUgYG9wdGlvbnNgIGFzIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBvciBtYXAgb2YgdmFsdWVzXG4gICAgICogQHBhcmFtIHZhbHVlIHRoZSBuZXcgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIHRoaXMgb2JqZWN0IGlzIHNlbnQgZG93biB0byB0aGUgZXZlbnQgaGFuZGxlcnMsIHVzZWZ1bCB0byB0aGluZ3MgZG93biB0byB5b3VyXG4gICAgICogaGFuZGxlci4gaWYgYG9wdGlvbnMuc2lsZW50YCBpcyB0cnVlIHRoZW4gZXZlbnRzIGFyZSBub3QgZmlyZWQuXG4gICAgICovXG4gICAgcHVibGljIHNldChrZXk6IHN0cmluZyB8IG9iamVjdCwgdmFsdWU6IGFueSwgb3B0aW9ucz86IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgc3VjY2VzcztcblxuICAgICAgICBpZiAodHlwZW9mKGtleSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgY29uc3Qgc2lsZW50ID0gdHlwZW9mKG9wdGlvbnMuc2lsZW50KSA9PT0gXCJ1bmRlZmluZWRcIiA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSB0aGlzLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzICYmICFzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2U6XCIgKyBrZXksIHRoaXMsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBtYXAgb2Yga2V5IHZhbHVlcyBhcmUgcGFzc2VkXG4gICAgICAgICAgICAvLyB0aGVuIHNldCBlYWNoIHZhbHVlIHNlcGFyYXRlbHlcbiAgICAgICAgICAgIG9wdGlvbnMgPSB2YWx1ZSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHNpbGVudCA9IHR5cGVvZihvcHRpb25zLnNpbGVudCkgPT09IFwidW5kZWZpbmVkXCIgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBrZXlWYWx1ZU1hcCA9IGtleTtcblxuICAgICAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChrZXkgaW4ga2V5VmFsdWVNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCBrZXlWYWx1ZU1hcFtrZXldLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNoYW5nZTpcIiArIGtleSwgdGhpcywga2V5VmFsdWVNYXBba2V5XSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3VjY2VzcyAmJiAhc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgdG8gYW5vdGhlciBFdmVudEVtaXR0ZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHByb3ZpZGVzIGFuIGV2ZW50IHN1YnNjcmlwdGlvbiBsaXN0IGZhY2lsaXR5LiBBbGxvd2luZ1xuICAgICAqIHN1YmNsYXNzZXMgdG8gbGlzdGVuIHRvIG90aGVyIGVtaXR0ZXJzIGFuZCByZW1vdmUgYWxsIG9yIHNvbWUgbGlzdGVuZXJzXG4gICAgICogd2l0aCBhIHNpbmdsZSBjYWxsIHRvIFtbTW9kZWwuc3RvcExpc3RlbmluZ11dLCBsYXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbWl0dGVyIHRoZSBldmVudCBlbWl0dGVyIHRvIGxpc3RlbiB0b1xuICAgICAqIEBwYXJhbSBldmVudCB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBjYWxsYmFjayBmb3IgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgbGlzdGVuVG8oZW1pdHRlcjogRXZlbnRFbWl0dGVyLCBldmVudDogc3RyaW5nLCBjYWxsYmFjazogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKSB7XG4gICAgICAgIGVtaXR0ZXIuYWRkTGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goe2VtaXR0ZXIsIGV2ZW50LCBjYWxsYmFja30pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdG8gb25lIG9yIG1vcmUgbGlzdGVuZXJzIHRoYXQgd2VyZSBzZXQgZWFybGllciB3aXRoIGNhbGxzIHRvIFtbTW9kZWwubGlzdGVuVG9dXS5cbiAgICAgKlxuICAgICAqIFVzZSB0aGUgYXJndW1lbnRzIHRvIGZpbHRlciBzdWJzY3JpcHRpb25zLiBlZzogYG1vZGVsLnN0b3BMaXN0ZW5pbmcoZW0pYCB3aWxsIHJlbW92ZSBhbGxcbiAgICAgKiBsaXN0ZW5lcnMgb24gZW1pdHRlciBgZW1gLiBgbW9kZWwuc3RvcExpc3RlbmluZyhlbSwgJ2NoYW5nZScpYCB3aWxsIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvclxuICAgICAqIGBjaGFuZ2VgIGV2ZW50IG9uIGVtaXR0ZXIgYGVtYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbWl0dGVyIHRoZSBldmVudCBlbWl0dGVyIG9uIHdoaWNoIHRoZSBsaXN0ZW5lciB3YXMgc2V0XG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBldmVudCB0byBiZSByZW1vdmVkXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBjYWxsYmFjayB0byBiZSByZW1vdmVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0b3BMaXN0ZW5pbmcoZW1pdHRlcj86IEV2ZW50RW1pdHRlciwgZXZlbnQ/OiBzdHJpbmcsIGNhbGxiYWNrPzogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKSB7XG4gICAgICAgIGNvbnN0IHN1YkZpbHRlcjogYW55ID0ge307XG4gICAgICAgIGlmIChlbWl0dGVyKSB7XG4gICAgICAgICAgICBzdWJGaWx0ZXIuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBzdWJGaWx0ZXIuZXZlbnQgPSBldmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1pdHRlcikge1xuICAgICAgICAgICAgc3ViRmlsdGVyLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VicyA9IGZpbHRlcih0aGlzLnN1YnNjcmlwdGlvbnMsIHN1YkZpbHRlcik7XG4gICAgICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICAgICAgICBzdWIuZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihzdWIuZXZlbnQsIHN1Yi5jYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB2YWx1ZSBvZiBhIHNpbmdsZSBhdHRyaWJ1dGUgYW5kIHJldHVybnMgYm9vbGVhbiB0byBpbmRpY2F0ZSBzdWNjZXNzLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGUgdGhpcyB0byBpbXBsZW1lbnQgYXR0cmlidXRlIHNldCBsb2dpY1xuICAgICAqIEBwYXJhbSBrZXkgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgdmFsdWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjdXN0b20gb3B0aW9uc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBzZXRBdHRyaWJ1dGUoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnksIG9wdGlvbnM6IGFueSk6IGJvb2xlYW47XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvTW9kZWwudHMiLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUluY2x1ZGVzV2l0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlJbmNsdWRlc1dpdGguanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VDcmVhdGUgZnJvbSAnLi9fYmFzZUNyZWF0ZS5qcyc7XG5pbXBvcnQgYmFzZUxvZGFzaCBmcm9tICcuL19iYXNlTG9kYXNoLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzLlxuICovXG5mdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICB0aGlzLl9faW5kZXhfXyA9IDA7XG4gIHRoaXMuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbn1cblxuTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbkxvZGFzaFdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9kYXNoV3JhcHBlcjtcblxuZXhwb3J0IGRlZmF1bHQgTG9kYXNoV3JhcHBlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTG9kYXNoV3JhcHBlci5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgY2hhaW4gc2VxdWVuY2Ugd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VMb2Rhc2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VMb2Rhc2guanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IG1ldGFNYXAgZnJvbSAnLi9fbWV0YU1hcC5qcyc7XG5pbXBvcnQgbm9vcCBmcm9tICcuL25vb3AuanMnO1xuXG4vKipcbiAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAqL1xudmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdldERhdGE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldERhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VDcmVhdGUgZnJvbSAnLi9fYmFzZUNyZWF0ZS5qcyc7XG5pbXBvcnQgYmFzZUxvZGFzaCBmcm9tICcuL19iYXNlTG9kYXNoLmpzJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbnZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbGF6eSB3cmFwcGVyIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBsYXp5IGV2YWx1YXRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAqL1xuZnVuY3Rpb24gTGF6eVdyYXBwZXIodmFsdWUpIHtcbiAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gIHRoaXMuX19kaXJfXyA9IDE7XG4gIHRoaXMuX19maWx0ZXJlZF9fID0gZmFsc2U7XG4gIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICB0aGlzLl9fdGFrZUNvdW50X18gPSBNQVhfQVJSQVlfTEVOR1RIO1xuICB0aGlzLl9fdmlld3NfXyA9IFtdO1xufVxuXG4vLyBFbnN1cmUgYExhenlXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgYmFzZUxvZGFzaGAuXG5MYXp5V3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbkxhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG5leHBvcnQgZGVmYXVsdCBMYXp5V3JhcHBlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTGF6eVdyYXBwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBHZXRzIHRoZSBhcmd1bWVudCBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgYGZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRIb2xkZXIoZnVuYykge1xuICB2YXIgb2JqZWN0ID0gZnVuYztcbiAgcmV0dXJuIG9iamVjdC5wbGFjZWhvbGRlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0SG9sZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRIb2xkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VTbGljZSBmcm9tICcuL19iYXNlU2xpY2UuanMnO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tICcuL3RvSW50ZWdlci5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBbM11cbiAqXG4gKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDIpO1xuICogLy8gPT4gWzIsIDNdXG4gKlxuICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAqIC8vID0+IFsxLCAyLCAzXVxuICpcbiAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gKiAvLyA9PiBbXVxuICovXG5mdW5jdGlvbiB0YWtlUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgbiA9IGxlbmd0aCAtIG47XG4gIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRha2VSaWdodDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90YWtlUmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGRyb3AgZnJvbSBcImxvZGFzaC1lcy9kcm9wXCI7XG5pbXBvcnQgZWFjaCBmcm9tIFwibG9kYXNoLWVzL2VhY2hcIjtcbmltcG9ydCBleHRlbmQgZnJvbSBcImxvZGFzaC1lcy9leHRlbmRcIjtcbmltcG9ydCBoYXMgZnJvbSBcImxvZGFzaC1lcy9oYXNcIjtcbmltcG9ydCBpc0FycmF5IGZyb20gXCJsb2Rhc2gtZXMvaXNBcnJheVwiO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSBcImxvZGFzaC1lcy9pc0Z1bmN0aW9uXCI7XG5pbXBvcnQgaXNTdHJpbmcgZnJvbSBcImxvZGFzaC1lcy9pc1N0cmluZ1wiO1xuaW1wb3J0IG1hcCBmcm9tIFwibG9kYXNoLWVzL21hcFwiO1xuaW1wb3J0IHRha2UgZnJvbSBcImxvZGFzaC1lcy90YWtlXCI7XG5pbXBvcnQgdGltZXMgZnJvbSBcImxvZGFzaC1lcy90aW1lc1wiO1xuaW1wb3J0IEFuYWx5c2VyQWRhcHRlciBmcm9tIFwiLi4vYW5hbHlzZXIvQW5hbHlzZXJBZGFwdGVyXCI7XG5pbXBvcnQgeyBJQ29udGFpbmVyIH0gZnJvbSBcIi4uL0NvbXBvbmVudFwiO1xuaW1wb3J0IElNYWluIGZyb20gXCIuLi9JTWFpblwiO1xuaW1wb3J0IHsgV2ViR0xWYXJUeXBlIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tIFwiLi4vd2ViZ2wvU2hhZGVyUHJvZ3JhbVwiO1xuXG4vLyBBbiBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgdGhlIGdlbmVyYXRlZCBleGVjdXRhYmxlIGNvZGVcbi8vIGFuZCBpdHMgc3RhdGUgdmFsdWVzLiBBbHNvIGNvbnRhaW5zIGltcGxlbWVudGF0aW9ucyBvZlxuLy8gZnVuY3Rpb25zIGNhbGxhYmxlIGZyb20gZXhwcmVzc2lvbnNcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvZGVJbnN0YW5jZSB7XG4gICAgLy8gY3JlYXRlcyBhbiBhcnJheSBvZiBjbG9uZXMgb2YgY29kZSBpbnN0YW5jZXNcbiAgICBwdWJsaWMgc3RhdGljIGNsb25lKGNsb25lT3JDbG9uZXM6IENvZGVJbnN0YW5jZSB8IENvZGVJbnN0YW5jZVtdLCBjb3VudCk6IENvZGVJbnN0YW5jZVtdIHtcbiAgICAgICAgbGV0IGNsb25lczogQ29kZUluc3RhbmNlW107XG4gICAgICAgIGlmICghaXNBcnJheShjbG9uZU9yQ2xvbmVzKSkge1xuICAgICAgICAgICAgY2xvbmVPckNsb25lcy5jaWQgPSAwO1xuICAgICAgICAgICAgY2xvbmVzID0gW2Nsb25lT3JDbG9uZXNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xvbmVzID0gY2xvbmVPckNsb25lcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbG9uZXNMZW5ndGggPSBjbG9uZXMubGVuZ3RoO1xuICAgICAgICBpZiAoY2xvbmVzTGVuZ3RoIDwgY291bnQpIHtcbiAgICAgICAgICAgIHRpbWVzKGNvdW50IC0gY2xvbmVzTGVuZ3RoLCAoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5jcmVhdGUoQ29kZUluc3RhbmNlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5kKGNsb25lLCBjbG9uZXNbMF0pO1xuICAgICAgICAgICAgICAgIGNsb25lLmNpZCA9IGluZGV4ICsgY2xvbmVzTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNsb25lcy5wdXNoKGNsb25lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNsb25lc0xlbmd0aCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjbG9uZXMgPSB0YWtlKGNsb25lcywgY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZXM7XG4gICAgfVxuXG4gICAgLy8gY29waWVzIGluc3RhbmNlIHZhbHVlcyBmcm9tIG9uZSBjb2RlIGluc3RhbmNlIHRvIGFub3RoZXJcbiAgICBwdWJsaWMgc3RhdGljIGNvcHlWYWx1ZXMoZGVzdDogQ29kZUluc3RhbmNlLCBzcmM6IENvZGVJbnN0YW5jZSkge1xuICAgICAgICBlYWNoKHNyYywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzRnVuY3Rpb24odmFsdWUpICYmIG5hbWUuY2hhckF0KDApICE9PSBcIl9cIikge1xuICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHc6IG51bWJlcjtcbiAgICBwdWJsaWMgaDogbnVtYmVyO1xuICAgIHB1YmxpYyBjaWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIGJvb3RUaW1lOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBhbmFseXNlcjogQW5hbHlzZXJBZGFwdGVyO1xuICAgIHByaXZhdGUgcmVnaXN0ZXJCYW5rOiB7W25hbWU6IHN0cmluZ106IG51bWJlcn07XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWdpc3RlclVzYWdlczogc3RyaW5nW10sXG4gICAgICAgIHByaXZhdGUgZ2xzbFJlZ2lzdGVyczogc3RyaW5nW10sXG4gICAgICAgIHB1YmxpYyBoYXNSYW5kb206IGJvb2xlYW4sXG4gICAgICAgIHByaXZhdGUgdW5pZm9ybXM6IHN0cmluZ1tdLFxuICAgICAgICBwcml2YXRlIHByZUNvbXB1dGU6IHtbdW5pZm9ybU5hbWU6IHN0cmluZ106IHN0cmluZ1tdfSxcbiAgICApIHt9XG5cbiAgICAvLyBhdnMgZXhwcmVzc2lvbiByYW5kIGZ1bmN0aW9uXG4gICAgcHVibGljIHJhbmQobWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpICsgMTtcbiAgICB9XG5cbiAgICAvLyBhdnMgZXhwcmVzc2lvbiBnZXR0aW1lIGZ1bmN0aW9uXG4gICAgcHVibGljIGdldHRpbWUoc3RhcnRUaW1lOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBzd2l0Y2ggKHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGN1cnJlbnRUaW1lIC0gdGhpcy5ib290VGltZSkgLyAxMDAwO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGFydFRpbWUgbW9kZSBmb3IgZ2V0dGltZSBjYWxsXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXZzIGV4cHJlc3Npb24gZ2V0b3NjIGZ1bmN0aW9uXG4gICAgcHVibGljIGdldG9zYyhiYW5kOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGNoYW5uZWw6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IG9zYyA9IHRoaXMuYW5hbHlzZXIuZ2V0V2F2ZWZvcm0oKTtcbiAgICAgICAgY29uc3QgcG9zID0gTWF0aC5mbG9vcigoYmFuZCAtIHdpZHRoIC8gMikgKiAob3NjLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5mbG9vcigoYmFuZCArIHdpZHRoIC8gMikgKiAob3NjLmxlbmd0aCAtIDEpKTtcblxuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IG9zY1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtIC8gKGVuZCAtIHBvcyArIDEpO1xuICAgIH1cblxuICAgIC8vIGJpbmQgc3RhdGUgdmFsdWVzIHRvIHVuaWZvcm1zXG4gICAgcHVibGljIGJpbmRVbmlmb3Jtcyhwcm9ncmFtOiBTaGFkZXJQcm9ncmFtKSB7XG4gICAgICAgIC8vIGJpbmQgYWxsIHZhbHVlc1xuICAgICAgICBlYWNoKHRoaXMudW5pZm9ybXMsIChuYW1lKSA9PiB7XG4gICAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm0obmFtZSwgV2ViR0xWYXJUeXBlLl8xRiwgdGhpc1tuYW1lXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGJpbmQgcmVnaXN0ZXJzXG4gICAgICAgIGVhY2godGhpcy5nbHNsUmVnaXN0ZXJzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtKG5hbWUsIFdlYkdMVmFyVHlwZS5fMUYsIHRoaXMucmVnaXN0ZXJCYW5rW25hbWVdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYmluZCByYW5kb20gc3RlcCB2YWx1ZSBpZiB0aGVyZSBhcmUgdXNhZ2VzIG9mIHJhbmRvbVxuICAgICAgICBpZiAodGhpcy5oYXNSYW5kb20pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSBbTWF0aC5yYW5kb20oKSAvIDEwMCwgTWF0aC5yYW5kb20oKSAvIDEwMF07XG4gICAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm0oXCJfX3JhbmRTdGVwXCIsIFdlYkdMVmFyVHlwZS5fMkZWLCBzdGVwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJpbmQgcHJlY29tcHV0ZWQgdmFsdWVzXG4gICAgICAgIGVhY2godGhpcy5wcmVDb21wdXRlLCAoZW50cnksIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBtYXAoZHJvcChlbnRyeSksIChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLnN1YnN0cmluZygwLCA1KSA9PT0gXCJfX1JFR1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlckJhbmtbYXJnXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2FyZ107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpc1tlbnRyeVswXV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm0obmFtZSwgV2ViR0xWYXJUeXBlLl8xRiwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZXMgdGhpcyBjb2RlaW5zdGFuY2VcbiAgICBwdWJsaWMgc2V0dXAobWFpbjogSU1haW4pIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckJhbmsgPSBtYWluLmdldFJlZ2lzdGVyQmFuaygpO1xuICAgICAgICB0aGlzLmJvb3RUaW1lID0gbWFpbi5nZXRCb290VGltZSgpO1xuICAgICAgICB0aGlzLmFuYWx5c2VyID0gbWFpbi5nZXRBbmFseXNlcigpO1xuICAgICAgICB0aGlzLnVwZGF0ZURpbVZhcnMobWFpbi5nZXRSY3R4KCkuZ2V0R2woKSk7XG5cbiAgICAgICAgLy8gY2xlYXIgYWxsIHVzZWQgcmVnaXN0ZXJzXG4gICAgICAgIGVhY2godGhpcy5yZWdpc3RlclVzYWdlcywgKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFzKHRoaXMucmVnaXN0ZXJCYW5rLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJCYW5rW25hbWVdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZURpbVZhcnMoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCkge1xuICAgICAgICB0aGlzLncgPSBnbC5kcmF3aW5nQnVmZmVyV2lkdGg7XG4gICAgICAgIHRoaXMuaCA9IGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQ7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2V4cHIvQ29kZUluc3RhbmNlLnRzIiwiaW1wb3J0IEJ1ZmZlciBmcm9tIFwiLi9CdWZmZXJcIjtcbmltcG9ydCBSZW5kZXJpbmdDb250ZXh0IGZyb20gXCIuL1JlbmRlcmluZ0NvbnRleHRcIjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgY2FjaGVkIEJ1ZmZlciB3aXRoIHBvaW50cyBvbiBhIGNpcmNsZVxuICogQHBhcmFtIHJjdHggUmVuZGVyaW5nQ29udGV4dCB1bmRlZiB3aGljaCB0aGUgYnVmZmVyIHdpbGwgYmUgY3JlYXRlZCBhbmQgY2FjaGVkXG4gKiBAcGFyYW0gcG9pbnRDb3VudCBudW1iZXIgb2YgcG9pbnRzIGluIHRoZSBnZW9tZXRyeVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2lyY2xlR2VvbWV0cnkocmN0eDogUmVuZGVyaW5nQ29udGV4dCwgcG9pbnRDb3VudDogbnVtYmVyID0gMTAwKSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBcIkNpcmNsZUdlb21ldHJ5X1wiICsgcG9pbnRDb3VudDtcbiAgICBsZXQgYnVmZmVyID0gcmN0eC5nZXRCdWZmZXIoY2FjaGVLZXkpO1xuICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheSgocG9pbnRDb3VudCArIDIpICogMik7XG4gICAgbGV0IHBiaSA9IDA7XG4gICAgcG9pbnRzW3BiaSsrXSA9IDA7IC8vIGNlbnRlclxuICAgIHBvaW50c1twYmkrK10gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRDb3VudDsgaSsrKSB7XG4gICAgICAgIHBvaW50c1twYmkrK10gPSBNYXRoLnNpbihpICogMiAqIE1hdGguUEkgLyBwb2ludENvdW50KTtcbiAgICAgICAgcG9pbnRzW3BiaSsrXSA9IE1hdGguY29zKGkgKiAyICogTWF0aC5QSSAvIHBvaW50Q291bnQpO1xuICAgIH1cbiAgICBwb2ludHNbcGJpKytdID0gcG9pbnRzWzJdOyAvLyByZXBlYXQgbGFzdCBwb2ludCBhZ2FpblxuICAgIHBvaW50c1twYmkrK10gPSBwb2ludHNbM107XG5cbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKHJjdHgsIGZhbHNlLCBwb2ludHMpO1xuICAgIHJjdHguY2FjaGVCdWZmZXIoY2FjaGVLZXksIGJ1ZmZlcik7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgY2FjaGVkIGJ1ZmZlciB3aXRoIHBvaW50cyBvbiBhIHNxdWFyZVxuICogQHBhcmFtIHJjdHggUmVuZGVyaW5nQ29udGV4dCB1bmRlciB3aGljaCB0aGUgYnVmZmVyIHdpbGwgYmUgY3JlYXRlZCBhbmQgY2FjaGVkXG4gKiBAcGFyYW0gcG9zaXRpdmVRdWFkIGlmIHRydWUgdGhlbiBzcXVhcmUgd2lsbCBiZSBpbiBbMC0xXVswLTFdIHJhbmdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlR2VvbWV0cnkocmN0eDogUmVuZGVyaW5nQ29udGV4dCwgcG9zaXRpdmVRdWFkOiBib29sZWFuID0gZmFsc2UpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IFwiU3F1YXJlR2VvbWV0cnlfXCIgKyBwb3NpdGl2ZVF1YWQ7XG4gICAgbGV0IGJ1ZmZlciA9IHJjdHguZ2V0QnVmZmVyKGNhY2hlS2V5KTtcbiAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIGxldCBwb2ludHM7XG4gICAgaWYgKHBvc2l0aXZlUXVhZCkge1xuICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgICAwLCAgMCxcbiAgICAgICAgICAgIDAsICAxLFxuICAgICAgICAgICAgMSwgIDEsXG4gICAgICAgICAgICAwLCAgMCxcbiAgICAgICAgICAgIDEsICAxLFxuICAgICAgICAgICAgMSwgIDAsXG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnRzID0gW1xuICAgICAgICAgICAgLTEsICAtMSxcbiAgICAgICAgICAgIDEsICAtMSxcbiAgICAgICAgICAgIC0xLCAgMSxcbiAgICAgICAgICAgIC0xLCAgMSxcbiAgICAgICAgICAgIDEsICAtMSxcbiAgICAgICAgICAgIDEsICAxLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKHJjdHgsIGZhbHNlLCBwb2ludHMpO1xuICAgIHJjdHguY2FjaGVCdWZmZXIoY2FjaGVLZXksIGJ1ZmZlcik7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy93ZWJnbC9nZW9tZXRyaWVzLnRzIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBhcnJheUVhY2ggZnJvbSAnLi9fYXJyYXlFYWNoLmpzJztcbmltcG9ydCBhc3NpZ25WYWx1ZSBmcm9tICcuL19hc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgYmFzZUFzc2lnbiBmcm9tICcuL19iYXNlQXNzaWduLmpzJztcbmltcG9ydCBiYXNlQXNzaWduSW4gZnJvbSAnLi9fYmFzZUFzc2lnbkluLmpzJztcbmltcG9ydCBjbG9uZUJ1ZmZlciBmcm9tICcuL19jbG9uZUJ1ZmZlci5qcyc7XG5pbXBvcnQgY29weUFycmF5IGZyb20gJy4vX2NvcHlBcnJheS5qcyc7XG5pbXBvcnQgY29weVN5bWJvbHMgZnJvbSAnLi9fY29weVN5bWJvbHMuanMnO1xuaW1wb3J0IGNvcHlTeW1ib2xzSW4gZnJvbSAnLi9fY29weVN5bWJvbHNJbi5qcyc7XG5pbXBvcnQgZ2V0QWxsS2V5cyBmcm9tICcuL19nZXRBbGxLZXlzLmpzJztcbmltcG9ydCBnZXRBbGxLZXlzSW4gZnJvbSAnLi9fZ2V0QWxsS2V5c0luLmpzJztcbmltcG9ydCBnZXRUYWcgZnJvbSAnLi9fZ2V0VGFnLmpzJztcbmltcG9ydCBpbml0Q2xvbmVBcnJheSBmcm9tICcuL19pbml0Q2xvbmVBcnJheS5qcyc7XG5pbXBvcnQgaW5pdENsb25lQnlUYWcgZnJvbSAnLi9faW5pdENsb25lQnlUYWcuanMnO1xuaW1wb3J0IGluaXRDbG9uZU9iamVjdCBmcm9tICcuL19pbml0Q2xvbmVPYmplY3QuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc01hcCBmcm9tICcuL2lzTWFwLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBpc1NldCBmcm9tICcuL2lzU2V0LmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VDbG9uZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUNsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1NvdXJjZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9Tb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZVByb3BlcnR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUFzc2lnblZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQXNzaWduVmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lUHJvcGVydHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2RlZmluZVByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlVGltZXMgZnJvbSAnLi9fYmFzZVRpbWVzLmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TGlrZUtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VJc1R5cGVkQXJyYXkgZnJvbSAnLi9fYmFzZUlzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNUeXBlZEFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHViQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc3R1YkFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBhcnJheVB1c2ggZnJvbSAnLi9fYXJyYXlQdXNoLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBnZXRTeW1ib2xzIGZyb20gJy4vX2dldFN5bWJvbHMuanMnO1xuaW1wb3J0IHN0dWJBcnJheSBmcm9tICcuL3N0dWJBcnJheS5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdldFN5bWJvbHNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0U3ltYm9sc0luLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlR2V0QWxsS2V5cyBmcm9tICcuL19iYXNlR2V0QWxsS2V5cy5qcyc7XG5pbXBvcnQgZ2V0U3ltYm9scyBmcm9tICcuL19nZXRTeW1ib2xzLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldEFsbEtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldEFsbEtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGFycmF5UHVzaCBmcm9tICcuL19hcnJheVB1c2guanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0QWxsS2V5cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldEFsbEtleXMuanNcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5leHBvcnQgZGVmYXVsdCBTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1NldC5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxuZXhwb3J0IGRlZmF1bHQgV2Vha01hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fV2Vha01hcC5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgVWludDhBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fVWludDhBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlclJlc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJSZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNob3J0T3V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaG9ydE91dC5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VQaWNrIGZyb20gJy4vX2Jhc2VQaWNrLmpzJztcbmltcG9ydCBmbGF0UmVzdCBmcm9tICcuL19mbGF0UmVzdC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcGljaztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9waWNrLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUdldCBmcm9tICcuL19iYXNlR2V0LmpzJztcbmltcG9ydCBiYXNlU2V0IGZyb20gJy4vX2Jhc2VTZXQuanMnO1xuaW1wb3J0IGNhc3RQYXRoIGZyb20gJy4vX2Nhc3RQYXRoLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQaWNrQnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQaWNrQnkuanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlVG9TdHJpbmcgZnJvbSAnLi9fYmFzZVRvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VIYXNJbiBmcm9tICcuL19iYXNlSGFzSW4uanMnO1xuaW1wb3J0IGhhc1BhdGggZnJvbSAnLi9faGFzUGF0aC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaGFzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzUGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VJc0VxdWFsIGZyb20gJy4vX2Jhc2VJc0VxdWFsLmpzJztcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBvYmplY3QgPT09IG90aGVyO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRXF1YWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNFcXVhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IFNldENhY2hlIGZyb20gJy4vX1NldENhY2hlLmpzJztcbmltcG9ydCBhcnJheVNvbWUgZnJvbSAnLi9fYXJyYXlTb21lLmpzJztcbmltcG9ydCBjYWNoZUhhcyBmcm9tICcuL19jYWNoZUhhcy5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsQXJyYXlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEFycmF5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1VuZGVmaW5lZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1VuZGVmaW5lZC5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxhc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbGFzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGFycmF5RmlsdGVyIGZyb20gJy4vX2FycmF5RmlsdGVyLmpzJztcbmltcG9ydCBiYXNlRmlsdGVyIGZyb20gJy4vX2Jhc2VGaWx0ZXIuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqIEBzZWUgXy5yZWplY3RcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gKiBdO1xuICpcbiAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZpbHRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9maWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1N0cmljdENvbXBhcmFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzU3RyaWN0Q29tcGFyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQcm9wZXJ0eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUZpbmRJbmRleCBmcm9tICcuL19iYXNlRmluZEluZGV4LmpzJztcbmltcG9ydCBiYXNlSXNOYU4gZnJvbSAnLi9fYmFzZUlzTmFOLmpzJztcbmltcG9ydCBzdHJpY3RJbmRleE9mIGZyb20gJy4vX3N0cmljdEluZGV4T2YuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSW5kZXhPZjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUluZGV4T2YuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FzdEZ1bmN0aW9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jYXN0RnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBjcmVhdGVGbG93IGZyb20gJy4vX2NyZWF0ZUZsb3cuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb25zXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAqIEBzZWUgXy5mbG93UmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3coW18uYWRkLCBzcXVhcmVdKTtcbiAqIGFkZFNxdWFyZSgxLCAyKTtcbiAqIC8vID0+IDlcbiAqL1xudmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbmV4cG9ydCBkZWZhdWx0IGZsb3c7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZmxvdy5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IFdlYWtNYXAgZnJvbSAnLi9fV2Vha01hcC5qcyc7XG5cbi8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIG1ldGFNYXAgPSBXZWFrTWFwICYmIG5ldyBXZWFrTWFwO1xuXG5leHBvcnQgZGVmYXVsdCBtZXRhTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tZXRhTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5leHBvcnQgZGVmYXVsdCBub29wO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL25vb3AuanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCByZWFsTmFtZXMgZnJvbSAnLi9fcmVhbE5hbWVzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICovXG5mdW5jdGlvbiBnZXRGdW5jTmFtZShmdW5jKSB7XG4gIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQpID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldEZ1bmNOYW1lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRGdW5jTmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IExhenlXcmFwcGVyIGZyb20gJy4vX0xhenlXcmFwcGVyLmpzJztcbmltcG9ydCBnZXREYXRhIGZyb20gJy4vX2dldERhdGEuanMnO1xuaW1wb3J0IGdldEZ1bmNOYW1lIGZyb20gJy4vX2dldEZ1bmNOYW1lLmpzJztcbmltcG9ydCBsb2Rhc2ggZnJvbSAnLi93cmFwcGVyTG9kYXNoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xuXG4gIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgcmV0dXJuICEhZGF0YSAmJiBmdW5jID09PSBkYXRhWzBdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0xhemlhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0xhemlhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTnVtYmVyKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc051bWJlcignMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTnVtYmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTnVtYmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUVhY2ggZnJvbSAnLi9fYmFzZUVhY2guanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGNyZWF0ZVdyYXAgZnJvbSAnLi9fY3JlYXRlV3JhcC5qcyc7XG5pbXBvcnQgZ2V0SG9sZGVyIGZyb20gJy4vX2dldEhvbGRlci5qcyc7XG5pbXBvcnQgcmVwbGFjZUhvbGRlcnMgZnJvbSAnLi9fcmVwbGFjZUhvbGRlcnMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG4gKiBhcmUgYXBwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAqXG4gKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gKiB9XG4gKlxuICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuICogZ3JlZXRGcmVkKCdoaScpO1xuICogLy8gPT4gJ2hpIGZyZWQnXG4gKlxuICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcbiAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICovXG52YXIgcGFydGlhbFJpZ2h0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWxSaWdodCkpO1xuICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG59KTtcblxuLy8gQXNzaWduIGRlZmF1bHQgcGxhY2Vob2xkZXJzLlxucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnRpYWxSaWdodDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9wYXJ0aWFsUmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCBtZXRhTWFwIGZyb20gJy4vX21ldGFNYXAuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICBtZXRhTWFwLnNldChmdW5jLCBkYXRhKTtcbiAgcmV0dXJuIGZ1bmM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2V0RGF0YTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNldERhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBjb21wb3NlQXJncyBmcm9tICcuL19jb21wb3NlQXJncy5qcyc7XG5pbXBvcnQgY29tcG9zZUFyZ3NSaWdodCBmcm9tICcuL19jb21wb3NlQXJnc1JpZ2h0LmpzJztcbmltcG9ydCBjb3VudEhvbGRlcnMgZnJvbSAnLi9fY291bnRIb2xkZXJzLmpzJztcbmltcG9ydCBjcmVhdGVDdG9yIGZyb20gJy4vX2NyZWF0ZUN0b3IuanMnO1xuaW1wb3J0IGNyZWF0ZVJlY3VycnkgZnJvbSAnLi9fY3JlYXRlUmVjdXJyeS5qcyc7XG5pbXBvcnQgZ2V0SG9sZGVyIGZyb20gJy4vX2dldEhvbGRlci5qcyc7XG5pbXBvcnQgcmVvcmRlciBmcm9tICcuL19yZW9yZGVyLmpzJztcbmltcG9ydCByZXBsYWNlSG9sZGVycyBmcm9tICcuL19yZXBsYWNlSG9sZGVycy5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG52YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsXG4gICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICBXUkFQX0FSWV9GTEFHID0gMTI4LFxuICAgIFdSQVBfRkxJUF9GTEFHID0gNTEyO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCBvcHRpb25hbCBgdGhpc2BcbiAqIGJpbmRpbmcgb2YgYHRoaXNBcmdgLCBwYXJ0aWFsIGFwcGxpY2F0aW9uLCBhbmQgY3VycnlpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc1JpZ2h0XSBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZFxuICogIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc1JpZ2h0XSBUaGUgYHBhcnRpYWxzUmlnaHRgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSHlicmlkKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICB2YXIgaXNBcnkgPSBiaXRtYXNrICYgV1JBUF9BUllfRkxBRyxcbiAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUcsXG4gICAgICBpc0N1cnJpZWQgPSBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyksXG4gICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgV1JBUF9GTElQX0ZMQUcsXG4gICAgICBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogY3JlYXRlQ3RvcihmdW5jKTtcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgIH1cbiAgICBpZiAoaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlciksXG4gICAgICAgICAgaG9sZGVyc0NvdW50ID0gY291bnRIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICB9XG4gICAgaWYgKHBhcnRpYWxzKSB7XG4gICAgICBhcmdzID0gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCk7XG4gICAgfVxuICAgIGlmIChwYXJ0aWFsc1JpZ2h0KSB7XG4gICAgICBhcmdzID0gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGlzQ3VycmllZCk7XG4gICAgfVxuICAgIGxlbmd0aCAtPSBob2xkZXJzQ291bnQ7XG4gICAgaWYgKGlzQ3VycmllZCAmJiBsZW5ndGggPCBhcml0eSkge1xuICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcbiAgICAgICAgZnVuYywgYml0bWFzaywgY3JlYXRlSHlicmlkLCB3cmFwcGVyLnBsYWNlaG9sZGVyLCB0aGlzQXJnLFxuICAgICAgICBhcmdzLCBuZXdIb2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkgLSBsZW5ndGhcbiAgICAgICk7XG4gICAgfVxuICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICBmbiA9IGlzQmluZEtleSA/IHRoaXNCaW5kaW5nW2Z1bmNdIDogZnVuYztcblxuICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuICAgIGlmIChhcmdQb3MpIHtcbiAgICAgIGFyZ3MgPSByZW9yZGVyKGFyZ3MsIGFyZ1Bvcyk7XG4gICAgfSBlbHNlIGlmIChpc0ZsaXAgJiYgbGVuZ3RoID4gMSkge1xuICAgICAgYXJncy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGlmIChpc0FyeSAmJiBhcnkgPCBsZW5ndGgpIHtcbiAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgIH1cbiAgICBpZiAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSB7XG4gICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUh5YnJpZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlSHlicmlkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhcnRpYWxzIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSxcbiAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgcmVzdWx0W2xlZnRJbmRleF0gPSBwYXJ0aWFsc1tsZWZ0SW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgfVxuICB9XG4gIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2xlZnRJbmRleCsrXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvc2VBcmdzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb21wb3NlQXJncy5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgY29tcG9zZUFyZ3NgIGV4Y2VwdCB0aGF0IHRoZSBhcmd1bWVudHMgY29tcG9zaXRpb25cbiAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgIHJpZ2h0SW5kZXggPSAtMSxcbiAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgcmVzdWx0ID0gQXJyYXkocmFuZ2VMZW5ndGggKyByaWdodExlbmd0aCksXG4gICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgd2hpbGUgKCsrYXJnc0luZGV4IDwgcmFuZ2VMZW5ndGgpIHtcbiAgICByZXN1bHRbYXJnc0luZGV4XSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgfVxuICB2YXIgb2Zmc2V0ID0gYXJnc0luZGV4O1xuICB3aGlsZSAoKytyaWdodEluZGV4IDwgcmlnaHRMZW5ndGgpIHtcbiAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgfVxuICB3aGlsZSAoKytob2xkZXJzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtvZmZzZXQgKyBob2xkZXJzW2hvbGRlcnNJbmRleF1dID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvc2VBcmdzUmlnaHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvbXBvc2VBcmdzUmlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBpc0xhemlhYmxlIGZyb20gJy4vX2lzTGF6aWFibGUuanMnO1xuaW1wb3J0IHNldERhdGEgZnJvbSAnLi9fc2V0RGF0YS5qcyc7XG5pbXBvcnQgc2V0V3JhcFRvU3RyaW5nIGZyb20gJy4vX3NldFdyYXBUb1N0cmluZy5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQklORF9GTEFHID0gMSxcbiAgICBXUkFQX0JJTkRfS0VZX0ZMQUcgPSAyLFxuICAgIFdSQVBfQ1VSUllfQk9VTkRfRkxBRyA9IDQsXG4gICAgV1JBUF9DVVJSWV9GTEFHID0gOCxcbiAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHID0gNjQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGNvbnRpbnVlIGN1cnJ5aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBGdW5jIFRoZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGBmdW5jYCB3cmFwcGVyLlxuICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVjdXJyeShmdW5jLCBiaXRtYXNrLCB3cmFwRnVuYywgcGxhY2Vob2xkZXIsIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgdmFyIGlzQ3VycnkgPSBiaXRtYXNrICYgV1JBUF9DVVJSWV9GTEFHLFxuICAgICAgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkLFxuICAgICAgbmV3SG9sZGVyc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IGhvbGRlcnMsXG4gICAgICBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBwYXJ0aWFscyA6IHVuZGVmaW5lZCxcbiAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogcGFydGlhbHM7XG5cbiAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9GTEFHIDogV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICBiaXRtYXNrICY9IH4oaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHIDogV1JBUF9QQVJUSUFMX0ZMQUcpO1xuXG4gIGlmICghKGJpdG1hc2sgJiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcpKSB7XG4gICAgYml0bWFzayAmPSB+KFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHKTtcbiAgfVxuICB2YXIgbmV3RGF0YSA9IFtcbiAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBuZXdQYXJ0aWFscywgbmV3SG9sZGVycywgbmV3UGFydGlhbHNSaWdodCxcbiAgICBuZXdIb2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eVxuICBdO1xuXG4gIHZhciByZXN1bHQgPSB3cmFwRnVuYy5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICBpZiAoaXNMYXppYWJsZShmdW5jKSkge1xuICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcbiAgfVxuICByZXN1bHQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQsIGZ1bmMsIGJpdG1hc2spO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVSZWN1cnJ5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVSZWN1cnJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZVNldERhdGEgZnJvbSAnLi9fYmFzZVNldERhdGEuanMnO1xuaW1wb3J0IHNob3J0T3V0IGZyb20gJy4vX3Nob3J0T3V0LmpzJztcblxuLyoqXG4gKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gKlxuICogKipOb3RlOioqIElmIHRoaXMgZnVuY3Rpb24gYmVjb21lcyBob3QsIGkuZS4gaXMgaW52b2tlZCBhIGxvdCBpbiBhIHNob3J0XG4gKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5XG4gKiBmdW5jdGlvbiB0byBhdm9pZCBnYXJiYWdlIGNvbGxlY3Rpb24gcGF1c2VzIGluIFY4LiBTZWVcbiAqIFtWOCBpc3N1ZSAyMDcwXShodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMDcwKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldERhdGEgPSBzaG9ydE91dChiYXNlU2V0RGF0YSk7XG5cbmV4cG9ydCBkZWZhdWx0IHNldERhdGE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldERhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBnZXRXcmFwRGV0YWlscyBmcm9tICcuL19nZXRXcmFwRGV0YWlscy5qcyc7XG5pbXBvcnQgaW5zZXJ0V3JhcERldGFpbHMgZnJvbSAnLi9faW5zZXJ0V3JhcERldGFpbHMuanMnO1xuaW1wb3J0IHNldFRvU3RyaW5nIGZyb20gJy4vX3NldFRvU3RyaW5nLmpzJztcbmltcG9ydCB1cGRhdGVXcmFwRGV0YWlscyBmcm9tICcuL191cGRhdGVXcmFwRGV0YWlscy5qcyc7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYHdyYXBwZXJgIHRvIG1pbWljIHRoZSBzb3VyY2Ugb2YgYHJlZmVyZW5jZWBcbiAqIHdpdGggd3JhcHBlciBkZXRhaWxzIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBzb3VyY2UgYm9keS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGB3cmFwcGVyYC5cbiAqL1xuZnVuY3Rpb24gc2V0V3JhcFRvU3RyaW5nKHdyYXBwZXIsIHJlZmVyZW5jZSwgYml0bWFzaykge1xuICB2YXIgc291cmNlID0gKHJlZmVyZW5jZSArICcnKTtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0V3JhcFRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRXcmFwVG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBTZXRDYWNoZSBmcm9tICcuL19TZXRDYWNoZS5qcyc7XG5pbXBvcnQgYXJyYXlJbmNsdWRlcyBmcm9tICcuL19hcnJheUluY2x1ZGVzLmpzJztcbmltcG9ydCBhcnJheUluY2x1ZGVzV2l0aCBmcm9tICcuL19hcnJheUluY2x1ZGVzV2l0aC5qcyc7XG5pbXBvcnQgY2FjaGVIYXMgZnJvbSAnLi9fY2FjaGVIYXMuanMnO1xuaW1wb3J0IGNyZWF0ZVNldCBmcm9tICcuL19jcmVhdGVTZXQuanMnO1xuaW1wb3J0IHNldFRvQXJyYXkgZnJvbSAnLi9fc2V0VG9BcnJheS5qcyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgfVxuICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgIGlmIChzZXQpIHtcbiAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgfVxuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICB9XG4gIGVsc2Uge1xuICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICB9XG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VVbmlxO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVW5pcS5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VVbmlxIGZyb20gJy4vX2Jhc2VVbmlxLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSwgdXNpbmdcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGluIHdoaWNoIG9ubHkgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgZWFjaCBlbGVtZW50XG4gKiBpcyBrZXB0LiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyXG4gKiBpbiB0aGUgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVuaXEoWzIsIDEsIDJdKTtcbiAqIC8vID0+IFsyLCAxXVxuICovXG5mdW5jdGlvbiB1bmlxKGFycmF5KSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5KSA6IFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCB1bmlxO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3VuaXEuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImV4cG9ydCB0eXBlIEV4cHJlc3Npb24gPSBCaW5hcnlFeHByIHwgVW5hcnlFeHByIHwgRnVuY0NhbGwgfCBQcmltYXJ5RXhwcjtcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cbmV4cG9ydCBjbGFzcyBCaW5hcnlFeHByIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIG9wZXJhdG9yOiBzdHJpbmcsXG4gICAgICAgIHB1YmxpYyBsZWZ0T3BlcmFuZDogRXhwcmVzc2lvbixcbiAgICAgICAgcHVibGljIHJpZ2h0T3BlcmFuZDogRXhwcmVzc2lvbixcbiAgICApIHt9XG59XG5cbi8vIFVuYXJ5IEV4cHJlc3Npb25cbmV4cG9ydCBjbGFzcyBVbmFyeUV4cHIge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgb3BlcmF0b3I6IHN0cmluZyxcbiAgICAgICAgcHVibGljIG9wZXJhbmQ6IEV4cHJlc3Npb24sXG4gICAgKSB7fVxufVxuXG4vLyBGdW5jdGlvbiBjYWxsXG5leHBvcnQgY2xhc3MgRnVuY0NhbGwge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgZnVuY05hbWU6IHN0cmluZyxcbiAgICAgICAgcHVibGljIGFyZ3M6IEV4cHJlc3Npb25bXSxcbiAgICAgICAgcHVibGljIHByZUNvbXB1dGVVbmlmb3JtTmFtZTogc3RyaW5nLFxuICAgICkge31cbn1cblxuLy8gVmFyaWFibGUgYXNzaWdubWVudFxuZXhwb3J0IGNsYXNzIEFzc2lnbm1lbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgbGhzOiBQcmltYXJ5RXhwcixcbiAgICAgICAgcHVibGljIGV4cHI6IEV4cHJlc3Npb24sXG4gICAgKSB7fVxufVxuXG5leHBvcnQgdHlwZSBTdGF0ZW1lbnQgPSBFeHByZXNzaW9uIHwgQXNzaWdubWVudDtcbi8vIENvZGUgc3RhcnQgc3ltYm9sXG5leHBvcnQgY2xhc3MgUHJvZ3JhbSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBzdGF0ZW1lbnRzOiBTdGF0ZW1lbnRbXSxcbiAgICApIHt9XG59XG5cbmV4cG9ydCBlbnVtIFByaW1hcnlFeHByVHlwZSB7XG4gICAgSUQgPSBcIklEXCIsXG4gICAgQ09OU1QgPSBcIkNPTlNUXCIsXG4gICAgUkVHID0gXCJSRUdcIixcbiAgICBWQUxVRSA9IFwiVkFMVUVcIixcbn1cblxuLy8gQXRvbWljIGV4cHJlc3Npb25cbmV4cG9ydCBjbGFzcyBQcmltYXJ5RXhwciAge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgdmFsdWU6IHN0cmluZyxcbiAgICAgICAgcHVibGljIHR5cGU6IFByaW1hcnlFeHByVHlwZSxcbiAgICApIHt9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZXhwci9Bc3QudHMiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9hc3NpZ25Jbi5qcydcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9leHRlbmQuanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlU2xpY2UgZnJvbSAnLi9fYmFzZVNsaWNlLmpzJztcbmltcG9ydCB0b0ludGVnZXIgZnJvbSAnLi90b0ludGVnZXIuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRha2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IFsxXVxuICpcbiAqIF8udGFrZShbMSwgMiwgM10sIDIpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogXy50YWtlKFsxLCAyLCAzXSwgNSk7XG4gKiAvLyA9PiBbMSwgMiwgM11cbiAqXG4gKiBfLnRha2UoWzEsIDIsIDNdLCAwKTtcbiAqIC8vID0+IFtdXG4gKi9cbmZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRha2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGFrZS5qc1xuLy8gbW9kdWxlIGlkID0gMTM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VUaW1lcyBmcm9tICcuL19iYXNlVGltZXMuanMnO1xuaW1wb3J0IGNhc3RGdW5jdGlvbiBmcm9tICcuL19jYXN0RnVuY3Rpb24uanMnO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tICcuL3RvSW50ZWdlci5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB0aGUgbWF4aW11bSBsZW5ndGggYW5kIGluZGV4IG9mIGFuIGFycmF5LiAqL1xudmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogSW52b2tlcyB0aGUgaXRlcmF0ZWUgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2ZcbiAqIGVhY2ggaW52b2NhdGlvbi4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygzLCBTdHJpbmcpO1xuICogLy8gPT4gWycwJywgJzEnLCAnMiddXG4gKlxuICogIF8udGltZXMoNCwgXy5jb25zdGFudCgwKSk7XG4gKiAvLyA9PiBbMCwgMCwgMCwgMF1cbiAqL1xuZnVuY3Rpb24gdGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgbiA9IHRvSW50ZWdlcihuKTtcbiAgaWYgKG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBpbmRleCA9IE1BWF9BUlJBWV9MRU5HVEgsXG4gICAgICBsZW5ndGggPSBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCk7XG5cbiAgaXRlcmF0ZWUgPSBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpO1xuICBuIC09IE1BWF9BUlJBWV9MRU5HVEg7XG5cbiAgdmFyIHJlc3VsdCA9IGJhc2VUaW1lcyhsZW5ndGgsIGl0ZXJhdGVlKTtcbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRpbWVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RpbWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgaXNOdW1iZXIgZnJvbSBcImxvZGFzaC1lcy9pc051bWJlclwiO1xuaW1wb3J0IGlzU3RyaW5nIGZyb20gXCJsb2Rhc2gtZXMvaXNTdHJpbmdcIjtcbmltcG9ydCBpc1VuZGVmaW5lZCBmcm9tIFwibG9kYXNoLWVzL2lzVW5kZWZpbmVkXCI7XG5pbXBvcnQgUmVuZGVyaW5nQ29udGV4dCBmcm9tIFwiLi9SZW5kZXJpbmdDb250ZXh0XCI7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tIFwiLi9TaGFkZXJQcm9ncmFtXCI7XG5cbmludGVyZmFjZSBJVGV4dHVyZU5hbWVNZXRhIHtcbiAgICByZWZDb3VudDogbnVtYmVyO1xuICAgIGluZGV4OiBudW1iZXI7XG59XG5cbi8qKlxuICogVGV4dHVyZVNldE1hbmFnZXIgbWFpbnRhaW5zIGEgc2V0IG9mIG5hbWVkL2luZGV4ZWQgdGV4dHVyZXMgYW5kIG9wdGlvbmFsbHksIGFcbiAqIEZyYW1lQnVmZmVyIGZvciBvZmZzY3JlZW4gcmVuZGVyaW5nLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlU2V0TWFuYWdlciB7XG4gICAgcHJpdmF0ZSByY3R4OiBSZW5kZXJpbmdDb250ZXh0O1xuICAgIHByaXZhdGUgY29waWVyOiBTaGFkZXJQcm9ncmFtO1xuICAgIHByaXZhdGUgaW5pdFRleENvdW50OiBudW1iZXI7XG4gICAgcHJpdmF0ZSBoYXNGcmFtZUJ1ZmZlcjogYm9vbGVhbjtcbiAgICBwcml2YXRlIGZyYW1lYnVmZmVyOiBXZWJHTEZyYW1lYnVmZmVyO1xuICAgIHByaXZhdGUgbmFtZXM6IHtba2V5OiBzdHJpbmddOiBJVGV4dHVyZU5hbWVNZXRhfTtcbiAgICBwcml2YXRlIHRleHR1cmVzOiBXZWJHTFRleHR1cmVbXTtcbiAgICBwcml2YXRlIGN1clRleDogbnVtYmVyO1xuICAgIHByaXZhdGUgb2xkVGV4dHVyZTogV2ViR0xUZXh0dXJlO1xuICAgIHByaXZhdGUgb2xkRnJhbWVCdWZmZXI6IFdlYkdMRnJhbWVidWZmZXI7XG4gICAgcHJpdmF0ZSBpc1JlbmRlclRhcmdldDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dHVyZVNldE1hbmFnZXJcbiAgICAgKiBAcGFyYW0gcmN0eCB0aGUgcmVuZGVyaW5nIGNvbnRleHQgaW4gd2hpY2ggdGhlIHRleHR1cmVzIGFuZCBidWZmZXJzIHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIEBwYXJhbSBjb3BpZXIgYW4gaW5zdGFuY2Ugb2YgYSBjb3BpZXIgcHJvZ3JhbVxuICAgICAqIEBwYXJhbSBoYXNGcmFtZUJ1ZmZlciBpZiB0cnVlLCB0aGVuIGEgRnJhbWVCdWZmZXIgaXMgYWxzbyBjcmVhdGVkXG4gICAgICogQHBhcmFtIHRleENvdW50IGluaXRpYWwgbnVtYmVyIG9mIHRleHR1cmVzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmN0eDogUmVuZGVyaW5nQ29udGV4dCwgY29waWVyOiBTaGFkZXJQcm9ncmFtLCBoYXNGcmFtZUJ1ZmZlcjogYm9vbGVhbiA9IGZhbHNlLCB0ZXhDb3VudDogbnVtYmVyID0gMikge1xuICAgICAgICB0aGlzLnJjdHggPSByY3R4O1xuICAgICAgICB0aGlzLmNvcGllciA9IGNvcGllcjtcbiAgICAgICAgdGhpcy5pbml0VGV4Q291bnQgPSB0ZXhDb3VudDtcbiAgICAgICAgdGhpcy5oYXNGcmFtZUJ1ZmZlciA9IGhhc0ZyYW1lQnVmZmVyO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIG5hbWUgbmFtZSBvZiB0aGUgdGV4dHVyZVxuICAgICAqL1xuICAgIHB1YmxpYyBhZGRUZXh0dXJlKG5hbWU/OiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICBpZiAobmFtZSAmJiBuYW1lIGluIHRoaXMubmFtZXMpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZXNbbmFtZV0ucmVmQ291bnQrKztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVzW25hbWVdLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5yY3R4LmdldEdsKCk7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlcy5wdXNoKHRleHR1cmUpO1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy50ZXh0dXJlcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgIHJlZkNvdW50OiAxLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlcy5sZW5ndGggLSAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIG5hbWVPckluZGV4IG5hbWUgb3IgaW5kZXggb2YgdGhlIHRleHR1cmUgdG8gYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmVUZXh0dXJlKG5hbWVPckluZGV4OiBzdHJpbmcgfCBudW1iZXIpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKG5hbWVPckluZGV4KSAmJiBuYW1lT3JJbmRleCBpbiB0aGlzLm5hbWVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lc1tuYW1lT3JJbmRleF0ucmVmQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lc1tuYW1lT3JJbmRleF0ucmVmQ291bnQtLTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmZpbmRJbmRleChuYW1lT3JJbmRleCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5jdXJUZXggJiYgKHRoaXMub2xkVGV4dHVyZSB8fCB0aGlzLm9sZEZyYW1lQnVmZmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSBjdXJyZW50IHRleHR1cmUgd2hlbiBzZXQgYXMgcmVuZGVyIHRhcmdldFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnbCA9IHRoaXMucmN0eC5nZXRHbCgpO1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZXNbaW5kZXhdKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpZiAodGhpcy5jdXJUZXggPj0gdGhpcy50ZXh0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyVGV4ID0gdGhpcy50ZXh0dXJlcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZU9ySW5kZXggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5hbWVzW25hbWVPckluZGV4XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdGV4dHVyZSBhcyB0aGUgZnJhbWUgYnVmZmVyIGF0dGFjaG1lbnQuIElmIGBoYXNGcmFtZUJ1ZmZlcmAgaXMgdHJ1ZVxuICAgICAqIHRoZW4gdGhlIEZyYW1lQnVmZmVyIG1hbmFnZXIgaXMgYm91bmQgYW5kIHRoZSB0ZXh0dXJlIGlzIHNldCBhcyB0aGUgZnJhbWUgYnVmZmVyIGF0dGFjaG1lbnQuXG4gICAgICogQHBhcmFtIHRleE5hbWUgbmFtZSBvZiB0aGUgdGV4dHVyZSB0byBzZXQgYXMgdGFyZ2V0LiBJZiB1bmRlZmluZWQgdGhlbiB3ZSBjeWNsZVxuICAgICAqICAgICAgICAgICAgICAgIHRocm91Z2ggdG8gbmV4dCB0ZXh0dXJlXG4gICAgICovXG4gICAgcHVibGljIHNldEFzUmVuZGVyVGFyZ2V0KHRleE5hbWU/OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnJjdHguZ2V0R2woKTtcbiAgICAgICAgY29uc3QgY3VyRnJhbWVCdWZmZXIgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuRlJBTUVCVUZGRVJfQklORElORykgYXMgV2ViR0xGcmFtZWJ1ZmZlcjtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZyYW1lQnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoIWN1ckZyYW1lQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB0ZXh0dXJlIHdoZW4gY3VycmVudCByZW5kZXJ0YXJnZXQgaXMgdGhlIGRlZmF1bHQgRnJhbWVCdWZmZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9sZFRleHR1cmUgPSBnbC5nZXRGcmFtZWJ1ZmZlckF0dGFjaG1lbnRQYXJhbWV0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2wuQ09MT1JfQVRUQUNITUVOVDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2wuRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfTkFNRSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9sZEZyYW1lQnVmZmVyID0gY3VyRnJhbWVCdWZmZXI7XG4gICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSZW5kZXJUYXJnZXQgPSB0cnVlO1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRleE5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnN3aXRjaFRleHR1cmUodGV4TmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlc1t0aGlzLmN1clRleF07XG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmUsIDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgdGhlIHRleHR1cmUgYXR0YWNobWVudCBvciBmcmFtZWJ1ZmZlciB0aGF0IHdhcyBzZXRcbiAgICAgKiB3aXRoIGEgcHJldmlvdXMgY2FsbCB0byBbW1RleHR1cmVTZXRNYW5hZ2VyLnNldEFzUmVuZGVyVGFyZ2V0XV1cbiAgICAgKi9cbiAgICBwdWJsaWMgdW5zZXRBc1JlbmRlclRhcmdldCgpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnJjdHguZ2V0R2woKTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZyYW1lQnVmZmVyKSB7XG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2xkVGV4dHVyZSwgMCk7XG4gICAgICAgICAgICB0aGlzLm9sZFRleHR1cmUgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLm9sZEZyYW1lQnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMub2xkRnJhbWVCdWZmZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSZW5kZXJUYXJnZXQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRleHR1cmUuXG4gICAgICpcbiAgICAgKiBUZXh0dXJlU2V0TWFuYWdlciBoYXMgdGhpcyBub3Rpb24gb2YgY3VycmVudCB0ZXh0dXJlXG4gICAgICogdGhhdCBpdCBjYW4gY3ljbGUgdGhyb3VnaCB0aGUgc2V0IG9mIGFsbCB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q3VycmVudFRleHR1cmUoKTogV2ViR0xUZXh0dXJlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZXNbdGhpcy5jdXJUZXhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRleHR1cmUgYXQgZ2l2ZW4gaW5kZXggb3Igd2l0aCBnaXZlbiBuYW0sZVxuICAgICAqIEBwYXJhbSBuYW1lb3JJbmRleCBuYW1lIG9mIGluZGV4IG9mIHRoZSB0ZXh0dXJlIHRvIGJlIHJldHVybmVkXG4gICAgICovXG4gICAgcHVibGljIGdldFRleHR1cmUobmFtZU9ySW5kZXg6IHN0cmluZyB8IG51bWJlcik6IFdlYkdMVGV4dHVyZSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5maW5kSW5kZXgobmFtZU9ySW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlc1tpbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHByZXZpb3VzIHRleHR1cmUgaW50byBjdXJyZW50IHRleHR1cmUuXG4gICAgICovXG4gICAgcHVibGljIGNvcHlPdmVyKCkge1xuICAgICAgICBjb25zdCB0ZXhDb3VudCA9IHRoaXMudGV4dHVyZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBwcmV2VGV4dHVyZSA9IHRoaXMudGV4dHVyZXNbKHRleENvdW50ICsgdGhpcy5jdXJUZXggLSAxKSAlIHRleENvdW50XTtcbiAgICAgICAgdGhpcy5jb3BpZXIucnVuKG51bGwsIHtzcmNUZXh0dXJlOiBwcmV2VGV4dHVyZX0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdGV4dHVyZSBhbmQgc2V0cyBpdCBhcyB0aGUgY3VycmVudCBmcmFtZSBidWZmZXIgYXR0YWNobWVudFxuICAgICAqIEBwYXJhbSBuYW1lT3JJbmRleCBuYW1lIG9yIGluZGV4IG9mIHRoZSB0ZXh0dXJlLiBJZiB1bmRlZmluZWQgdGhlbiB3ZSBjeWNsZSB0aHJvdWdoXG4gICAgICogICAgICAgICAgICAgICAgICAgIHRvIG5leHQgdGV4dHVyZVxuICAgICAqL1xuICAgIHB1YmxpYyBzd2l0Y2hUZXh0dXJlKG5hbWVPckluZGV4OiBzdHJpbmcgfCBudW1iZXIgPSAodGhpcy5jdXJUZXggKyAxKSAlIHRoaXMudGV4dHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1JlbmRlclRhcmdldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN3aXRjaCB0ZXh0dXJlIHdoZW4gbm90IHNldCBhcyByZW5kZXJ0YXJnZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnJjdHguZ2V0R2woKTtcbiAgICAgICAgdGhpcy5jdXJUZXggPSB0aGlzLmZpbmRJbmRleChuYW1lT3JJbmRleCk7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmVzW3RoaXMuY3VyVGV4XTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNpemVzIGFsbCB0ZXh0dXJlc1xuICAgICAqL1xuICAgIHB1YmxpYyByZXNpemUoKSB7XG4gICAgICAgIC8vIFRPRE86IGludmVzdGlnYXRlIGNocm9tZSB3YXJuaW5nOiBJTlZBTElEX09QRVJBVElPTjogbm8gdGV4dHVyZVxuICAgICAgICBjb25zdCBnbCA9IHRoaXMucmN0eC5nZXRHbCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHRleHR1cmUgb2YgdGhpcy50ZXh0dXJlcykge1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhbGwgdGV4dHVyZSBhbmQgZnJhbWVidWZmZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnJjdHguZ2V0R2woKTtcbiAgICAgICAgZm9yIChjb25zdCB0ZXh0dXJlIG9mIHRoaXMudGV4dHVyZXMpIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzRnJhbWVCdWZmZXIpIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbml0KCkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMucmN0eC5nZXRHbCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZyYW1lQnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmFtZXMgPSB7fTtcbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5pdFRleENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VyVGV4ID0gMDtcbiAgICAgICAgdGhpcy5pc1JlbmRlclRhcmdldCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZmluZEluZGV4KGFyZzogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBpZiAoaXNTdHJpbmcoYXJnKSAmJiBhcmcgaW4gdGhpcy5uYW1lcykge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLm5hbWVzW2FyZ10uaW5kZXg7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoYXJnKSAmJiBhcmcgPj0gMCAmJiBhcmcgPCB0aGlzLnRleHR1cmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaW5kZXggPSBhcmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJhcmcgPSBcIiwgdHlwZW9mKGFyZyksIFwidGV4dHVyZXMgPSBcIiwgdGhpcy50ZXh0dXJlcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRleHR1cmUgJ1wiICsgYXJnICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvd2ViZ2wvVGV4dHVyZVNldE1hbmFnZXIudHMiLCJpbXBvcnQgeyBCbGVuZE1vZGUsIENvbG9yLCBXZWJHTFZhclR5cGUgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCBSZW5kZXJpbmdDb250ZXh0IGZyb20gXCIuL1JlbmRlcmluZ0NvbnRleHRcIjtcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gXCIuL1NoYWRlclByb2dyYW1cIjtcblxuLyoqXG4gKiBWYWx1ZXMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIFtbQ2xlYXJTY3JlZW5Qcm9ncmFtLnJ1bl1dXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNsZWFyU2NyZWVuUHJvZ3JhbVZhbHVlcyB7XG4gICAgLyoqXG4gICAgICogQ29sb3IgdG8gd2hpY2ggdGhlIHNjcmVlbiBzaG91bGQgYmUgY2xlYXJlZFxuICAgICAqL1xuICAgIGNvbG9yOiBDb2xvcjtcbn1cblxuLyoqXG4gKiBBIFNoYWRlciBwcm9ncmFtIHRoZSBjbGVhcnMgdGhlIHNjcmVlbiB0byBhIGdpdmVuIGNvbG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENsZWFyU2NyZWVuUHJvZ3JhbSBleHRlbmRzIFNoYWRlclByb2dyYW08SUNsZWFyU2NyZWVuUHJvZ3JhbVZhbHVlcz4ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IENsZWFyU2NyZWVuUHJvZ3JhbVxuICAgICAqIEBwYXJhbSByY3R4IHRoZSByZW5kZXJpbmcgY29udGV4dCBpbiB3aGljaCB0byBjcmVhdGUgdGhpcyBzaGFkZXJcbiAgICAgKiBAcGFyYW0gYmxlbmRNb2RlIGJsZW5kIG1vZGUgZm9yIHRoaXMgc2hhZGVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmN0eDogUmVuZGVyaW5nQ29udGV4dCwgYmxlbmRNb2RlOiBCbGVuZE1vZGUpIHtcbiAgICAgICAgc3VwZXIocmN0eCwge1xuICAgICAgICAgICAgYmluZGluZ3M6IHtcbiAgICAgICAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogeyBuYW1lOiBcInVfY29sb3JcIiwgdmFsdWVUeXBlOiBXZWJHTFZhclR5cGUuXzNGVn0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibGVuZE1vZGUsXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogYFxuICAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjMyB1X2NvbG9yO1xuICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICBzZXRGcmFnQ29sb3IodmVjNCh1X2NvbG9yLCAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3dlYmdsL0NsZWFyU2NyZWVuUHJvZ3JhbS50cyIsImltcG9ydCB7IENoYW5uZWxzLCBGbG9hdEFycmF5IH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5cbi8qKlxuICogQW5hbHlzZXJBZGFwdGVyIGFkYXB0cyBtdXNpYyBkYXRhIGFuYWx5c2VycyBzbyB0aGF0IGl0IGNhbiBiZSBwbHVnZ2VkIGludG8gV2VidnMuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgdG8gc2VuZCBtdXNpYyBkYXRhIGludG8gd2VidnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgQW5hbHlzZXJBZGFwdGVyIHtcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIGEgYmVhdFxuICAgICAqIGlzIGluIHByb2dyZXNzIG9yIG5vdFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBpc0JlYXQoKTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBldmVyeSBmcmFtZS4gT3ZlcnJpZGUgYW5kIGltcGxlbWVudCBhbmFseXNlciBjb2RlXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IHVwZGF0ZSgpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhcnJheSBvZiB3YXZlZm9ybSB2YWx1ZXMuIE92ZXJyaWRlIGFuZCBpbXBsZW1lbnQgYW5hbHlzZXIgY29kZVxuICAgICAqIEBwYXJhbSBjaGFubmVsIGNoYW5uZWwgZm9yIHdoaWNoIHdhdmVmb3JtIGRhdGEgd2lsbCBiZSByZXR1cm5lZFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRXYXZlZm9ybShjaGFubmVsPzogQ2hhbm5lbHMpOiBGbG9hdEFycmF5O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhcnJheSBvZiBzcGVjdHJ1bSB2YWx1ZXMuIE92ZXJyaWRlIGFuZCBpbXBsZW1lbnQgYW5hbHlzZXIgY29kZVxuICAgICAqIEBwYXJhbSBjaGFubmVsIGNoYW5uZWwgZm9yIHdoaWNoIHNwZWN0cnVtIGRhdGEgd2lsbCBiZSByZXR1cm5lZFxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRTcGVjdHJ1bShjaGFubmVsPzogQ2hhbm5lbHMpOiBGbG9hdEFycmF5O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FuYWx5c2VyL0FuYWx5c2VyQWRhcHRlci50cyIsImltcG9ydCBNYWluIGZyb20gJy4vc3JjL01haW4nO1xyXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vc3JjL0NvbXBvbmVudCc7XHJcbmltcG9ydCBXZWJBdWRpb0FuYWx5c2VyIGZyb20gJy4vc3JjL2FuYWx5c2VyL1dlYkF1ZGlvQW5hbHlzZXInO1xyXG5pbXBvcnQgQW5hbHlzZXJBZGFwdGVyIGZyb20gJy4vc3JjL2FuYWx5c2VyL0FuYWx5c2VyQWRhcHRlcic7XHJcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gJy4vc3JjL3dlYmdsL1NoYWRlclByb2dyYW0nO1xyXG5cclxuY29uc3QgV2VidnMgPSB7XHJcbiAgICBNYWluLCBDb21wb25lbnQsIFNoYWRlclByb2dyYW0sXHJcbiAgICBXZWJBdWRpb0FuYWx5c2VyLCBBbmFseXNlckFkYXB0ZXIsXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBXZWJ2cztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9pbmRleC50cyIsImltcG9ydCBjbG9uZSBmcm9tIFwibG9kYXNoLWVzL2Nsb25lXCI7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSBcImxvZGFzaC1lcy9kZWZhdWx0c1wiO1xuaW1wb3J0IHBpY2sgZnJvbSBcImxvZGFzaC1lcy9waWNrXCI7XG5pbXBvcnQgU3RhdHMgZnJvbSBcInN0YXRzLmpzXCI7XG5pbXBvcnQgQW5hbHlzZXJBZGFwdGVyIGZyb20gXCIuL2FuYWx5c2VyL0FuYWx5c2VyQWRhcHRlclwiO1xuaW1wb3J0IGJ1aWx0aW5SZXNvdXJjZVBhY2sgZnJvbSBcIi4vYnVpbHRpblJlc291cmNlUGFja1wiO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi9Db21wb25lbnRcIjtcbmltcG9ydCBDb21wb25lbnRSZWdpc3RyeSBmcm9tIFwiLi9Db21wb25lbnRSZWdpc3RyeVwiO1xuaW1wb3J0IEVmZmVjdExpc3QgZnJvbSBcIi4vRWZmZWN0TGlzdFwiO1xuaW1wb3J0IElNYWluIGZyb20gXCIuL0lNYWluXCI7XG5pbXBvcnQgQnVmZmVyU2F2ZSBmcm9tIFwiLi9taXNjL0J1ZmZlclNhdmVcIjtcbmltcG9ydCBHbG9iYWxWYXIgZnJvbSBcIi4vbWlzYy9HbG9iYWxWYXJcIjtcbmltcG9ydCBNb2RlbCBmcm9tIFwiLi9Nb2RlbFwiO1xuaW1wb3J0IENsZWFyU2NyZWVuIGZyb20gXCIuL3JlbmRlci9DbGVhclNjcmVlblwiO1xuaW1wb3J0IE1vdmluZ1BhcnRpY2xlIGZyb20gXCIuL3JlbmRlci9Nb3ZpbmdQYXJ0aWNsZVwiO1xuaW1wb3J0IFBpY3R1cmUgZnJvbSBcIi4vcmVuZGVyL1BpY3R1cmVcIjtcbmltcG9ydCBTdXBlclNjb3BlIGZyb20gXCIuL3JlbmRlci9TdXBlclNjb3BlXCI7XG5pbXBvcnQgVGV4ZXIgZnJvbSBcIi4vcmVuZGVyL1RleGVyXCI7XG5pbXBvcnQgUmVzb3VyY2VNYW5hZ2VyIGZyb20gXCIuL1Jlc291cmNlTWFuYWdlclwiO1xuaW1wb3J0IENoYW5uZWxTaGlmdCBmcm9tIFwiLi90cmFucy9DaGFubmVsU2hpZnRcIjtcbmltcG9ydCBDb2xvckNsaXAgZnJvbSBcIi4vdHJhbnMvQ29sb3JDbGlwXCI7XG5pbXBvcnQgQ29sb3JNYXAgZnJvbSBcIi4vdHJhbnMvQ29sb3JNYXBcIjtcbmltcG9ydCBDb252b2x1dGlvbiBmcm9tIFwiLi90cmFucy9Db252b2x1dGlvblwiO1xuaW1wb3J0IER5bmFtaWNNb3ZlbWVudCBmcm9tIFwiLi90cmFucy9EeW5hbWljTW92ZW1lbnRcIjtcbmltcG9ydCBGYWRlT3V0IGZyb20gXCIuL3RyYW5zL0ZhZGVPdXRcIjtcbmltcG9ydCBJbnZlcnQgZnJvbSBcIi4vdHJhbnMvSW52ZXJ0XCI7XG5pbXBvcnQgTWlycm9yIGZyb20gXCIuL3RyYW5zL01pcnJvclwiO1xuaW1wb3J0IE1vc2FpYyBmcm9tIFwiLi90cmFucy9Nb3NhaWNcIjtcbmltcG9ydCBVbmlxdWVUb25lIGZyb20gXCIuL3RyYW5zL1VuaXF1ZVRvbmVcIjtcbmltcG9ydCB7Y2hlY2tSZXF1aXJlZE9wdGlvbnN9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgQnVmZmVyIGZyb20gXCIuL3dlYmdsL0J1ZmZlclwiO1xuaW1wb3J0IENvcHlQcm9ncmFtIGZyb20gXCIuL3dlYmdsL0NvcHlQcm9ncmFtXCI7XG5pbXBvcnQgUmVuZGVyaW5nQ29udGV4dCBmcm9tIFwiLi93ZWJnbC9SZW5kZXJpbmdDb250ZXh0XCI7XG5pbXBvcnQgVGV4dHVyZVNldE1hbmFnZXIgZnJvbSBcIi4vd2ViZ2wvVGV4dHVyZVNldE1hbmFnZXJcIjtcblxuZGVjbGFyZSB2YXIgV0VCVlNfVkVSU0lPTjogc3RyaW5nO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIE1haW4gY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJTWFpbk9wdHMge1xuICAgIC8qKlxuICAgICAqIENhbnZhcyBlbGVtZW50IGluIHdoaWNoIHRoZSB2aXN1YWxpemF0aW9uIHdpbGwgYmUgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50O1xuICAgIC8qKlxuICAgICAqIGFuIGFuYWx5c2VyIHRoYXQgd2lsbCBwcm92aWRlIG11c2ljIGRhdGEgZm9yIHRoZSB2aXN1YWxpemF0aW9uc1xuICAgICAqL1xuICAgIGFuYWx5c2VyOiBBbmFseXNlckFkYXB0ZXI7XG4gICAgLyoqXG4gICAgICogc2hvdyBvciBoaWRlIHBlcmZvcm1hbmNlIHN0YXRzXG4gICAgICovXG4gICAgc2hvd1N0YXQ/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGJha2VkLWluIHJlc291cmNlIHVybCBwcmVmaXggZm9yIGJ1aWx0aW4gcmVzb3VyY2VzXG4gICAgICovXG4gICAgcmVzb3VyY2VQcmVmaXg/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQ3VzdG9tIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gVXNlZnVsIGZvciB0ZXN0aW5nL2N1c3RvbSBmcmFtZS1yYXRlIGNvbnRyb2wuXG4gICAgICogVXNlIHRvZ2V0aGVyIHdpdGggW1tjYW5jZWxBbmltYXRpb25GcmFtZV1dXG4gICAgICovXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lPzogKGNhbGxiYWNrOiAoKSA9PiB2b2lkKSA9PiBhbnk7XG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGNhbmNlbEFuaW1hdGlvbkZyYW1lLiBVc2VmdWwgZm9yIHRlc3RpbmcvY3VzdG9tIGZyYW1lLXJhdGUgY29udHJvbC5cbiAgICAgKiBVc2UgdG9nZXRoZXIgd2l0aCBbW3JlcXVlc3RBbmltYXRpb25GcmFtZV1dXG4gICAgICovXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWU/OiAocmVxSWQ6IGFueSkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBNYWluIGlzIHRoZSBwcmltYXJ5IGludGVyZmFjZSB0aGF0IGNvbnRyb2xzIGxvYWRpbmcgb2YgcHJlc2V0cywgc3RhcnRpbmcgc3RvcHBpbmcgYW5pbWF0aW9ucywgZXRjLlxuICogSXQgbWFpbnRhaW5zIHRoZSByb290IENvbXBvbmVudCBhbmQgdGhlIGhpZXJhcmNoeSBvZiBjb21wb25lbnRzIHVuZGVyIGl0LlxuICogQSB0eXBpY2FsIHVzYWdlIGludm9sdmVzIGNyZWF0aW5nIGFuIEFuYWx5c2VyIGFuZCBhIE1haW4gb2JqZWN0LiBUaGUgQW5hbHlzZXIgaW50ZXJmYWNlcyB3aXRoIHlvdXJcbiAqIGF1ZGlvIHNvdXJjZSBhbmQgZ2VuZXJhdGVzIHRoZSB2aXN1YWxpemF0aW9uIGRhdGEsIHdoaWxlIHRoZSBNYWluIG9iamVjdCBzZXJ2ZXMgYXMgdGhlIHByaW1hcnlcbiAqIGludGVyZmFjZSBmb3IgY29udHJvbGxpbmcgdGhlIHZpc3VhbGl6YXRpb24uIEUuZzpcbiAqIGBgYFxuICogY29uc3QgYW5hbHlzZXIgPSBuZXcgV2VidnMuV2ViQXVkaW9BbmFseXNlcigpO1xuICogY29uc3Qgd2VidnMgPSBuZXcgV2VidnMuTWFpbih7XG4gKiAgICAgY2FudmFzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbnZhc1wiKSxcbiAqICAgICBhbmFseXNlcjogYW5hbHlzZXIsXG4gKiAgICAgc2hvd1N0YXQ6IHRydWVcbiAqIH0pO1xuICogd2VidnMubG9hZFByZXNldCh7XG4gKiAgIFwiY2xlYXJGcmFtZVwiOiB0cnVlLFxuICogICBcImNvbXBvbmVudHNcIjogW1xuICogICAgICAge1xuICogICAgICAgICAgIFwidHlwZVwiOiBcIlN1cGVyU2NvcGVcIixcbiAqICAgICAgICAgICBcInNvdXJjZVwiOiBcIldBVkVGT1JNXCIsXG4gKiAgICAgICAgICAgXCJjb2RlXCI6IHtcbiAqICAgICAgICAgICAgICAgXCJwZXJQb2ludFwiOiBcIng9aSoyLTE7eT12O1wiXG4gKiAgICAgICAgICAgfSxcbiAqICAgICAgICAgICBcImNvbG9yc1wiOiBbXCIjZmZmZmZmXCJdXG4gKiAgICAgICB9XG4gKiAgIF1cbiAqIH0pO1xuICogd2VidnMuc3RhcnQoKTtcbiAqIGFuYWx5c2VyLmxvYWQoXCJtdXNpYy5vZ2dcIik7XG4gKiBhbmFseXNlci5wbGF5KCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpbiBleHRlbmRzIE1vZGVsIGltcGxlbWVudHMgSU1haW4ge1xuICAgIC8qKlxuICAgICAqIHZlcnNpb24gb2YgV2VidnMgbGlicmFyeVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgdmVyc2lvbjogc3RyaW5nID0gV0VCVlNfVkVSU0lPTjtcbiAgICBwcml2YXRlIGFuYWx5c2VyOiBBbmFseXNlckFkYXB0ZXI7XG4gICAgcHJpdmF0ZSByc3JjTWFuOiBSZXNvdXJjZU1hbmFnZXI7XG4gICAgcHJpdmF0ZSByY3R4OiBSZW5kZXJpbmdDb250ZXh0O1xuICAgIHByaXZhdGUgY29waWVyOiBDb3B5UHJvZ3JhbTtcbiAgICBwcml2YXRlIGNvbXBvbmVudFJlZ2lzdHJ5OiBDb21wb25lbnRSZWdpc3RyeTtcbiAgICBwcml2YXRlIHRlbXBUU006IFRleHR1cmVTZXRNYW5hZ2VyO1xuICAgIHByaXZhdGUgcmVnaXN0ZXJCYW5rOiB7W2tleTogc3RyaW5nXTogbnVtYmVyfTtcbiAgICBwcml2YXRlIGJvb3RUaW1lOiBudW1iZXI7XG5cbiAgICBwcml2YXRlIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgcHJpdmF0ZSBpc1N0YXJ0ZWQ6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBzdGF0czogU3RhdHM7XG4gICAgcHJpdmF0ZSBtZXRhOiBhbnk7XG4gICAgcHJpdmF0ZSByb290Q29tcG9uZW50OiBDb21wb25lbnQ7XG4gICAgcHJpdmF0ZSBhbmltUmVxSWQ6IG51bWJlcjtcbiAgICBwcml2YXRlIGJ1ZmZlcnM6IHtbbmFtZTogc3RyaW5nXTogQnVmZmVyfTtcbiAgICBwcml2YXRlIHJlcXVlc3RBbmltYXRpb25GcmFtZTogKGNhbGxiYWNrOiAoKSA9PiB2b2lkKSA9PiBhbnk7XG4gICAgcHJpdmF0ZSBjYW5jZWxBbmltYXRpb25GcmFtZTogKHJlcUlkOiBhbnkpID0+IHZvaWQ7XG4gICAgcHJpdmF0ZSBwcmVzZXRSZXNvdXJjZUtleXM6IHN0cmluZ1tdID0gW107XG4gICAgcHJpdmF0ZSBjb250ZXh0TG9zdEhhbmRlcjogKGV2ZW50OiBhbnkpID0+IHZvaWQ7XG4gICAgcHJpdmF0ZSBjb250ZXh0UmVzdG9yZWRIYW5kZXI6IChldmVudDogYW55KSA9PiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIFdlYnZzIE1haW4gb2JqZWN0IHRoYXQgY2FuIGxvYWQgYW5kIHJlbmRlciB2aXN1YWxpemF0aW9uIHByZXNldHNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zIGZvciBNYWluXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogSU1haW5PcHRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGNoZWNrUmVxdWlyZWRPcHRpb25zKG9wdGlvbnMsIFtcImNhbnZhc1wiLCBcImFuYWx5c2VyXCJdKTtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIHNob3dTdGF0OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gb3B0aW9ucy5jYW52YXM7XG4gICAgICAgIHRoaXMuYW5hbHlzZXIgPSBvcHRpb25zLmFuYWx5c2VyO1xuICAgICAgICB0aGlzLmlzU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgb3B0aW9ucy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBvcHRpb25zLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBvcHRpb25zLmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnNob3dTdGF0KSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IG5ldyBTdGF0cygpO1xuICAgICAgICAgICAgc3RhdHMuc2V0TW9kZSgwKTtcbiAgICAgICAgICAgIHN0YXRzLmRvbUVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICBzdGF0cy5kb21FbGVtZW50LnN0eWxlLnJpZ2h0ID0gXCI1cHhcIjtcbiAgICAgICAgICAgIHN0YXRzLmRvbUVsZW1lbnQuc3R5bGUuYm90dG9tID0gXCI1cHhcIjtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHMuZG9tRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRzID0gc3RhdHM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1ldGEgPSB7fTtcbiAgICAgICAgdGhpcy5idWZmZXJzID0ge307XG4gICAgICAgIHRoaXMuX2luaXRDb21wb25lbnRSZWdpc3RyeSgpO1xuICAgICAgICB0aGlzLl9pbml0UmVzb3VyY2VNYW5hZ2VyKG9wdGlvbnMucmVzb3VyY2VQcmVmaXggfHwgXCJcIik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyQ29udGV4dEV2ZW50cygpO1xuICAgICAgICB0aGlzLl9pbml0R2woKTtcbiAgICAgICAgdGhpcy5fc2V0dXBSb290KHtpZDogXCJyb290XCJ9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydHMgcnVubmluZyB0aGUgYW5pbWF0aW9uIHdoZW4gcmVhZHkuIFRoZSBhbmltYXRpb24gbWF5IG5vdCBzdGFydFxuICAgICAqIHBsYXlpbmcgaW1tZWRpYXRlbHkgYmVjYXVzZSBwcmVzZXQgbWF5IHVzZSBleHRlcm5hbCByZXNvdXJjZXMgd2hpY2hcbiAgICAgKiBuZWVkcyB0byBiZSBsb2FkZWQgYXN5bmNocm9ub3VzbHkgYnkgdGhlIHJlc291cmNlIG1hbmFnZXIuXG4gICAgICovXG4gICAgcHVibGljIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RhcnRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnJzcmNNYW4ucmVhZHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgYW5pbWF0aW9uXG4gICAgICovXG4gICAgcHVibGljIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5yc3JjTWFuLnJlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIHByZXNldCBpbnRvIHRoaXMgd2VidnMgbWFpbiBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcmVzZXQgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHByZXNldC4gVGhlIHJvb3Qgb2JqZWN0IHNob3VsZFxuICAgICAqIGhhdmUgYSBgY29tcG9uZW50c2AgcHJvcGVydHkgd2hpY2ggd2lsbCBjb250YWluIGFuIEFycmF5IGZvciBjb21wb25lbnQgY29uZmlndXJhdGlvbnNcbiAgICAgKiBmb3IgYWxsIHRoZSBjb21wb25lbnRzLiBBbGwgY29tcG9uZW50IGNvbmZpZ3VyYXRpb25zIHNob3VsZCBoYXZlIGFcbiAgICAgKiBgdHlwZWAgcHJvcGVydHkgY29udGFpbmluZyB0aGUgc3RyaW5nIG5hbWUgb2YgdGhlIENvbXBvbmVudC4gT3RoZXJcbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSBzcGVjaWZpYyB0byBlYWNoIGNvbXBvbmVudC4gVGhlIGByZXNvdXJjZXMudXJpc2AgcHJvcGVydHlcbiAgICAgKiBpbiBwcmVzZXQgaXMgdXNlZCB0byByZWdpc3RlciByZXNvdXJjZXMgd2l0aCBbW1Jlc291cmNlTWFuYWdlcl1dIGFuZCBoYXNcbiAgICAgKiB0aGUgc2FtZSBmb3JtYXQgYWNjZXB0ZWQgYnkgdGhlIFtbUmVzb3VyY2VNYW5hZ2VyLnJlZ2lzdGVyVXJpXV0uXG4gICAgICovXG4gICAgcHVibGljIGxvYWRQcmVzZXQocHJlc2V0OiBhbnkpIHtcbiAgICAgICAgcHJlc2V0ID0gY2xvbmUocHJlc2V0KTsgLy8gdXNlIG91ciBvd24gY29weVxuICAgICAgICBwcmVzZXQuaWQgPSBcInJvb3RcIjtcbiAgICAgICAgdGhpcy5yb290Q29tcG9uZW50LmRlc3Ryb3koKTtcblxuICAgICAgICAvLyBzZXR1cCByZXNvdXJjZXNcbiAgICAgICAgdGhpcy5yc3JjTWFuLmNsZWFyKHRoaXMucHJlc2V0UmVzb3VyY2VLZXlzKTtcbiAgICAgICAgaWYgKFwicmVzb3VyY2VzXCIgaW4gcHJlc2V0ICYmIFwidXJpc1wiIGluIHByZXNldC5yZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMucnNyY01hbi5yZWdpc3RlclVyaShwcmVzZXQucmVzb3VyY2VzLnVyaXMpO1xuICAgICAgICAgICAgdGhpcy5wcmVzZXRSZXNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhwcmVzZXQucmVzb3VyY2VzLnVyaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcmVzZXRSZXNvdXJjZUtleXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxvYWQgbWV0YVxuICAgICAgICB0aGlzLm1ldGEgPSBjbG9uZShwcmVzZXQubWV0YSk7XG5cbiAgICAgICAgdGhpcy5fc2V0dXBSb290KHByZXNldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFuZCByZWluaXRpYWxpemVzIGFsbCB0aGUgY29tcG9uZW50cyBhbmQgY2FudmFzLlxuICAgICAqL1xuICAgIHB1YmxpYyByZXNldENhbnZhcygpIHtcbiAgICAgICAgY29uc3QgcHJlc2V0ID0gdGhpcy5yb290Q29tcG9uZW50LnRvSlNPTigpO1xuICAgICAgICB0aGlzLnJvb3RDb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRlbXBUU00uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9pbml0R2woKTtcbiAgICAgICAgdGhpcy5fc2V0dXBSb290KHByZXNldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGlmIHRoZSBjYW52YXMgZWxlbWVudCdzXG4gICAgICogd2lkdGggb3IgaGVpZ2h0IGF0dHJpYnV0ZSBoYXMgY2hhbmdlZC4gVGhpcyBhbGxvd3MgV2VidnNcbiAgICAgKiB0byB1cGRhdGUgYW5kIHJlc2l6ZSBhbGwgdGhlIGJ1ZmZlcnMuXG4gICAgICovXG4gICAgcHVibGljIG5vdGlmeVJlc2l6ZSgpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnJjdHguZ2V0R2woKTtcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgICAgICAgdGhpcy50ZW1wVFNNLnJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmVtaXQoXCJyZXNpemVcIiwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWNoZSB3ZWJnbCBCdWZmZXJzLiBVc2VmdWwgdG8gc3RvcmUgYnVmZmVycyB0aGF0IGNhbiBiZSBzaGFyZWQuIGUuZy4gZ2VvbWV0cmllcy5cbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBidWZmZXJcbiAgICAgKiBAcGFyYW0gYnVmZmVyIEJ1ZmZlciB0byBiZSBjYWNoZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgY2FjaGVCdWZmZXIobmFtZTogc3RyaW5nLCBidWZmZXI6IEJ1ZmZlcikge1xuICAgICAgICB0aGlzLmJ1ZmZlcnNbbmFtZV0gPSBidWZmZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBidWZmZXIgY2FjaGVkIHVuZGVyIGdpdmVuIG5hbWVcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBidWZmZXJcbiAgICAgKiBAcmV0dXJucyBUaGUgYnVmZmVyIGNhY2hlZCB1bmRlciBnaXZlbiBuYW1lLiBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgcHVibGljIGdldEJ1ZmZlcihuYW1lOiBzdHJpbmcpOiBCdWZmZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzW25hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBwcmVzZXQgcHJvcGVydHkuIEVnLiBgbWFpbi5nZXQoXCJtZXRhXCIpYFxuICAgICAqIEBwYXJhbSBrZXkgcHJlc2V0IHByb3BlcnR5IHRvIGJlIHJldHVybmVkXG4gICAgICovXG4gICAgcHVibGljIGdldChrZXk6IHN0cmluZykge1xuICAgICAgICBpZiAoa2V5ID09PSBcIm1ldGFcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWV0YTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyB0aGUgaW5zdGFudGFuZW91cyBwcmVzZXQgSlNPTiByZXByZXNlbnRhdGlvblxuICAgICAqIEByZXR1cm5zIEpTT04gcmVwcmVzZW50YXRvbiBvZiB0aGUgcHJlc2V0XG4gICAgICovXG4gICAgcHVibGljIHRvSlNPTigpOiBhbnkge1xuICAgICAgICBsZXQgcHJlc2V0ID0gdGhpcy5yb290Q29tcG9uZW50LnRvSlNPTigpO1xuICAgICAgICBwcmVzZXQgPSBwaWNrKHByZXNldCwgXCJjbGVhckZyYW1lXCIsIFwiY29tcG9uZW50c1wiKTtcbiAgICAgICAgcHJlc2V0LnJlc291cmNlcyA9IHRoaXMucnNyY01hbi50b0pTT04oKTtcbiAgICAgICAgcHJlc2V0Lm1ldGEgPSBjbG9uZSh0aGlzLm1ldGEpO1xuICAgICAgICByZXR1cm4gcHJlc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFuZCBjbGVhbnMgdXAgYWxsIHJlc291cmNlc1xuICAgICAqL1xuICAgIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICB0aGlzLnJvb3RDb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnJvb3RDb21wb25lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvcGllci5kZXN0cm95KCk7XG4gICAgICAgIGZvciAoY29uc3QgYnVmTmFtZSBpbiB0aGlzLmJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5idWZmZXJzLmhhc093blByb3BlcnR5KGJ1Zk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcnNbYnVmTmFtZV0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGVtcFRTTS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudGVtcFRTTSA9IG51bGw7XG4gICAgICAgIHRoaXMucmN0eC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucmN0eCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnN0YXRzKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0c0RvbUVsZW1lbnQgPSB0aGlzLnN0YXRzLmRvbUVsZW1lbnQ7XG4gICAgICAgICAgICBzdGF0c0RvbUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdGF0c0RvbUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yc3JjTWFuID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsIHRoaXMuY29udGV4dExvc3RIYW5kZXIpO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwid2ViZ2xjb250ZXh0cmVzdG9yZWRcIiwgdGhpcy5jb250ZXh0UmVzdG9yZWRIYW5kZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB3ZWJnbCByZW5kZXJpbmdcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0UmN0eCgpOiBSZW5kZXJpbmdDb250ZXh0IHsgcmV0dXJuIHRoaXMucmN0eDsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgUmVzb3VyY2UgTWFuYWdlciB0aGF0IG1hbmFnZXMgbWVkaWEgcmVzb3VyY2VzXG4gICAgICovXG4gICAgcHVibGljIGdldFJzcmNNYW4oKTogUmVzb3VyY2VNYW5hZ2VyIHsgcmV0dXJuIHRoaXMucnNyY01hbjsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBBIHNoYWRlciBwcm9ncmFtIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29weSBmcmFtZXNcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q29waWVyKCk6IENvcHlQcm9ncmFtIHsgcmV0dXJuIHRoaXMuY29waWVyOyB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbmFseXNlciBpbnN0YW5jZSB0aGF0J3MgdXNlZCB0byBnZXQgbXVzaWMgZGF0YVxuICAgICAqIGZvciB0aGUgdmlzdWFsaXphdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRBbmFseXNlcigpOiBBbmFseXNlckFkYXB0ZXIgeyByZXR1cm4gdGhpcy5hbmFseXNlcjsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZ2lzdHJ5IG9mIFtbQ29tcG9uZW50XV0gY2xhc3NlcyB0aGF0IHdpbGwgYmUgdXNlZFxuICAgICAqIHRvIGNyZWF0ZSBwcmVzZXQgZWZmZWN0c1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDb21wb25lbnRSZWdpc3RyeSgpOiBDb21wb25lbnRSZWdpc3RyeSB7IHJldHVybiB0aGlzLmNvbXBvbmVudFJlZ2lzdHJ5OyB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFRleHR1cmVTZXRNYW5hZ2VyIGZvciBnbG9iYWwgdGVtcG9yYXJ5IGJ1ZmZlcnMsIHRoYXQgY2FuXG4gICAgICogYmUgc2hhcmVkIGJldHdlZW4gY29tcG9uZW50cy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0VGVtcFRTTSgpOiBUZXh0dXJlU2V0TWFuYWdlciB7IHJldHVybiB0aGlzLnRlbXBUU007IH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmVnaXN0ZXIgYmFuaywgYSBtYXAgb2Ygc2hhcmVkIHJlZ2lzdGVyIHZhbHVlcyBhdmFpbGFibGVcbiAgICAgKiBpbiBFRUwgY29kZSBpbiBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRSZWdpc3RlckJhbmsoKToge1trZXk6IHN0cmluZ106IG51bWJlcn0ge3JldHVybiB0aGlzLnJlZ2lzdGVyQmFuazsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGltZXN0YW1wIGF0IHdoaWNoIHRoaXMgaW5zdGFuY2Ugd2FzIGNvbnN0cnVjdGVkXG4gICAgICovXG4gICAgcHVibGljIGdldEJvb3RUaW1lKCk6IG51bWJlciB7cmV0dXJuIHRoaXMuYm9vdFRpbWU7IH1cblxuICAgIHByb3RlY3RlZCBzZXRBdHRyaWJ1dGUoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnksIG9wdGlvbnM6IGFueSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcIm1ldGFcIikge1xuICAgICAgICAgICAgdGhpcy5tZXRhID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICBwcml2YXRlIGhhbmRsZVJzcmNXYWl0KCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BBbmltYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlUnNyY1JlYWR5KCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9pbml0Q29tcG9uZW50UmVnaXN0cnkoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVnaXN0cnkgPSBuZXcgQ29tcG9uZW50UmVnaXN0cnkoW1xuICAgICAgICAgICAgRWZmZWN0TGlzdCxcblxuICAgICAgICAgICAgQ2xlYXJTY3JlZW4sXG4gICAgICAgICAgICBNb3ZpbmdQYXJ0aWNsZSxcbiAgICAgICAgICAgIFBpY3R1cmUsXG4gICAgICAgICAgICBTdXBlclNjb3BlLFxuICAgICAgICAgICAgVGV4ZXIsXG5cbiAgICAgICAgICAgIENoYW5uZWxTaGlmdCxcbiAgICAgICAgICAgIENvbG9yQ2xpcCxcbiAgICAgICAgICAgIENvbG9yTWFwLFxuICAgICAgICAgICAgQ29udm9sdXRpb24sXG4gICAgICAgICAgICBEeW5hbWljTW92ZW1lbnQsXG4gICAgICAgICAgICBGYWRlT3V0LFxuICAgICAgICAgICAgSW52ZXJ0LFxuICAgICAgICAgICAgTWlycm9yLFxuICAgICAgICAgICAgTW9zYWljLFxuICAgICAgICAgICAgVW5pcXVlVG9uZSxcblxuICAgICAgICAgICAgQnVmZmVyU2F2ZSxcbiAgICAgICAgICAgIEdsb2JhbFZhcixcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaW5pdFJlc291cmNlTWFuYWdlcihwcmVmaXg6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBsZXQgYnVpbHRpblBhY2sgPSBidWlsdGluUmVzb3VyY2VQYWNrO1xuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgICBidWlsdGluUGFjayA9IGNsb25lKGJ1aWx0aW5QYWNrKTtcbiAgICAgICAgICAgIGJ1aWx0aW5QYWNrLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJzcmNNYW4gPSBuZXcgUmVzb3VyY2VNYW5hZ2VyKGJ1aWx0aW5QYWNrKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLnJzcmNNYW4sIFwid2FpdFwiLCAoKSA9PiB0aGlzLmhhbmRsZVJzcmNXYWl0KCkpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMucnNyY01hbiwgXCJyZWFkeVwiLCAoKSA9PiB0aGlzLmhhbmRsZVJzcmNSZWFkeSgpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9yZWdpc3RlckNvbnRleHRFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dExvc3RIYW5kZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dGxvc3RcIiwgdGhpcy5jb250ZXh0TG9zdEhhbmRlcik7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0UmVzdG9yZWRIYW5kZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRDYW52YXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmdsY29udGV4dHJlc3RvcmVkXCIsIHRoaXMuY29udGV4dFJlc3RvcmVkSGFuZGVyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pbml0R2woKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCB7YWxwaGE6IGZhbHNlfSk7XG4gICAgICAgICAgICBpZiAoIWdsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29udGV4dCBpcyBmYWxzeVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmN0eCA9IG5ldyBSZW5kZXJpbmdDb250ZXh0KGdsKTtcbiAgICAgICAgICAgIHRoaXMuY29waWVyID0gbmV3IENvcHlQcm9ncmFtKHRoaXMucmN0eCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnRlbXBUU00gPSBuZXcgVGV4dHVyZVNldE1hbmFnZXIodGhpcy5yY3R4LCB0aGlzLmNvcGllciwgdHJ1ZSwgMCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbnQgZ2V0IHdlYmdsIGNvbnRleHRcIiArIGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc2V0dXBSb290KHByZXNldDogYW55KSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJCYW5rID0ge307XG4gICAgICAgIHRoaXMuYm9vdFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLnJvb3RDb21wb25lbnQgPSBuZXcgRWZmZWN0TGlzdCh0aGlzLCBudWxsLCBwcmVzZXQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3N0YXJ0QW5pbWF0aW9uKCkge1xuICAgICAgICBsZXQgZHJhd0ZyYW1lID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hbmFseXNlci51cGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucm9vdENvbXBvbmVudC5kcmF3KCk7XG4gICAgICAgICAgICB0aGlzLmFuaW1SZXFJZCA9IHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXdGcmFtZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gV3JhcCBkcmF3ZnJhbWUgaW4gc3RhdHMgY29sbGVjdGlvbiBpZiByZXF1aXJlZFxuICAgICAgICBpZiAodGhpcy5zdGF0cykge1xuICAgICAgICAgICAgY29uc3Qgb2xkRHJhd0ZyYW1lID0gZHJhd0ZyYW1lO1xuICAgICAgICAgICAgZHJhd0ZyYW1lID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHMuYmVnaW4oKTtcbiAgICAgICAgICAgICAgICBvbGREcmF3RnJhbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRzLmVuZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1SZXFJZCA9IHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXdGcmFtZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc3RvcEFuaW1hdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1SZXFJZCk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL01haW4udHMiLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUNsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVDbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZURlbGV0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlRGVsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZUdldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYXNzb2NJbmRleE9mIGZyb20gJy4vX2Fzc29jSW5kZXhPZi5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZUhhcy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrQ2xlYXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrQ2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrRGVsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0YWNrR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0dldC5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5pbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTWFza2VkIGZyb20gJy4vX2lzTWFza2VkLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCB0b1NvdXJjZSBmcm9tICcuL190b1NvdXJjZS5qcyc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc05hdGl2ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qc1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGNvcmVKc0RhdGEgZnJvbSAnLi9fY29yZUpzRGF0YS5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTWFza2VkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc01hc2tlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbmV4cG9ydCBkZWZhdWx0IGNvcmVKc0RhdGE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRWYWx1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBIYXNoIGZyb20gJy4vX0hhc2guanMnO1xuaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlQ2xlYXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlQ2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBoYXNoQ2xlYXIgZnJvbSAnLi9faGFzaENsZWFyLmpzJztcbmltcG9ydCBoYXNoRGVsZXRlIGZyb20gJy4vX2hhc2hEZWxldGUuanMnO1xuaW1wb3J0IGhhc2hHZXQgZnJvbSAnLi9faGFzaEdldC5qcyc7XG5pbXBvcnQgaGFzaEhhcyBmcm9tICcuL19oYXNoSGFzLmpzJztcbmltcG9ydCBoYXNoU2V0IGZyb20gJy4vX2hhc2hTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuZXhwb3J0IGRlZmF1bHQgSGFzaDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fSGFzaC5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaENsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoQ2xlYXIuanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hEZWxldGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaEhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaEhhcy5qc1xuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaFNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZURlbGV0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXlhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0tleWFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDE2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUdldC5qc1xuLy8gbW9kdWxlIGlkID0gMTcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlSGFzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUhhcy5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGdldE1hcERhdGEgZnJvbSAnLi9fZ2V0TWFwRGF0YS5qcyc7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUFzc2lnbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzQXJndW1lbnRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R1YkZhbHNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJGYWxzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNUeXBlZEFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXMgZnJvbSAnLi9fbmF0aXZlS2V5cy5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVLZXlzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VBc3NpZ25JbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUFzc2lnbkluLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXNJbiBmcm9tICcuL19uYXRpdmVLZXlzSW4uanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5c0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5c0luLmpzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5c0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDE4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZUJ1ZmZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVCdWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGdldFN5bWJvbHMgZnJvbSAnLi9fZ2V0U3ltYm9scy5qcyc7XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weVN5bWJvbHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlTeW1ib2xzLmpzXG4vLyBtb2R1bGUgaWQgPSAxODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBnZXRTeW1ib2xzSW4gZnJvbSAnLi9fZ2V0U3ltYm9sc0luLmpzJztcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5U3ltYm9sc0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5U3ltYm9sc0luLmpzXG4vLyBtb2R1bGUgaWQgPSAxODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5leHBvcnQgZGVmYXVsdCBEYXRhVmlldztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fRGF0YVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDE4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5leHBvcnQgZGVmYXVsdCBQcm9taXNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19Qcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBpbml0Q2xvbmVBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faW5pdENsb25lQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDE4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBjbG9uZUFycmF5QnVmZmVyIGZyb20gJy4vX2Nsb25lQXJyYXlCdWZmZXIuanMnO1xuaW1wb3J0IGNsb25lRGF0YVZpZXcgZnJvbSAnLi9fY2xvbmVEYXRhVmlldy5qcyc7XG5pbXBvcnQgY2xvbmVSZWdFeHAgZnJvbSAnLi9fY2xvbmVSZWdFeHAuanMnO1xuaW1wb3J0IGNsb25lU3ltYm9sIGZyb20gJy4vX2Nsb25lU3ltYm9sLmpzJztcbmltcG9ydCBjbG9uZVR5cGVkQXJyYXkgZnJvbSAnLi9fY2xvbmVUeXBlZEFycmF5LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluaXRDbG9uZUJ5VGFnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbml0Q2xvbmVCeVRhZy5qc1xuLy8gbW9kdWxlIGlkID0gMTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGNsb25lQXJyYXlCdWZmZXIgZnJvbSAnLi9fY2xvbmVBcnJheUJ1ZmZlci5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lRGF0YVZpZXc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lRGF0YVZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDE4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lUmVnRXhwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVJlZ0V4cC5qc1xuLy8gbW9kdWxlIGlkID0gMTkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lU3ltYm9sO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVN5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGNsb25lQXJyYXlCdWZmZXIgZnJvbSAnLi9fY2xvbmVBcnJheUJ1ZmZlci5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lVHlwZWRBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2xvbmVUeXBlZEFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUNyZWF0ZSBmcm9tICcuL19iYXNlQ3JlYXRlLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5pdENsb25lT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbml0Q2xvbmVPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlSXNNYXAgZnJvbSAnLi9fYmFzZUlzTWFwLmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbmV4cG9ydCBkZWZhdWx0IGlzTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgZ2V0VGFnIGZyb20gJy4vX2dldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc01hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUlzU2V0IGZyb20gJy4vX2Jhc2VJc1NldC5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5leHBvcnQgZGVmYXVsdCBpc1NldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1NldC5qc1xuLy8gbW9kdWxlIGlkID0gMTk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGdldFRhZyBmcm9tICcuL19nZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc1NldC5qc1xuLy8gbW9kdWxlIGlkID0gMTk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gJy4vY29uc3RhbnQuanMnO1xuaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZVByb3BlcnR5LmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTZXRUb1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNldFRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29uc3RhbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY29uc3RhbnQuanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlUGlja0J5IGZyb20gJy4vX2Jhc2VQaWNrQnkuanMnO1xuaW1wb3J0IGhhc0luIGZyb20gJy4vaGFzSW4uanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQaWNrO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUGljay5qc1xuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IG1lbW9pemVDYXBwZWQgZnJvbSAnLi9fbWVtb2l6ZUNhcHBlZC5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5nVG9QYXRoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdHJpbmdUb1BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDIwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBtZW1vaXplIGZyb20gJy4vbWVtb2l6ZS5qcyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZUNhcHBlZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWVtb2l6ZUNhcHBlZC5qc1xuLy8gbW9kdWxlIGlkID0gMjAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL21lbW9pemUuanNcbi8vIG1vZHVsZSBpZCA9IDIwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMjA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGFzc2lnblZhbHVlIGZyb20gJy4vX2Fzc2lnblZhbHVlLmpzJztcbmltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCB0b0tleSBmcm9tICcuL190b0tleS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUhhc0luO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSGFzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDIwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0ZsYXR0ZW5hYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0ZsYXR0ZW5hYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBzdGF0cy5qcyAtIGh0dHA6Ly9naXRodWIuY29tL21yZG9vYi9zdGF0cy5qc1xuKGZ1bmN0aW9uKGYsZSl7XCJvYmplY3RcIj09PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6Zi5TdGF0cz1lKCl9KSh0aGlzLGZ1bmN0aW9uKCl7dmFyIGY9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGEpe2MuYXBwZW5kQ2hpbGQoYS5kb20pO3JldHVybiBhfWZ1bmN0aW9uIHUoYSl7Zm9yKHZhciBkPTA7ZDxjLmNoaWxkcmVuLmxlbmd0aDtkKyspYy5jaGlsZHJlbltkXS5zdHlsZS5kaXNwbGF5PWQ9PT1hP1wiYmxvY2tcIjpcIm5vbmVcIjtsPWF9dmFyIGw9MCxjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7Yy5zdHlsZS5jc3NUZXh0PVwicG9zaXRpb246Zml4ZWQ7dG9wOjA7bGVmdDowO2N1cnNvcjpwb2ludGVyO29wYWNpdHk6MC45O3otaW5kZXg6MTAwMDBcIjtjLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGZ1bmN0aW9uKGEpe2EucHJldmVudERlZmF1bHQoKTtcbnUoKytsJWMuY2hpbGRyZW4ubGVuZ3RoKX0sITEpO3ZhciBrPShwZXJmb3JtYW5jZXx8RGF0ZSkubm93KCksZz1rLGE9MCxyPWUobmV3IGYuUGFuZWwoXCJGUFNcIixcIiMwZmZcIixcIiMwMDJcIikpLGg9ZShuZXcgZi5QYW5lbChcIk1TXCIsXCIjMGYwXCIsXCIjMDIwXCIpKTtpZihzZWxmLnBlcmZvcm1hbmNlJiZzZWxmLnBlcmZvcm1hbmNlLm1lbW9yeSl2YXIgdD1lKG5ldyBmLlBhbmVsKFwiTUJcIixcIiNmMDhcIixcIiMyMDFcIikpO3UoMCk7cmV0dXJue1JFVklTSU9OOjE2LGRvbTpjLGFkZFBhbmVsOmUsc2hvd1BhbmVsOnUsYmVnaW46ZnVuY3Rpb24oKXtrPShwZXJmb3JtYW5jZXx8RGF0ZSkubm93KCl9LGVuZDpmdW5jdGlvbigpe2ErKzt2YXIgYz0ocGVyZm9ybWFuY2V8fERhdGUpLm5vdygpO2gudXBkYXRlKGMtaywyMDApO2lmKGM+ZysxRTMmJihyLnVwZGF0ZSgxRTMqYS8oYy1nKSwxMDApLGc9YyxhPTAsdCkpe3ZhciBkPXBlcmZvcm1hbmNlLm1lbW9yeTt0LnVwZGF0ZShkLnVzZWRKU0hlYXBTaXplL1xuMTA0ODU3NixkLmpzSGVhcFNpemVMaW1pdC8xMDQ4NTc2KX1yZXR1cm4gY30sdXBkYXRlOmZ1bmN0aW9uKCl7az10aGlzLmVuZCgpfSxkb21FbGVtZW50OmMsc2V0TW9kZTp1fX07Zi5QYW5lbD1mdW5jdGlvbihlLGYsbCl7dmFyIGM9SW5maW5pdHksaz0wLGc9TWF0aC5yb3VuZCxhPWcod2luZG93LmRldmljZVBpeGVsUmF0aW98fDEpLHI9ODAqYSxoPTQ4KmEsdD0zKmEsdj0yKmEsZD0zKmEsbT0xNSphLG49NzQqYSxwPTMwKmEscT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3Eud2lkdGg9cjtxLmhlaWdodD1oO3Euc3R5bGUuY3NzVGV4dD1cIndpZHRoOjgwcHg7aGVpZ2h0OjQ4cHhcIjt2YXIgYj1xLmdldENvbnRleHQoXCIyZFwiKTtiLmZvbnQ9XCJib2xkIFwiKzkqYStcInB4IEhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmXCI7Yi50ZXh0QmFzZWxpbmU9XCJ0b3BcIjtiLmZpbGxTdHlsZT1sO2IuZmlsbFJlY3QoMCwwLHIsaCk7Yi5maWxsU3R5bGU9ZjtiLmZpbGxUZXh0KGUsdCx2KTtcbmIuZmlsbFJlY3QoZCxtLG4scCk7Yi5maWxsU3R5bGU9bDtiLmdsb2JhbEFscGhhPS45O2IuZmlsbFJlY3QoZCxtLG4scCk7cmV0dXJue2RvbTpxLHVwZGF0ZTpmdW5jdGlvbihoLHcpe2M9TWF0aC5taW4oYyxoKTtrPU1hdGgubWF4KGssaCk7Yi5maWxsU3R5bGU9bDtiLmdsb2JhbEFscGhhPTE7Yi5maWxsUmVjdCgwLDAscixtKTtiLmZpbGxTdHlsZT1mO2IuZmlsbFRleHQoZyhoKStcIiBcIitlK1wiIChcIitnKGMpK1wiLVwiK2coaykrXCIpXCIsdCx2KTtiLmRyYXdJbWFnZShxLGQrYSxtLG4tYSxwLGQsbSxuLWEscCk7Yi5maWxsUmVjdChkK24tYSxtLGEscCk7Yi5maWxsU3R5bGU9bDtiLmdsb2JhbEFscGhhPS45O2IuZmlsbFJlY3QoZCtuLWEsbSxhLGcoKDEtaC93KSpwKSl9fX07cmV0dXJuIGZ9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0YXRzLmpzL2J1aWxkL3N0YXRzLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiZGVjbGFyZSB2YXIgUkVTT1VSQ0VfUEFDS19VUkw6IHN0cmluZztcblxuY29uc3QgYnVpbHRpblJlc291cmNlUGFjayA9IHtcbiAgICBmaWxlTmFtZXM6IFtcbiAgICAgICAgXCJhdnNyZXNfdGV4ZXJfY2lyY2xlX2VkZ2Vvbmx5XzE5eDE5LmJtcFwiLFxuICAgICAgICBcImF2c3Jlc190ZXhlcl9jaXJjbGVfZWRnZW9ubHlfMjl4MjkuYm1wXCIsXG4gICAgICAgIFwiYXZzcmVzX3RleGVyX2NpcmNsZV9mYWRlXzEzeDEzLmJtcFwiLFxuICAgICAgICBcImF2c3Jlc190ZXhlcl9jaXJjbGVfaGVhdnlibHVyXzE5eDE5LmJtcFwiLFxuICAgICAgICBcImF2c3Jlc190ZXhlcl9jaXJjbGVfaGVhdnlibHVyXzIxeDIxLmJtcFwiLFxuICAgICAgICBcImF2c3Jlc190ZXhlcl9jaXJjbGVfaGVhdnlibHVyXzI5eDI5LmJtcFwiLFxuICAgICAgICBcImF2c3Jlc190ZXhlcl9jaXJjbGVfc2hhcnBfMDl4MDkuYm1wXCIsXG4gICAgICAgIFwiYXZzcmVzX3RleGVyX2NpcmNsZV9zaGFycF8xOXgxOS5ibXBcIixcbiAgICAgICAgXCJhdnNyZXNfdGV4ZXJfY2lyY2xlX3NsaWdodGJsdXJfMTN4MTMuYm1wXCIsXG4gICAgICAgIFwiYXZzcmVzX3RleGVyX2NpcmNsZV9zbGlnaHRibHVyXzIxeDIxLmJtcFwiLFxuICAgICAgICBcImF2c3Jlc190ZXhlcl9oZXhhZ29uLWhfYmx1cl8xMjN4MTIzLmJtcFwiLFxuICAgICAgICBcImF2c3Jlc190ZXhlcl9zcXVhcmVfZWRnZW9ubHlfMjR4MjQuYm1wXCIsXG4gICAgICAgIFwiYXZzcmVzX3RleGVyX3NxdWFyZV9lZGdlb25seV8yOHgyOC5ibXBcIixcbiAgICAgICAgXCJhdnNyZXNfdGV4ZXJfc3F1YXJlX2VkZ2Vvbmx5XzMweDMwLmJtcFwiLFxuICAgICAgICBcImF2c3Jlc190ZXhlcl9zcXVhcmVfc2hhcnBfMjB4MjAuYm1wXCIsXG4gICAgICAgIFwiYXZzcmVzX3RleGVyX3NxdWFyZV9zaGFycF8zMngzMi5ibXBcIixcbiAgICAgICAgXCJhdnNyZXNfdGV4ZXJfc3F1YXJlX3NoYXJwXzQ4eDQ4LmJtcFwiLFxuICAgICAgICBcImF2c3Jlc190ZXhlcl9zcXVhcmVfc2hhcnBfNjB4NjAuYm1wXCIsXG4gICAgICAgIFwiYXZzcmVzX3RleGVyX3NxdWFyZV9zaGFycF82NHg2NC5ibXBcIixcbiAgICAgICAgXCJhdnNyZXNfdGV4ZXJfc3F1YXJlX3NoYXJwXzcyeDcyLmJtcFwiLFxuICAgICAgICBcImF2c3Jlc190ZXhlcl9zcXVhcmVfc2hhcnBfOTZ4OTYuYm1wXCIsXG4gICAgICAgIFwiYXZzcmVzX3RleGVyX3NxdWFyZV9zaGFycF8yNTB4MjUwLmJtcFwiLFxuICAgIF0sXG4gICAgbmFtZTogXCJCdWlsdGluXCIsXG4gICAgcHJlZml4OiBSRVNPVVJDRV9QQUNLX1VSTCxcbn07XG5leHBvcnQgZGVmYXVsdCBidWlsdGluUmVzb3VyY2VQYWNrO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2J1aWx0aW5SZXNvdXJjZVBhY2sudHMiLCJpbXBvcnQgQ29tcG9uZW50LCB7SUNvbXBvbmVudENvbnN0cnVjdG9yfSBmcm9tIFwiLi9Db21wb25lbnRcIjtcbmltcG9ydCBDbGVhclNjcmVlbiBmcm9tIFwiLi9yZW5kZXIvQ2xlYXJTY3JlZW5cIjtcblxuLyoqXG4gKiBBIFJlZ2lzdHJ5IG9mIENvbXBvbmVudCBjbGFzc2VzLlxuICpcbiAqIENvbXBvbmVudFJlZ2lzdHJ5IG1haW50YWlucyBhIG1hcCBmcm9tIENvbXBvbmVudCBuYW1lXG4gKiB0byBDb21wb25lbnQgY2xhc3MgY29uc3RydWN0b3JzLiBUeXBpY2FsbHkgdXNlZCB0aHJvdWdoIHRoZSBbW01haW4uY29tcG9uZW50UmVnaXN0cnldXVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wb25lbnRSZWdpc3RyeSB7XG4gICAgcHJpdmF0ZSBjb21wb25lbnRzOiB7W25hbWU6IHN0cmluZ106IElDb21wb25lbnRDb25zdHJ1Y3Rvcn0gPSB7fTtcbiAgICBwcml2YXRlIHRhZ3M6IHN0cmluZ1tdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBjb25zdHJ1Y3QgYSBDb21wb25lbnRSZWdpc3RyeSB3aXRoIGFuIGluaXRpYWwgc2V0IG9mIENvbXBvbmVudCBjbGFzc1xuICAgICAqIGNvbnN0cnVjdG9ycy5cbiAgICAgKiBAcGFyYW0gY29tcG9uZW50Q2xhc3NlcyBvbmUgb3IgbW9yZSBDb21wb25lbnQgY2xhc3MgY29uc3RydWN0b3JzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50Q2xhc3Nlcz86IElDb21wb25lbnRDb25zdHJ1Y3RvciB8IElDb21wb25lbnRDb25zdHJ1Y3RvcltdKSB7XG4gICAgICAgIGlmIChjb21wb25lbnRDbGFzc2VzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZENvbXBvbmVudChjb21wb25lbnRDbGFzc2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIENvbXBvbmVudCBjbGFzcyBjb25zdHJ1Y3RvciBpbnRvIHRoZSByZWdpc3RyeS4gRWFjaCBjb25zdHJ1Y3RvciBpcyBtYXBwZWRcbiAgICAgKiB0byB0aGUgc3RhdGljIFtbQ29tcG9uZW50LmNvbXBvbmVudE5hbWVdXSB2YWx1ZSBvZiB0aGUgY2xhc3MuXG4gICAgICogQHBhcmFtIGNvbXBvbmVudENsYXNzZXMgb25lIG9yIG1vcmUgQ29tcG9uZW50IGNsYXNzIGNvbnN0cnVjdG9ycyB0byBiZSBhZGRlZFxuICAgICAqL1xuICAgIHB1YmxpYyBhZGRDb21wb25lbnQoY29tcG9uZW50Q2xhc3NlczogSUNvbXBvbmVudENvbnN0cnVjdG9yIHwgSUNvbXBvbmVudENvbnN0cnVjdG9yW10pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbXBvbmVudENsYXNzZXMpKSB7XG4gICAgICAgICAgICBjb21wb25lbnRDbGFzc2VzID0gW2NvbXBvbmVudENsYXNzZXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcG9uZW50Q2xhc3Nlcy5mb3JFYWNoKChjb21wb25lbnRDbGFzcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbXBvbmVudENsYXNzLmdldENvbXBvbmVudE5hbWUoKTtcbiAgICAgICAgICAgIGlmIChuYW1lIGluIHRoaXMuY29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50ICR7bmFtZX0gYWxyZWFkeSBleGlzdHMgaW4gdGhlIHJlZ2lzdHJ5YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbbmFtZV0gPSBjb21wb25lbnRDbGFzcztcbiAgICAgICAgICAgIGlmICh0aGlzLnRhZ3MuaW5kZXhPZihjb21wb25lbnRDbGFzcy5nZXRDb21wb25lbnRUYWcoKSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzLnB1c2goY29tcG9uZW50Q2xhc3MuZ2V0Q29tcG9uZW50VGFnKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBDb21wb25lbnQgY2xhc3MgY29uc3RydWN0b3IgbWFwcGVkIHRvIHRoZSBnaXZlbiBuYW1lXG4gICAgICogQHBhcmFtIG5hbWUgY29tcG9uZW50TmFtZSBvZiB0aGUgQ29tcG9uZW50IGNsYXNzIHRvIGJlIHJldHJpZXZlZFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDb21wb25lbnRDbGFzcyhuYW1lOiBzdHJpbmcpOiBJQ29tcG9uZW50Q29uc3RydWN0b3Ige1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRzW25hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGNvbXBvbmVudHMgd2l0aCBnaXZlbiB0YWdcbiAgICAgKiBAcGFyYW0gdGFnIG9mIGNvbXBvbmVudCBjbGFzc2VzIHRvIGJlIHJldHVybmVkXG4gICAgICovXG4gICAgcHVibGljIGdldENvbXBvbmVudENsYXNzZXNCeVRhZyh0YWc6IHN0cmluZyk6IElDb21wb25lbnRDb25zdHJ1Y3RvcltdIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuY29tcG9uZW50cylcbiAgICAgICAgICAgICAgICAgICAgIC5tYXAoKG5hbWUpID0+IHRoaXMuY29tcG9uZW50c1tuYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGNvbXBvbmVudENsYXNzKSA9PiBjb21wb25lbnRDbGFzcy5nZXRDb21wb25lbnRUYWcoKSA9PT0gdGFnKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQ29tcG9uZW50UmVnaXN0cnkudHMiLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuL0NvbXBvbmVudFwiO1xuaW1wb3J0IENvbnRhaW5lciBmcm9tIFwiLi9Db250YWluZXJcIjtcbmltcG9ydCBDb2RlSW5zdGFuY2UgZnJvbSBcIi4vZXhwci9Db2RlSW5zdGFuY2VcIjtcbmltcG9ydCBjb21waWxlRXhwciBmcm9tIFwiLi9leHByL2NvbXBpbGVFeHByXCI7XG5pbXBvcnQgSU1haW4gZnJvbSBcIi4vSU1haW5cIjtcbmltcG9ydCB7IEJsZW5kTW9kZSB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQgVGV4dHVyZVNldE1hbmFnZXIgZnJvbSBcIi4vd2ViZ2wvVGV4dHVyZVNldE1hbmFnZXJcIjtcblxuLyoqXG4gKiBCbGVuZE1vZGVzIHN1cHBvcnRlZCBieSBFZmZlY3RsaXN0XG4gKi9cbmV4cG9ydCBlbnVtIEVMQmxlbmRNb2RlIHtcbiAgICBSRVBMQUNFID0gMSxcbiAgICBNQVhJTVVNLFxuICAgIEFWRVJBR0UsXG4gICAgQURESVRJVkUsXG4gICAgU1VCVFJBQ1RJVkUxLFxuICAgIFNVQlRSQUNUSVZFMixcbiAgICBNVUxUSVBMWSxcbiAgICBNVUxUSVBMWTIsXG4gICAgQURKVVNUQUJMRSxcbiAgICBBTFBIQSxcbiAgICBJR05PUkUsXG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgRWZmZWN0TGlzdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIElFZmZlY3RMaXN0T3B0cyB7XG4gICAgLyoqXG4gICAgICogRUVMIGNvZGUgdG8gY29udHJvbCB0aGUgZWZmZWN0bGlzdC5cbiAgICAgKlxuICAgICAqIEZvbGxvd2luZyB2YXJhaWJsZXMgYXJlIGF2YWlsYWJsZTpcbiAgICAgKlxuICAgICAqICsgYGJlYXRgOiAwIG9yIDEgdG8gaW5kaWNhdGUgYSBiZWF0IGZvciB0aGUgY3VycmVudCBmcmFtZVxuICAgICAqICsgYGVuYWJsZWRgOiBzZXQgdGhpcyB0byAwIG9yIDEgdG8gZGlzYWJsZSBvciBlbmFibGUgdGhlIGVmZmVjdGxpc3RcbiAgICAgKiArIGBjbGVhcmA6IHNldCB0aGlzIHRvIDAgb3IgMSB0byBjbGVhciB0aGUgZnJhbWVcbiAgICAgKi9cbiAgICBjb2RlOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFRUwgdGhhdCB3aWxsIGJlIHJ1biBvbiBpbml0XG4gICAgICAgICAqL1xuICAgICAgICBpbml0OiBzdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFRUwgdGhhdCB3aWxsIGJlIHJ1biBwZXIgZnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIHBlckZyYW1lOiBzdHJpbmcsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgb3V0cHV0IGJsZW5kIG1vZGUuIERlZmF1bHQ6IFwiUkVQTEFDRVwiXG4gICAgICovXG4gICAgb3V0cHV0OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGlucHV0IGJsZW5kIG1vZGUuIERlZmF1bHQ6IFwiSUdOT1JFXCJcbiAgICAgKi9cbiAgICBpbnB1dDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSBjbGVhcmluZyBlYWNoIGZyYW1lLiBEZWZhdWx0OiBmYWxzZVxuICAgICAqL1xuICAgIGNsZWFyRnJhbWU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSWYgc2V0LCB0aGUgdGhpcyBlZmZlY3RsaXN0IGlzIGVuYWJsZWQgb25seSBvbiBhIGJlYXQuIERlZmF1bHQ6IGZhbHNlXG4gICAgICovXG4gICAgZW5hYmxlT25CZWF0OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFdoZW4gZW5hYmxlT25CZWF0LCB0aGlzIGRldGVybWluZXMgdGhlIG51bWJlciBvZiBiZWF0c1xuICAgICAqIGNvdW50ZWQgYmVmb3JlIHRoZSBFZmZlY3RsaXN0IGlzIGVuYWJsZWQuIERlZmF1bHQ6IDFcbiAgICAgKi9cbiAgICBlbmFibGVPbkJlYXRGb3I6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIElFTENvZGVJbnN0YW5jZSBleHRlbmRzIENvZGVJbnN0YW5jZSB7XG4gICAgYmVhdDogbnVtYmVyO1xuICAgIGVuYWJsZWQ6IG51bWJlcjtcbiAgICBjbGVhcjogbnVtYmVyO1xuICAgIGluaXQ6ICgpID0+IHZvaWQ7XG4gICAgcGVyRnJhbWU6ICgpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogRWZmZWN0bGlzdCBpcyBhIGNvbnRhaW5lciB0aGF0IHJlbmRlcnMgY29tcG9uZW50cyB0byBhIHNlcGFyYXRlIGJ1ZmZlci4gQW5kIGJsZW5kc1xuICogaXQgaW4gd2l0aCB0aGUgcGFyZW50IGJ1ZmZlci5cbiAqXG4gKiBBbiBpbXBsaWNpdCBFZmZlY2xpc3QgaXMgYWxzbyBjcmVhdGVkIGJ5IFtbTWFpbl1dIGFzIGEgcm9vdCBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVmZmVjdExpc3QgZXh0ZW5kcyBDb250YWluZXIge1xuICAgIHB1YmxpYyBzdGF0aWMgY29tcG9uZW50TmFtZSA9IFwiRWZmZWN0TGlzdFwiO1xuICAgIHB1YmxpYyBzdGF0aWMgY29tcG9uZW50VGFnID0gXCJcIjtcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlZmF1bHRPcHRpb25zOiBJRWZmZWN0TGlzdE9wdHMgPSB7XG4gICAgICAgIGNsZWFyRnJhbWU6IGZhbHNlLFxuICAgICAgICBjb2RlOiB7XG4gICAgICAgICAgICBpbml0OiBcIlwiLFxuICAgICAgICAgICAgcGVyRnJhbWU6IFwiXCIsXG4gICAgICAgIH0sXG4gICAgICAgIGVuYWJsZU9uQmVhdDogZmFsc2UsXG4gICAgICAgIGVuYWJsZU9uQmVhdEZvcjogMSxcbiAgICAgICAgaW5wdXQ6IFwiSUdOT1JFXCIsXG4gICAgICAgIG91dHB1dDogXCJSRVBMQUNFXCIsXG4gICAgfTtcbiAgICBwcm90ZWN0ZWQgc3RhdGljIG9wdFVwZGF0ZUhhbmRsZXJzID0ge1xuICAgICAgICBjb2RlOiBcInVwZGF0ZUNvZGVcIixcbiAgICAgICAgaW5wdXQ6IFwidXBkYXRlQmxlbmRNb2RlXCIsXG4gICAgICAgIG91dHB1dDogXCJ1cGRhdGVCbGVuZE1vZGVcIixcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIG9wdHM6IElFZmZlY3RMaXN0T3B0cztcbiAgICBwcml2YXRlIGZyYW1lQ291bnRlcjogbnVtYmVyO1xuICAgIHByaXZhdGUgZmlyc3Q6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBpbml0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIGNvZGU6IElFTENvZGVJbnN0YW5jZTtcbiAgICBwcml2YXRlIGlucHV0OiBFTEJsZW5kTW9kZTtcbiAgICBwcml2YXRlIG91dHB1dDogRUxCbGVuZE1vZGU7XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluOiBJTWFpbiwgcGFyZW50OiBDb250YWluZXIsIG9wdHM6IGFueSkge1xuICAgICAgICBzdXBlcihtYWluLCBwYXJlbnQsIG9wdHMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbml0KCkge1xuICAgICAgICBzdXBlci5pbml0KCk7XG4gICAgICAgIGNvbnN0IHRzbSA9IG5ldyBUZXh0dXJlU2V0TWFuYWdlcihcbiAgICAgICAgICAgIHRoaXMubWFpbi5nZXRSY3R4KCksIHRoaXMubWFpbi5nZXRDb3BpZXIoKSwgdGhpcy5wYXJlbnQgPyBmYWxzZSA6IHRydWUpO1xuICAgICAgICB0aGlzLnNldFRTTSh0c20pO1xuICAgICAgICB0aGlzLnVwZGF0ZUNvZGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVCbGVuZE1vZGUodGhpcy5vcHRzLmlucHV0LCBcImlucHV0XCIpO1xuICAgICAgICB0aGlzLnVwZGF0ZUJsZW5kTW9kZSh0aGlzLm9wdHMub3V0cHV0LCBcIm91dHB1dFwiKTtcbiAgICAgICAgdGhpcy5mcmFtZUNvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLmZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1haW4sIFwicmVzaXplXCIsICgpID0+IHRoaXMuaGFuZGxlUmVzaXplKCkpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkcmF3KCkge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRzO1xuXG4gICAgICAgIGlmIChvcHRzLmVuYWJsZU9uQmVhdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWFpbi5nZXRBbmFseXNlcigpLmlzQmVhdCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZUNvdW50ZXIgPSBvcHRzLmVuYWJsZU9uQmVhdEZvcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mcmFtZUNvdW50ZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZUNvdW50ZXItLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb25seSBlbmFibGUgZm9yIGVuYWJsZU9uQmVhdEZvciAjIG9mIGZyYW1lc1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJhbWVDb3VudGVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2RlLmJlYXQgPSB0aGlzLm1haW4uZ2V0QW5hbHlzZXIoKS5pc0JlYXQoKSA/IDEgOiAwO1xuICAgICAgICB0aGlzLmNvZGUuZW5hYmxlZCA9IDE7XG4gICAgICAgIHRoaXMuY29kZS5jbGVhciA9IG9wdHMuY2xlYXJGcmFtZSA/IDEgOiAwO1xuICAgICAgICBpZiAoIXRoaXMuaW5pdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvZGUuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29kZS5wZXJGcmFtZSgpO1xuICAgICAgICBpZiAodGhpcy5jb2RlLmVuYWJsZWQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCByZW5kZXJ0YXJnZXQgdG8gaW50ZXJuYWwgZnJhbWVidWZmZXJcbiAgICAgICAgdGhpcy5nZXRUU00oKS5zZXRBc1JlbmRlclRhcmdldCgpO1xuXG4gICAgICAgIC8vIGNsZWFyIGZyYW1lXG4gICAgICAgIGlmIChvcHRzLmNsZWFyRnJhbWUgfHwgdGhpcy5maXJzdCB8fCB0aGlzLmNvZGUuY2xlYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5tYWluLmdldFJjdHgoKS5nZXRHbCgpO1xuICAgICAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAxKTtcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgdGhpcy5maXJzdCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmxlbmQgaW5wdXQgdGV4dHVyZSBvbnRvIGludGVybmFsIHRleHR1cmVcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQgIT09IEVMQmxlbmRNb2RlLklHTk9SRSkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRUZXh0dXJlID0gdGhpcy5wYXJlbnQuZ2V0VFNNKCkuZ2V0Q3VycmVudFRleHR1cmUoKTtcbiAgICAgICAgICAgIHRoaXMubWFpbi5nZXRDb3BpZXIoKS5ydW4odGhpcy5nZXRUU00oKSwgeyBzcmNUZXh0dXJlOiBpbnB1dFRleHR1cmUgfSwgdGhpcy5pbnB1dCBhcyBudW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVuZGVyIGFsbCB0aGUgY29tcG9uZW50c1xuICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiB0aGlzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3dpdGNoIHRvIG9sZCBmcmFtZWJ1ZmZlclxuICAgICAgICB0aGlzLmdldFRTTSgpLnVuc2V0QXNSZW5kZXJUYXJnZXQoKTtcblxuICAgICAgICAvLyBibGVuZCBjdXJyZW50IHRleHR1cmUgdG8gdGhlIG91dHB1dCBmcmFtZWJ1ZmZlclxuICAgICAgICBpZiAodGhpcy5vdXRwdXQgIT09IEVMQmxlbmRNb2RlLklHTk9SRSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLmdldENvcGllcigpLnJ1bihcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuZ2V0VFNNKCksXG4gICAgICAgICAgICAgICAgICAgIHsgc3JjVGV4dHVyZTogdGhpcy5nZXRUU00oKS5nZXRDdXJyZW50VGV4dHVyZSgpIH0sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0IGFzIG51bWJlcixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW4uZ2V0Q29waWVyKCkucnVuKG51bGwsIHsgc3JjVGV4dHVyZTogdGhpcy5nZXRUU00oKS5nZXRDdXJyZW50VGV4dHVyZSgpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VFNNKCkpIHtcbiAgICAgICAgICAgIC8vIGRlc3Ryb3kgdGhlIGZyYW1lYnVmZmVyIG1hbmFnZXJcbiAgICAgICAgICAgIHRoaXMuZ2V0VFNNKCkuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVDb2RlKCkge1xuICAgICAgICB0aGlzLmNvZGUgPSBjb21waWxlRXhwcih0aGlzLm9wdHMuY29kZSwgW1wiaW5pdFwiLCBcInBlckZyYW1lXCJdKS5jb2RlSW5zdCBhcyBJRUxDb2RlSW5zdGFuY2U7XG4gICAgICAgIHRoaXMuY29kZS5zZXR1cCh0aGlzLm1haW4pO1xuICAgICAgICB0aGlzLmluaXRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlQmxlbmRNb2RlKHZhbHVlOiBzdHJpbmcsIG5hbWU6IFwiaW5wdXRcIiB8IFwib3V0cHV0XCIpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IEVMQmxlbmRNb2RlW3ZhbHVlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gRUxCbGVuZE1vZGVbdmFsdWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVSZXNpemUoKSB7XG4gICAgICAgIHRoaXMuZ2V0VFNNKCkucmVzaXplKCk7XG4gICAgICAgIHRoaXMuY29kZS51cGRhdGVEaW1WYXJzKHRoaXMubWFpbi5nZXRSY3R4KCkuZ2V0R2woKSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0VmZmVjdExpc3QudHMiLCJpbXBvcnQgZGVmYXVsdHMgZnJvbSBcImxvZGFzaC1lcy9kZWZhdWx0c1wiO1xuaW1wb3J0IGlzU3RyaW5nIGZyb20gXCJsb2Rhc2gtZXMvaXNTdHJpbmdcIjtcbmltcG9ydCBDb21wb25lbnQsIHsgSUNvbXBvbmVudENvbnN0cnVjdG9yLCBJQ29udGFpbmVyIH0gZnJvbSBcIi4vQ29tcG9uZW50XCI7XG5pbXBvcnQgQ29tcG9uZW50UmVnaXN0cnkgZnJvbSBcIi4vQ29tcG9uZW50UmVnaXN0cnlcIjtcbmltcG9ydCBJTWFpbiBmcm9tIFwiLi9JTWFpblwiO1xuaW1wb3J0IFRleHR1cmVTZXRNYW5hZ2VyIGZyb20gXCIuL3dlYmdsL1RleHR1cmVTZXRNYW5hZ2VyXCI7XG5cbi8qKlxuICogQSBCYXNlIGNsYXNzIGZvciBhbGwgQ29tcG9uZW50cyB0aGF0IGhhdmUgYSBzdWIgY29tcG9uZW50LlxuICpcbiAqIE1hbmFnZXMsIGNsb25pbmcgYW5kIGNvbXBvbmVudCB0cmVlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIENvbnRhaW5lciBleHRlbmRzIENvbXBvbmVudCBpbXBsZW1lbnRzIElDb250YWluZXIge1xuICAgIHByb3RlY3RlZCBjb21wb25lbnRzOiBDb21wb25lbnRbXTtcbiAgICBwcml2YXRlIHRzbTogVGV4dHVyZVNldE1hbmFnZXI7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgW1tDb21wb25lbnQuY29uc3RydWN0b3JdXVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1haW46IElNYWluLCBwYXJlbnQ6IElDb250YWluZXIsIG9wdHM6IGFueSkge1xuICAgICAgICBzdXBlcihtYWluLCBwYXJlbnQsIG9wdHMpO1xuICAgICAgICBkZWxldGUgdGhpcy5vcHRzLmNvbXBvbmVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVGV4dFNldE1hbmFnZXIgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQSBjb250YWluZXIgaW5oZXJpdHMgVGV4dHVyZVNldE1hbmFnZXIgZnJvbSBpdCdzIG93biBwYXJlbnRcbiAgICAgKiB1bmxlc3MgZXhwbGljaXRseSBvdmVycmlkZGVuIGJ5IFN1YmNsYXNzXG4gICAgICovXG4gICAgcHVibGljIGdldFRTTSgpOiBUZXh0dXJlU2V0TWFuYWdlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnRzbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBDb250YWluZXIuIFBsZWFzZSBvdmVycmlkZSB0byBpbXBsZW1lbnQgY29tcG9uZW50IHNwZWNpZmljIGluaXRpYWxpemF0aW9uXG4gICAgICpcbiAgICAgKiBDb250YWluZXIgaW5pdCBiYXNpY2FsbHkgaW5zdGFudGlhdGVzIGFsbCBzdWJjb21wb25lbnRzIGZyb20gdGhlIGBjb21wb25lbnRzYCBvcHRpb24uXG4gICAgICogSXQgYWxzbyBpbml0aWFsaXplcyB0aGUgVGV4dHVyZVNldE1hbmFnZXIgdG8gdGhlIHBhcmVudCdzLlxuICAgICAqL1xuICAgIHB1YmxpYyBpbml0KCkge1xuICAgICAgICBjb25zdCBjb21wb25lbnRzID0gW107XG4gICAgICAgIGlmICh0aGlzLm9wdHMuY29tcG9uZW50cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRzIG9mIHRoaXMub3B0cy5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50Q2xhc3MgPSB0aGlzLm1haW4uZ2V0Q29tcG9uZW50UmVnaXN0cnkoKS5nZXRDb21wb25lbnRDbGFzcyhvcHRzLnR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50Q2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIENvbXBvbmVudENsYXNzOiAke29wdHMudHlwZX0uIFNraXBwaW5nLmApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gbmV3IGNvbXBvbmVudENsYXNzKHRoaXMubWFpbiwgdGhpcywgb3B0cyk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdGhpcy50c20gPSB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5nZXRUU00oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGFsbCBzdWJjb21wb25lbnRzIGFuZCBpdHNlbGYuXG4gICAgICovXG4gICAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgdGhpcy5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICBjb21wb25lbnQuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBuZXcgc3ViIGNvbXBvbmVudCBpbiB0aGlzIENvbnRhaW5lclxuICAgICAqXG4gICAgICogT25jZSBjb21wb25lbnQgaXMgaW5zZXJ0ZWQsIGFuIGBhZGRDb21wb25lbnRgIGV2ZW50IGlzIGZpcmVkIHdpdGggdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XG4gICAgICogMS4gVGhlIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50XG4gICAgICogMi4gVGhpcyBjb250YWluZXJcbiAgICAgKiAzLiBBZGRpdGlvbmFsIHBhcmFtcyBwYXNzZWQgaW4gdG8gdGhpcyBjYWxsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50T3B0cyBvcHRpb25zIGZvciB0aGUgbmV3IHN1Yi1jb21wb25lbnRcbiAgICAgKiBAcGFyYW0gcG9zIHRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgc3ViLWNvbXBvbmVudCBzaG91bGQgYmUgaW5zZXJ0ZWQuIERlZmF1bHRzIHRvIGFwcGVuZGluZ1xuICAgICAqIEBwYXJhbSBwYXJhbXMgYWRkaXRpb25hbCBwYXJhbXMgdG8gYmUgcGFzc2VkIGRvd24gdGhlIHRoZSBgYWRkQ29tcG9uZW50YCBldmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBhZGRDb21wb25lbnQoY29tcG9uZW50T3B0czogYW55LCBwb3M6IG51bWJlciA9IHRoaXMuY29tcG9uZW50cy5sZW5ndGgsIHBhcmFtczogYW55ID0ge30pOiBDb21wb25lbnQge1xuICAgICAgICBsZXQgY29tcG9uZW50O1xuICAgICAgICBpZiAoY29tcG9uZW50T3B0cyBpbnN0YW5jZW9mIENvbXBvbmVudCkge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50T3B0cztcbiAgICAgICAgICAgIGNvbXBvbmVudC5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnRDbGFzcyA9IHRoaXMubWFpbi5nZXRDb21wb25lbnRSZWdpc3RyeSgpLmdldENvbXBvbmVudENsYXNzKGNvbXBvbmVudE9wdHMudHlwZSk7XG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudENsYXNzKSB7XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gQ29tcG9uZW50Q2xhc3M6ICR7Y29tcG9uZW50T3B0cy50eXBlfS5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudCA9IG5ldyBjb21wb25lbnRDbGFzcyh0aGlzLm1haW4sIHRoaXMsIGNvbXBvbmVudE9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5zcGxpY2UocG9zLCAwLCBjb21wb25lbnQpO1xuXG4gICAgICAgIHBhcmFtcyA9IGRlZmF1bHRzKHtwb3N9LCBwYXJhbXMpO1xuICAgICAgICB0aGlzLmVtaXQoXCJhZGRDb21wb25lbnRcIiwgY29tcG9uZW50LCB0aGlzLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGFjaGVzIGEgY29tcG9uZW50IGZyb20gdGhpcyBjb250YWluZXIgYW5kIHJldHVybnMgaXQuXG4gICAgICpcbiAgICAgKiBPbmNlIGNvbXBvbmVudCBpcyBkZXRhY2hlZCwgYSBgZGV0YWNoQ29tcG9uZW50YCBldmVudCBpcyBmaXJlZCB3aXRoIGZvbGxvd2luZyBhcmd1bWVudHMuXG4gICAgICogMS4gVGhlIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50XG4gICAgICogMi4gVGhpcyBjb250YWluZXJcbiAgICAgKiAzLiBBZGRpdGlvbmFsIHBhcmFtcyBwYXNzZWQgaW4gdG8gdGhpcyBjYWxsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9zIFRoZSBwb3NpdGlvbiBmcm9tIHdoaWNoIGNvbXBvbmVudCBzaG91bGQgYmUgZGV0YWNoZWRcbiAgICAgKiBAcGFyYW0gcGFyYW1zIGFkZGl0aW9uYWwgcGFyYW1zIHRvIGJlIHBhc3NlZCBkb3duIHRoZSB0aGUgYGRldGFjaENvbXBvbmVudGAgZXZlbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZGV0YWNoQ29tcG9uZW50KHBvczogbnVtYmVyLCBwYXJhbXM6IGFueSA9IHt9KTogQ29tcG9uZW50IHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHBvcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gcG9zO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50c1tpXS5nZXRJZCgpID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy5jb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHNbcG9zXTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnNwbGljZShwb3MsIDEpO1xuXG4gICAgICAgIHBhcmFtcyA9IGRlZmF1bHRzKHtwb3N9LCBwYXJhbXMpO1xuICAgICAgICB0aGlzLmVtaXQoXCJkZXRhY2hDb21wb25lbnRcIiwgY29tcG9uZW50LCB0aGlzLCBwYXJhbXMpO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdWItY29tcG9uZW50IHVuZGVyIGhpZXJhcmNoeSBvZiB0aGlzIENvbnRhaW5lciB3aXRoIHRoZSBnaXZlbiBpZFxuICAgICAqIEBwYXJhbSBpZCBpZCBvZiB0aGUgY29tcG9uZW50IHRvIGZpbmRcbiAgICAgKi9cbiAgICBwdWJsaWMgZmluZENvbXBvbmVudChpZDogc3RyaW5nKTogQ29tcG9uZW50IHtcbiAgICAgICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgdGhpcy5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmdldElkKCkgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlYXJjaCBpbiBhbnkgc3ViY29udGFpbmVyc1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnRhaW5lciBvZiB0aGlzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGlmICghKGNvbnRhaW5lciBpbnN0YW5jZW9mIENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN1YkNvbXBvbmVudCA9IGNvbnRhaW5lci5maW5kQ29tcG9uZW50KGlkKTtcbiAgICAgICAgICAgIGlmIChzdWJDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViQ29tcG9uZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICovXG4gICAgcHVibGljIHRvSlNPTigpOiBhbnkge1xuICAgICAgICBjb25zdCBvcHRzID0gc3VwZXIudG9KU09OKCk7XG5cbiAgICAgICAgb3B0cy5jb21wb25lbnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIHRoaXMuY29tcG9uZW50cykge1xuICAgICAgICAgICAgb3B0cy5jb21wb25lbnRzLnB1c2goY29tcG9uZW50LnRvSlNPTigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSBmcmFtYnVmZmVyIG1hbmFnZXIgZm9yIHRoaXMgY29udGFpbmVyXG4gICAgICogQHBhcmFtIHRzbSB0aGUgZnJhbWJ1ZmZlcm1hbmFnZXJcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2V0VFNNKHRzbTogVGV4dHVyZVNldE1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy50c20gPSB0c207XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0NvbnRhaW5lci50cyIsImltcG9ydCBTdGFjayBmcm9tICcuL19TdGFjay5qcyc7XG5pbXBvcnQgZXF1YWxBcnJheXMgZnJvbSAnLi9fZXF1YWxBcnJheXMuanMnO1xuaW1wb3J0IGVxdWFsQnlUYWcgZnJvbSAnLi9fZXF1YWxCeVRhZy5qcyc7XG5pbXBvcnQgZXF1YWxPYmplY3RzIGZyb20gJy4vX2VxdWFsT2JqZWN0cy5qcyc7XG5pbXBvcnQgZ2V0VGFnIGZyb20gJy4vX2dldFRhZy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNFcXVhbERlZXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsRGVlcC5qc1xuLy8gbW9kdWxlIGlkID0gMjEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNldENhY2hlQWRkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRDYWNoZUFkZC5qc1xuLy8gbW9kdWxlIGlkID0gMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRDYWNoZUhhcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0Q2FjaGVIYXMuanNcbi8vIG1vZHVsZSBpZCA9IDIxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5U29tZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTb21lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgVWludDhBcnJheSBmcm9tICcuL19VaW50OEFycmF5LmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcbmltcG9ydCBlcXVhbEFycmF5cyBmcm9tICcuL19lcXVhbEFycmF5cy5qcyc7XG5pbXBvcnQgbWFwVG9BcnJheSBmcm9tICcuL19tYXBUb0FycmF5LmpzJztcbmltcG9ydCBzZXRUb0FycmF5IGZyb20gJy4vX3NldFRvQXJyYXkuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcXVhbEJ5VGFnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEJ5VGFnLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBUb0FycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBUb0FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgZ2V0QWxsS2V5cyBmcm9tICcuL19nZXRBbGxLZXlzLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsT2JqZWN0cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxPYmplY3RzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGJhc2VDbG9uZSBmcm9tICcuL19iYXNlQ2xvbmUuanMnO1xuaW1wb3J0IGJhc2VVbnNldCBmcm9tICcuL19iYXNlVW5zZXQuanMnO1xuaW1wb3J0IGNhc3RQYXRoIGZyb20gJy4vX2Nhc3RQYXRoLmpzJztcbmltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGN1c3RvbU9taXRDbG9uZSBmcm9tICcuL19jdXN0b21PbWl0Q2xvbmUuanMnO1xuaW1wb3J0IGZsYXRSZXN0IGZyb20gJy4vX2ZsYXRSZXN0LmpzJztcbmltcG9ydCBnZXRBbGxLZXlzSW4gZnJvbSAnLi9fZ2V0QWxsS2V5c0luLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBwYXRocyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBvbWl0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdiJzogJzInIH1cbiAqL1xudmFyIG9taXQgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgaXNEZWVwID0gZmFsc2U7XG4gIHBhdGhzID0gYXJyYXlNYXAocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH0pO1xuICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBvbWl0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL29taXQuanNcbi8vIG1vZHVsZSBpZCA9IDIyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgbGFzdCBmcm9tICcuL2xhc3QuanMnO1xuaW1wb3J0IHBhcmVudCBmcm9tICcuL19wYXJlbnQuanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcHJvcGVydHkgcGF0aCB0byB1bnNldC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IGRlbGV0ZSBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVW5zZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbnNldC5qc1xuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VHZXQgZnJvbSAnLi9fYmFzZUdldC5qcyc7XG5pbXBvcnQgYmFzZVNsaWNlIGZyb20gJy4vX2Jhc2VTbGljZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byBnZXQgdGhlIHBhcmVudCB2YWx1ZSBvZi5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwYXJlbnQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgMiA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyZW50O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19wYXJlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJy4vaXNQbGFpbk9iamVjdC5qcyc7XG5cbi8qKlxuICogVXNlZCBieSBgXy5vbWl0YCB0byBjdXN0b21pemUgaXRzIGBfLmNsb25lRGVlcGAgdXNlIHRvIG9ubHkgY2xvbmUgcGxhaW5cbiAqIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW5jbG9uZWQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgdG8gZGVmZXIgY2xvbmluZyB0byBgXy5jbG9uZURlZXBgLlxuICovXG5mdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGN1c3RvbU9taXRDbG9uZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3VzdG9tT21pdENsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUGxhaW5PYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNQbGFpbk9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xudmFyIGlkQ291bnRlciA9IDA7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAqXG4gKiBfLnVuaXF1ZUlkKCk7XG4gKiAvLyA9PiAnMTA1J1xuICovXG5mdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVuaXF1ZUlkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3VuaXF1ZUlkLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUVhY2ggZnJvbSAnLi9fYmFzZUVhY2guanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGaWx0ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlRm9yIGZyb20gJy4vX2Jhc2VGb3IuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlRm9yT3duO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRm9yT3duLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgY3JlYXRlQmFzZUZvciBmcm9tICcuL19jcmVhdGVCYXNlRm9yLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlRm9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRm9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQmFzZUZvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQmFzZUZvci5qc1xuLy8gbW9kdWxlIGlkID0gMjMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCYXNlRWFjaDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQmFzZUVhY2guanNcbi8vIG1vZHVsZSBpZCA9IDIzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlSXNNYXRjaCBmcm9tICcuL19iYXNlSXNNYXRjaC5qcyc7XG5pbXBvcnQgZ2V0TWF0Y2hEYXRhIGZyb20gJy4vX2dldE1hdGNoRGF0YS5qcyc7XG5pbXBvcnQgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU1hdGNoZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNYXRjaGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGJhc2VJc0VxdWFsIGZyb20gJy4vX2Jhc2VJc0VxdWFsLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc01hdGNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNNYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGlzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19pc1N0cmljdENvbXBhcmFibGUuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE1hdGNoRGF0YTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TWF0Y2hEYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUlzRXF1YWwgZnJvbSAnLi9fYmFzZUlzRXF1YWwuanMnO1xuaW1wb3J0IGdldCBmcm9tICcuL2dldC5qcyc7XG5pbXBvcnQgaGFzSW4gZnJvbSAnLi9oYXNJbi5qcyc7XG5pbXBvcnQgaXNLZXkgZnJvbSAnLi9faXNLZXkuanMnO1xuaW1wb3J0IGlzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19pc1N0cmljdENvbXBhcmFibGUuanMnO1xuaW1wb3J0IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIGZyb20gJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzJztcbmltcG9ydCB0b0tleSBmcm9tICcuL190b0tleS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU1hdGNoZXNQcm9wZXJ0eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMjM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VHZXQgZnJvbSAnLi9fYmFzZUdldC5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2dldC5qc1xuLy8gbW9kdWxlIGlkID0gMjM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VQcm9wZXJ0eSBmcm9tICcuL19iYXNlUHJvcGVydHkuanMnO1xuaW1wb3J0IGJhc2VQcm9wZXJ0eURlZXAgZnJvbSAnLi9fYmFzZVByb3BlcnR5RGVlcC5qcyc7XG5pbXBvcnQgaXNLZXkgZnJvbSAnLi9faXNLZXkuanMnO1xuaW1wb3J0IHRvS2V5IGZyb20gJy4vX3RvS2V5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcm9wZXJ0eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMjM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VHZXQgZnJvbSAnLi9fYmFzZUdldC5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUHJvcGVydHlEZWVwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUHJvcGVydHlEZWVwLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZURpZmZlcmVuY2UgZnJvbSAnLi9fYmFzZURpZmZlcmVuY2UuanMnO1xuaW1wb3J0IGJhc2VGbGF0dGVuIGZyb20gJy4vX2Jhc2VGbGF0dGVuLmpzJztcbmltcG9ydCBiYXNlUmVzdCBmcm9tICcuL19iYXNlUmVzdC5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2VPYmplY3QgZnJvbSAnLi9pc0FycmF5TGlrZU9iamVjdC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGFycmF5c1xuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gKiBAc2VlIF8ud2l0aG91dCwgXy54b3JcbiAqIEBleGFtcGxlXG4gKlxuICogXy5kaWZmZXJlbmNlKFsyLCAxXSwgWzIsIDNdKTtcbiAqIC8vID0+IFsxXVxuICovXG52YXIgZGlmZmVyZW5jZSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKVxuICAgIDogW107XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZGlmZmVyZW5jZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9kaWZmZXJlbmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgU2V0Q2FjaGUgZnJvbSAnLi9fU2V0Q2FjaGUuanMnO1xuaW1wb3J0IGFycmF5SW5jbHVkZXMgZnJvbSAnLi9fYXJyYXlJbmNsdWRlcy5qcyc7XG5pbXBvcnQgYXJyYXlJbmNsdWRlc1dpdGggZnJvbSAnLi9fYXJyYXlJbmNsdWRlc1dpdGguanMnO1xuaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBjYWNoZUhhcyBmcm9tICcuL19jYWNoZUhhcy5qcyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgfVxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgfVxuICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID09IG51bGwgPyB2YWx1ZSA6IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlRGlmZmVyZW5jZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZURpZmZlcmVuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDI0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlRmluZEluZGV4O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRmluZEluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNOYU47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc05hTi5qc1xuLy8gbW9kdWxlIGlkID0gMjQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpY3RJbmRleE9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdHJpY3RJbmRleE9mLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYXJyYXlFYWNoIGZyb20gJy4vX2FycmF5RWFjaC5qcyc7XG5pbXBvcnQgYmFzZUVhY2ggZnJvbSAnLi9fYmFzZUVhY2guanMnO1xuaW1wb3J0IGNhc3RGdW5jdGlvbiBmcm9tICcuL19jYXN0RnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gKlxuICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZvckVhY2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZm9yRWFjaC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IExvZGFzaFdyYXBwZXIgZnJvbSAnLi9fTG9kYXNoV3JhcHBlci5qcyc7XG5pbXBvcnQgZmxhdFJlc3QgZnJvbSAnLi9fZmxhdFJlc3QuanMnO1xuaW1wb3J0IGdldERhdGEgZnJvbSAnLi9fZ2V0RGF0YS5qcyc7XG5pbXBvcnQgZ2V0RnVuY05hbWUgZnJvbSAnLi9fZ2V0RnVuY05hbWUuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0xhemlhYmxlIGZyb20gJy4vX2lzTGF6aWFibGUuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTY7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxvdyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmNzKSB7XG4gICAgdmFyIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgIHByZXJlcSA9IExvZGFzaFdyYXBwZXIucHJvdG90eXBlLnRocnU7XG5cbiAgICBpZiAoZnJvbVJpZ2h0KSB7XG4gICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVyZXEgJiYgIXdyYXBwZXIgJiYgZ2V0RnVuY05hbWUoZnVuYykgPT0gJ3dyYXBwZXInKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gbmV3IExvZGFzaFdyYXBwZXIoW10sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbmRleCA9IHdyYXBwZXIgPyBpbmRleCA6IGxlbmd0aDtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgZnVuYyA9IGZ1bmNzW2luZGV4XTtcblxuICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChkYXRhICYmIGlzTGF6aWFibGUoZGF0YVswXSkgJiZcbiAgICAgICAgICAgIGRhdGFbMV0gPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykgJiZcbiAgICAgICAgICAgICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDFcbiAgICAgICAgICApIHtcbiAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJbZ2V0RnVuY05hbWUoZGF0YVswXSldLmFwcGx5KHdyYXBwZXIsIGRhdGFbM10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JhcHBlciA9IChmdW5jLmxlbmd0aCA9PSAxICYmIGlzTGF6aWFibGUoZnVuYykpXG4gICAgICAgICAgPyB3cmFwcGVyW2Z1bmNOYW1lXSgpXG4gICAgICAgICAgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHZhbHVlID0gYXJnc1swXTtcblxuICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gd3JhcHBlci5wbGFudCh2YWx1ZSkudmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gbGVuZ3RoID8gZnVuY3NbaW5kZXhdLmFwcGx5KHRoaXMsIGFyZ3MpIDogdmFsdWU7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVGbG93O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVGbG93LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiogVXNlZCB0byBsb29rdXAgdW5taW5pZmllZCBmdW5jdGlvbiBuYW1lcy4gKi9cbnZhciByZWFsTmFtZXMgPSB7fTtcblxuZXhwb3J0IGRlZmF1bHQgcmVhbE5hbWVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yZWFsTmFtZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBMYXp5V3JhcHBlciBmcm9tICcuL19MYXp5V3JhcHBlci5qcyc7XG5pbXBvcnQgTG9kYXNoV3JhcHBlciBmcm9tICcuL19Mb2Rhc2hXcmFwcGVyLmpzJztcbmltcG9ydCBiYXNlTG9kYXNoIGZyb20gJy4vX2Jhc2VMb2Rhc2guanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuaW1wb3J0IHdyYXBwZXJDbG9uZSBmcm9tICcuL193cmFwcGVyQ2xvbmUuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgaW1wbGljaXQgbWV0aG9kXG4gKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcbiAqIGFuZCBmdW5jdGlvbnMgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIuIE1ldGhvZHMgdGhhdCByZXRyaWV2ZSBhIHNpbmdsZSB2YWx1ZVxuICogb3IgbWF5IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZW5kIHRoZSBjaGFpbiBzZXF1ZW5jZVxuICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxuICogd2l0aCBgXyN2YWx1ZWAuXG4gKlxuICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXG4gKiBlbmFibGVkIHVzaW5nIGBfLmNoYWluYC5cbiAqXG4gKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXG4gKiBgXyN2YWx1ZWAgaXMgaW1wbGljaXRseSBvciBleHBsaWNpdGx5IGNhbGxlZC5cbiAqXG4gKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cbiAqIFNob3J0Y3V0IGZ1c2lvbiBpcyBhbiBvcHRpbWl6YXRpb24gdG8gbWVyZ2UgaXRlcmF0ZWUgY2FsbHM7IHRoaXMgYXZvaWRzXG4gKiB0aGUgY3JlYXRpb24gb2YgaW50ZXJtZWRpYXRlIGFycmF5cyBhbmQgY2FuIGdyZWF0bHkgcmVkdWNlIHRoZSBudW1iZXIgb2ZcbiAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcbiAqIGZ1c2lvbiBpZiB0aGUgc2VjdGlvbiBpcyBhcHBsaWVkIHRvIGFuIGFycmF5IGFuZCBpdGVyYXRlZXMgYWNjZXB0IG9ubHlcbiAqIG9uZSBhcmd1bWVudC4gVGhlIGhldXJpc3RpYyBmb3Igd2hldGhlciBhIHNlY3Rpb24gcXVhbGlmaWVzIGZvciBzaG9ydGN1dFxuICogZnVzaW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlxuICpcbiAqIENoYWluaW5nIGlzIHN1cHBvcnRlZCBpbiBjdXN0b20gYnVpbGRzIGFzIGxvbmcgYXMgdGhlIGBfI3ZhbHVlYCBtZXRob2QgaXNcbiAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIGxvZGFzaCBtZXRob2RzLCB3cmFwcGVycyBoYXZlIGBBcnJheWAgYW5kIGBTdHJpbmdgIG1ldGhvZHMuXG4gKlxuICogVGhlIHdyYXBwZXIgYEFycmF5YCBtZXRob2RzIGFyZTpcbiAqIGBjb25jYXRgLCBgam9pbmAsIGBwb3BgLCBgcHVzaGAsIGBzaGlmdGAsIGBzb3J0YCwgYHNwbGljZWAsIGFuZCBgdW5zaGlmdGBcbiAqXG4gKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcbiAqIGByZXBsYWNlYCBhbmQgYHNwbGl0YFxuICpcbiAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XG4gKiBgYXRgLCBgY29tcGFjdGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBkcm9wV2hpbGVgLCBgZmlsdGVyYCwgYGZpbmRgLFxuICogYGZpbmRMYXN0YCwgYGhlYWRgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGByZWplY3RgLCBgcmV2ZXJzZWAsIGBzbGljZWAsXG4gKiBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBhbmQgYHRvQXJyYXlgXG4gKlxuICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICogYGFmdGVyYCwgYGFyeWAsIGBhc3NpZ25gLCBgYXNzaWduSW5gLCBgYXNzaWduSW5XaXRoYCwgYGFzc2lnbldpdGhgLCBgYXRgLFxuICogYGJlZm9yZWAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjYXN0QXJyYXlgLCBgY2hhaW5gLCBgY2h1bmtgLFxuICogYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25mb3Jtc2AsIGBjb25zdGFudGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsXG4gKiBgY3VycnlgLCBgZGVib3VuY2VgLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGRlZmVyYCwgYGRlbGF5YCxcbiAqIGBkaWZmZXJlbmNlYCwgYGRpZmZlcmVuY2VCeWAsIGBkaWZmZXJlbmNlV2l0aGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsXG4gKiBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGV4dGVuZGAsIGBleHRlbmRXaXRoYCwgYGZpbGxgLCBgZmlsdGVyYCxcbiAqIGBmbGF0TWFwYCwgYGZsYXRNYXBEZWVwYCwgYGZsYXRNYXBEZXB0aGAsIGBmbGF0dGVuYCwgYGZsYXR0ZW5EZWVwYCxcbiAqIGBmbGF0dGVuRGVwdGhgLCBgZmxpcGAsIGBmbG93YCwgYGZsb3dSaWdodGAsIGBmcm9tUGFpcnNgLCBgZnVuY3Rpb25zYCxcbiAqIGBmdW5jdGlvbnNJbmAsIGBncm91cEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludGVyc2VjdGlvbkJ5YCxcbiAqIGBpbnRlcnNlY3Rpb25XaXRoYCwgYGludmVydGAsIGBpbnZlcnRCeWAsIGBpbnZva2VNYXBgLCBgaXRlcmF0ZWVgLCBga2V5QnlgLFxuICogYGtleXNgLCBga2V5c0luYCwgYG1hcGAsIGBtYXBLZXlzYCwgYG1hcFZhbHVlc2AsIGBtYXRjaGVzYCwgYG1hdGNoZXNQcm9wZXJ0eWAsXG4gKiBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXJnZVdpdGhgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCwgYG5lZ2F0ZWAsXG4gKiBgbnRoQXJnYCwgYG9taXRgLCBgb21pdEJ5YCwgYG9uY2VgLCBgb3JkZXJCeWAsIGBvdmVyYCwgYG92ZXJBcmdzYCxcbiAqIGBvdmVyRXZlcnlgLCBgb3ZlclNvbWVgLCBgcGFydGlhbGAsIGBwYXJ0aWFsUmlnaHRgLCBgcGFydGl0aW9uYCwgYHBpY2tgLFxuICogYHBpY2tCeWAsIGBwbGFudGAsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLCBgcHVsbEFsbGAsIGBwdWxsQWxsQnlgLFxuICogYHB1bGxBbGxXaXRoYCwgYHB1bGxBdGAsIGBwdXNoYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVhcmdgLCBgcmVqZWN0YCxcbiAqIGByZW1vdmVgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNhbXBsZVNpemVgLCBgc2V0YCwgYHNldFdpdGhgLCBgc2h1ZmZsZWAsXG4gKiBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAqIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBgdGFwYCwgYHRocm90dGxlYCwgYHRocnVgLCBgdG9BcnJheWAsXG4gKiBgdG9QYWlyc2AsIGB0b1BhaXJzSW5gLCBgdG9QYXRoYCwgYHRvUGxhaW5PYmplY3RgLCBgdHJhbnNmb3JtYCwgYHVuYXJ5YCxcbiAqIGB1bmlvbmAsIGB1bmlvbkJ5YCwgYHVuaW9uV2l0aGAsIGB1bmlxYCwgYHVuaXFCeWAsIGB1bmlxV2l0aGAsIGB1bnNldGAsXG4gKiBgdW5zaGlmdGAsIGB1bnppcGAsIGB1bnppcFdpdGhgLCBgdXBkYXRlYCwgYHVwZGF0ZVdpdGhgLCBgdmFsdWVzYCxcbiAqIGB2YWx1ZXNJbmAsIGB3aXRob3V0YCwgYHdyYXBgLCBgeG9yYCwgYHhvckJ5YCwgYHhvcldpdGhgLCBgemlwYCxcbiAqIGB6aXBPYmplY3RgLCBgemlwT2JqZWN0RGVlcGAsIGFuZCBgemlwV2l0aGBcbiAqXG4gKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgYXJlICoqbm90KiogY2hhaW5hYmxlIGJ5IGRlZmF1bHQgYXJlOlxuICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xhbXBgLCBgY2xvbmVgLFxuICogYGNsb25lRGVlcGAsIGBjbG9uZURlZXBXaXRoYCwgYGNsb25lV2l0aGAsIGBjb25mb3Jtc1RvYCwgYGRlYnVycmAsXG4gKiBgZGVmYXVsdFRvYCwgYGRpdmlkZWAsIGBlYWNoYCwgYGVhY2hSaWdodGAsIGBlbmRzV2l0aGAsIGBlcWAsIGBlc2NhcGVgLFxuICogYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCxcbiAqIGBmaW5kTGFzdEluZGV4YCwgYGZpbmRMYXN0S2V5YCwgYGZpcnN0YCwgYGZsb29yYCwgYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCxcbiAqIGBmb3JJbmAsIGBmb3JJblJpZ2h0YCwgYGZvck93bmAsIGBmb3JPd25SaWdodGAsIGBnZXRgLCBgZ3RgLCBgZ3RlYCwgYGhhc2AsXG4gKiBgaGFzSW5gLCBgaGVhZGAsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCwgYGluUmFuZ2VgLCBgaW52b2tlYCxcbiAqIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQXJyYXlCdWZmZXJgLCBgaXNBcnJheUxpa2VgLCBgaXNBcnJheUxpa2VPYmplY3RgLFxuICogYGlzQm9vbGVhbmAsIGBpc0J1ZmZlcmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCwgYGlzRW1wdHlgLCBgaXNFcXVhbGAsXG4gKiBgaXNFcXVhbFdpdGhgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzSW50ZWdlcmAsIGBpc0xlbmd0aGAsXG4gKiBgaXNNYXBgLCBgaXNNYXRjaGAsIGBpc01hdGNoV2l0aGAsIGBpc05hTmAsIGBpc05hdGl2ZWAsIGBpc05pbGAsIGBpc051bGxgLFxuICogYGlzTnVtYmVyYCwgYGlzT2JqZWN0YCwgYGlzT2JqZWN0TGlrZWAsIGBpc1BsYWluT2JqZWN0YCwgYGlzUmVnRXhwYCxcbiAqIGBpc1NhZmVJbnRlZ2VyYCwgYGlzU2V0YCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXG4gKiBgaXNXZWFrTWFwYCwgYGlzV2Vha1NldGAsIGBqb2luYCwgYGtlYmFiQ2FzZWAsIGBsYXN0YCwgYGxhc3RJbmRleE9mYCxcbiAqIGBsb3dlckNhc2VgLCBgbG93ZXJGaXJzdGAsIGBsdGAsIGBsdGVgLCBgbWF4YCwgYG1heEJ5YCwgYG1lYW5gLCBgbWVhbkJ5YCxcbiAqIGBtaW5gLCBgbWluQnlgLCBgbXVsdGlwbHlgLCBgbm9Db25mbGljdGAsIGBub29wYCwgYG5vd2AsIGBudGhgLCBgcGFkYCxcbiAqIGBwYWRFbmRgLCBgcGFkU3RhcnRgLCBgcGFyc2VJbnRgLCBgcG9wYCwgYHJhbmRvbWAsIGByZWR1Y2VgLCBgcmVkdWNlUmlnaHRgLFxuICogYHJlcGVhdGAsIGByZXN1bHRgLCBgcm91bmRgLCBgcnVuSW5Db250ZXh0YCwgYHNhbXBsZWAsIGBzaGlmdGAsIGBzaXplYCxcbiAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRJbmRleEJ5YCwgYHNvcnRlZExhc3RJbmRleGAsXG4gKiBgc29ydGVkTGFzdEluZGV4QnlgLCBgc3RhcnRDYXNlYCwgYHN0YXJ0c1dpdGhgLCBgc3R1YkFycmF5YCwgYHN0dWJGYWxzZWAsXG4gKiBgc3R1Yk9iamVjdGAsIGBzdHViU3RyaW5nYCwgYHN0dWJUcnVlYCwgYHN1YnRyYWN0YCwgYHN1bWAsIGBzdW1CeWAsXG4gKiBgdGVtcGxhdGVgLCBgdGltZXNgLCBgdG9GaW5pdGVgLCBgdG9JbnRlZ2VyYCwgYHRvSlNPTmAsIGB0b0xlbmd0aGAsXG4gKiBgdG9Mb3dlcmAsIGB0b051bWJlcmAsIGB0b1NhZmVJbnRlZ2VyYCwgYHRvU3RyaW5nYCwgYHRvVXBwZXJgLCBgdHJpbWAsXG4gKiBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBgdHJ1bmNhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBgdXBwZXJDYXNlYCxcbiAqIGB1cHBlckZpcnN0YCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAqXG4gKiBAbmFtZSBfXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjYXRlZ29yeSBTZXFcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICogICByZXR1cm4gbiAqIG47XG4gKiB9XG4gKlxuICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gKlxuICogLy8gUmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWUuXG4gKiB3cmFwcGVkLnJlZHVjZShfLmFkZCk7XG4gKiAvLyA9PiA2XG4gKlxuICogLy8gUmV0dXJucyBhIHdyYXBwZWQgdmFsdWUuXG4gKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKHNxdWFyZSk7XG4gKlxuICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gIGlmIChpc09iamVjdExpa2UodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcbiAgICAgIHJldHVybiB3cmFwcGVyQ2xvbmUodmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUpO1xufVxuXG4vLyBFbnN1cmUgd3JhcHBlcnMgYXJlIGluc3RhbmNlcyBvZiBgYmFzZUxvZGFzaGAuXG5sb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XG5sb2Rhc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbG9kYXNoO1xuXG5leHBvcnQgZGVmYXVsdCBsb2Rhc2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvd3JhcHBlckxvZGFzaC5qc1xuLy8gbW9kdWxlIGlkID0gMjQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IExhenlXcmFwcGVyIGZyb20gJy4vX0xhenlXcmFwcGVyLmpzJztcbmltcG9ydCBMb2Rhc2hXcmFwcGVyIGZyb20gJy4vX0xvZGFzaFdyYXBwZXIuanMnO1xuaW1wb3J0IGNvcHlBcnJheSBmcm9tICcuL19jb3B5QXJyYXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgd3JhcHBlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB3cmFwcGVyIFRoZSB3cmFwcGVyIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG4gKi9cbmZ1bmN0aW9uIHdyYXBwZXJDbG9uZSh3cmFwcGVyKSB7XG4gIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICByZXR1cm4gd3JhcHBlci5jbG9uZSgpO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXyk7XG4gIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh3cmFwcGVyLl9fYWN0aW9uc19fKTtcbiAgcmVzdWx0Ll9faW5kZXhfXyAgPSB3cmFwcGVyLl9faW5kZXhfXztcbiAgcmVzdWx0Ll9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdyYXBwZXJDbG9uZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fd3JhcHBlckNsb25lLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGJhc2VJbnRlcnNlY3Rpb24gZnJvbSAnLi9fYmFzZUludGVyc2VjdGlvbi5qcyc7XG5pbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGNhc3RBcnJheUxpa2VPYmplY3QgZnJvbSAnLi9fY2FzdEFycmF5TGlrZU9iamVjdC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBnaXZlbiBhcnJheXNcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmludGVyc2VjdGlvbihbMiwgMV0sIFsyLCAzXSk7XG4gKiAvLyA9PiBbMl1cbiAqL1xudmFyIGludGVyc2VjdGlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICB2YXIgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcbiAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQpXG4gICAgOiBbXTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBpbnRlcnNlY3Rpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaW50ZXJzZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgU2V0Q2FjaGUgZnJvbSAnLi9fU2V0Q2FjaGUuanMnO1xuaW1wb3J0IGFycmF5SW5jbHVkZXMgZnJvbSAnLi9fYXJyYXlJbmNsdWRlcy5qcyc7XG5pbXBvcnQgYXJyYXlJbmNsdWRlc1dpdGggZnJvbSAnLi9fYXJyYXlJbmNsdWRlc1dpdGguanMnO1xuaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBjYWNoZUhhcyBmcm9tICcuL19jYWNoZUhhcy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmNsdWRlcyA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsXG4gICAgICBsZW5ndGggPSBhcnJheXNbMF0ubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgY2FjaGVzID0gQXJyYXkob3RoTGVuZ3RoKSxcbiAgICAgIG1heExlbmd0aCA9IEluZmluaXR5LFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICB2YXIgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xuICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZSkge1xuICAgICAgYXJyYXkgPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgfVxuICAgIG1heExlbmd0aCA9IG5hdGl2ZU1pbihhcnJheS5sZW5ndGgsIG1heExlbmd0aCk7XG4gICAgY2FjaGVzW290aEluZGV4XSA9ICFjb21wYXJhdG9yICYmIChpdGVyYXRlZSB8fCAobGVuZ3RoID49IDEyMCAmJiBhcnJheS5sZW5ndGggPj0gMTIwKSlcbiAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIH1cbiAgYXJyYXkgPSBhcnJheXNbMF07XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBzZWVuID0gY2FjaGVzWzBdO1xuXG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoIShzZWVuXG4gICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcbiAgICAgICAgICA6IGluY2x1ZGVzKHJlc3VsdCwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgICkpIHtcbiAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzW290aEluZGV4XTtcbiAgICAgICAgaWYgKCEoY2FjaGVcbiAgICAgICAgICAgICAgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgIDogaW5jbHVkZXMoYXJyYXlzW290aEluZGV4XSwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJbnRlcnNlY3Rpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJbnRlcnNlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDI1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBpc0FycmF5TGlrZU9iamVjdCBmcm9tICcuL2lzQXJyYXlMaWtlT2JqZWN0LmpzJztcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGFuIGVtcHR5IGFycmF5IGlmIGl0J3Mgbm90IGFuIGFycmF5IGxpa2Ugb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS1saWtlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2FzdEFycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpID8gdmFsdWUgOiBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FzdEFycmF5TGlrZU9iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdEFycmF5TGlrZU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VTZXREYXRhIGZyb20gJy4vX2Jhc2VTZXREYXRhLmpzJztcbmltcG9ydCBjcmVhdGVCaW5kIGZyb20gJy4vX2NyZWF0ZUJpbmQuanMnO1xuaW1wb3J0IGNyZWF0ZUN1cnJ5IGZyb20gJy4vX2NyZWF0ZUN1cnJ5LmpzJztcbmltcG9ydCBjcmVhdGVIeWJyaWQgZnJvbSAnLi9fY3JlYXRlSHlicmlkLmpzJztcbmltcG9ydCBjcmVhdGVQYXJ0aWFsIGZyb20gJy4vX2NyZWF0ZVBhcnRpYWwuanMnO1xuaW1wb3J0IGdldERhdGEgZnJvbSAnLi9fZ2V0RGF0YS5qcyc7XG5pbXBvcnQgbWVyZ2VEYXRhIGZyb20gJy4vX21lcmdlRGF0YS5qcyc7XG5pbXBvcnQgc2V0RGF0YSBmcm9tICcuL19zZXREYXRhLmpzJztcbmltcG9ydCBzZXRXcmFwVG9TdHJpbmcgZnJvbSAnLi9fc2V0V3JhcFRvU3RyaW5nLmpzJztcbmltcG9ydCB0b0ludGVnZXIgZnJvbSAnLi90b0ludGVnZXIuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LFxuICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgIHdpdGggb3B0aW9uYWxcbiAqIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgICAxIC0gYF8uYmluZGBcbiAqICAgIDIgLSBgXy5iaW5kS2V5YFxuICogICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gKiAgICA4IC0gYF8uY3VycnlgXG4gKiAgIDE2IC0gYF8uY3VycnlSaWdodGBcbiAqICAgMzIgLSBgXy5wYXJ0aWFsYFxuICogICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAqICAxMjggLSBgXy5yZWFyZ2BcbiAqICAyNTYgLSBgXy5hcnlgXG4gKiAgNTEyIC0gYF8uZmxpcGBcbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgdmFyIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBiaXRtYXNrICY9IH4oV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICB9XG4gIGFyeSA9IGFyeSA9PT0gdW5kZWZpbmVkID8gYXJ5IDogbmF0aXZlTWF4KHRvSW50ZWdlcihhcnkpLCAwKTtcbiAgYXJpdHkgPSBhcml0eSA9PT0gdW5kZWZpbmVkID8gYXJpdHkgOiB0b0ludGVnZXIoYXJpdHkpO1xuICBsZW5ndGggLT0gaG9sZGVycyA/IGhvbGRlcnMubGVuZ3RoIDogMDtcblxuICBpZiAoYml0bWFzayAmIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcbiAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcblxuICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgZGF0YSA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGdldERhdGEoZnVuYyk7XG5cbiAgdmFyIG5ld0RhdGEgPSBbXG4gICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCxcbiAgICBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgXTtcblxuICBpZiAoZGF0YSkge1xuICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgfVxuICBmdW5jID0gbmV3RGF0YVswXTtcbiAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gIHRoaXNBcmcgPSBuZXdEYXRhWzJdO1xuICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gIGhvbGRlcnMgPSBuZXdEYXRhWzRdO1xuICBhcml0eSA9IG5ld0RhdGFbOV0gPSBuZXdEYXRhWzldID09PSB1bmRlZmluZWRcbiAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXG4gICAgOiBuYXRpdmVNYXgobmV3RGF0YVs5XSAtIGxlbmd0aCwgMCk7XG5cbiAgaWYgKCFhcml0eSAmJiBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRykpIHtcbiAgICBiaXRtYXNrICY9IH4oV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKTtcbiAgfVxuICBpZiAoIWJpdG1hc2sgfHwgYml0bWFzayA9PSBXUkFQX0JJTkRfRkxBRykge1xuICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpO1xuICB9IGVsc2UgaWYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHIHx8IGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSB7XG4gICAgcmVzdWx0ID0gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpO1xuICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFdSQVBfUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKFdSQVBfQklORF9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcpKSAmJiAhaG9sZGVycy5sZW5ndGgpIHtcbiAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWQuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgfVxuICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcbiAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhzZXR0ZXIocmVzdWx0LCBuZXdEYXRhKSwgZnVuYywgYml0bWFzayk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVdyYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZVdyYXAuanNcbi8vIG1vZHVsZSBpZCA9IDI1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBjcmVhdGVDdG9yIGZyb20gJy4vX2NyZWF0ZUN0b3IuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQklORF9GTEFHID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIG9wdGlvbmFsIGB0aGlzYFxuICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZykge1xuICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgIHJldHVybiBmbi5hcHBseShpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQmluZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQmluZC5qc1xuLy8gbW9kdWxlIGlkID0gMjUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcbmltcG9ydCBjcmVhdGVDdG9yIGZyb20gJy4vX2NyZWF0ZUN0b3IuanMnO1xuaW1wb3J0IGNyZWF0ZUh5YnJpZCBmcm9tICcuL19jcmVhdGVIeWJyaWQuanMnO1xuaW1wb3J0IGNyZWF0ZVJlY3VycnkgZnJvbSAnLi9fY3JlYXRlUmVjdXJyeS5qcyc7XG5pbXBvcnQgZ2V0SG9sZGVyIGZyb20gJy4vX2dldEhvbGRlci5qcyc7XG5pbXBvcnQgcmVwbGFjZUhvbGRlcnMgZnJvbSAnLi9fcmVwbGFjZUhvbGRlcnMuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGVuYWJsZSBjdXJyeWluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gIHZhciBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICB9XG4gICAgdmFyIGhvbGRlcnMgPSAobGVuZ3RoIDwgMyAmJiBhcmdzWzBdICE9PSBwbGFjZWhvbGRlciAmJiBhcmdzW2xlbmd0aCAtIDFdICE9PSBwbGFjZWhvbGRlcilcbiAgICAgID8gW11cbiAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgbGVuZ3RoIC09IGhvbGRlcnMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCBhcml0eSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdW5kZWZpbmVkLFxuICAgICAgICBhcmdzLCBob2xkZXJzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkgLSBsZW5ndGgpO1xuICAgIH1cbiAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgIHJldHVybiBhcHBseShmbiwgdGhpcywgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUN1cnJ5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVDdXJyeS5qc1xuLy8gbW9kdWxlIGlkID0gMjU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYHBsYWNlaG9sZGVyYCBvY2N1cnJlbmNlcyBpbiBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAqL1xuZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gMDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3VudEhvbGRlcnM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvdW50SG9sZGVycy5qc1xuLy8gbW9kdWxlIGlkID0gMjU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG52YXIgcmVXcmFwRGV0YWlscyA9IC9cXHtcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoICguKylcXF0gXFwqLyxcbiAgICByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG5cbi8qKlxuICogRXh0cmFjdHMgd3JhcHBlciBkZXRhaWxzIGZyb20gdGhlIGBzb3VyY2VgIGJvZHkgY29tbWVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cbiAqL1xuZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XG4gIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFdyYXBEZXRhaWxzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRXcmFwRGV0YWlscy5qc1xuLy8gbW9kdWxlIGlkID0gMjU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG52YXIgcmVXcmFwQ29tbWVudCA9IC9cXHsoPzpcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoIC4rXFxdIFxcKlxcLyk/XFxuPy87XG5cbi8qKlxuICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBpbnNlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzb3VyY2UuXG4gKi9cbmZ1bmN0aW9uIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgZGV0YWlscykge1xuICB2YXIgbGVuZ3RoID0gZGV0YWlscy5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgZGV0YWlsc1tsYXN0SW5kZXhdID0gKGxlbmd0aCA+IDEgPyAnJiAnIDogJycpICsgZGV0YWlsc1tsYXN0SW5kZXhdO1xuICBkZXRhaWxzID0gZGV0YWlscy5qb2luKGxlbmd0aCA+IDIgPyAnLCAnIDogJyAnKTtcbiAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluc2VydFdyYXBEZXRhaWxzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pbnNlcnRXcmFwRGV0YWlscy5qc1xuLy8gbW9kdWxlIGlkID0gMjU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGFycmF5RWFjaCBmcm9tICcuL19hcnJheUVhY2guanMnO1xuaW1wb3J0IGFycmF5SW5jbHVkZXMgZnJvbSAnLi9fYXJyYXlJbmNsdWRlcy5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQklORF9GTEFHID0gMSxcbiAgICBXUkFQX0JJTkRfS0VZX0ZMQUcgPSAyLFxuICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgV1JBUF9QQVJUSUFMX0ZMQUcgPSAzMixcbiAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXG4gICAgV1JBUF9SRUFSR19GTEFHID0gMjU2LFxuICAgIFdSQVBfRkxJUF9GTEFHID0gNTEyO1xuXG4vKiogVXNlZCB0byBhc3NvY2lhdGUgd3JhcCBtZXRob2RzIHdpdGggdGhlaXIgYml0IGZsYWdzLiAqL1xudmFyIHdyYXBGbGFncyA9IFtcbiAgWydhcnknLCBXUkFQX0FSWV9GTEFHXSxcbiAgWydiaW5kJywgV1JBUF9CSU5EX0ZMQUddLFxuICBbJ2JpbmRLZXknLCBXUkFQX0JJTkRfS0VZX0ZMQUddLFxuICBbJ2N1cnJ5JywgV1JBUF9DVVJSWV9GTEFHXSxcbiAgWydjdXJyeVJpZ2h0JywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHXSxcbiAgWydmbGlwJywgV1JBUF9GTElQX0ZMQUddLFxuICBbJ3BhcnRpYWwnLCBXUkFQX1BBUlRJQUxfRkxBR10sXG4gIFsncGFydGlhbFJpZ2h0JywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUddLFxuICBbJ3JlYXJnJywgV1JBUF9SRUFSR19GTEFHXVxuXTtcblxuLyoqXG4gKiBVcGRhdGVzIHdyYXBwZXIgYGRldGFpbHNgIGJhc2VkIG9uIGBiaXRtYXNrYCBmbGFncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRldGFpbHNgLlxuICovXG5mdW5jdGlvbiB1cGRhdGVXcmFwRGV0YWlscyhkZXRhaWxzLCBiaXRtYXNrKSB7XG4gIGFycmF5RWFjaCh3cmFwRmxhZ3MsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICB2YXIgdmFsdWUgPSAnXy4nICsgcGFpclswXTtcbiAgICBpZiAoKGJpdG1hc2sgJiBwYWlyWzFdKSAmJiAhYXJyYXlJbmNsdWRlcyhkZXRhaWxzLCB2YWx1ZSkpIHtcbiAgICAgIGRldGFpbHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRldGFpbHMuc29ydCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB1cGRhdGVXcmFwRGV0YWlscztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdXBkYXRlV3JhcERldGFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDI1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogUmVvcmRlciBgYXJyYXlgIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGVsZW1lbnQgYXRcbiAqIHRoZSBmaXJzdCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGVsZW1lbnQgYXRcbiAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJyYXkgaW5kZXhlcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiByZW9yZGVyKGFycmF5LCBpbmRleGVzKSB7XG4gIHZhciBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICBvbGRBcnJheSA9IGNvcHlBcnJheShhcnJheSk7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVvcmRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVvcmRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcbmltcG9ydCBjcmVhdGVDdG9yIGZyb20gJy4vX2NyZWF0ZUN0b3IuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xudmFyIFdSQVBfQklORF9GTEFHID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgYXJncyA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSxcbiAgICAgICAgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuXG4gICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgfVxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUGFydGlhbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlUGFydGlhbC5qc1xuLy8gbW9kdWxlIGlkID0gMjYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGNvbXBvc2VBcmdzIGZyb20gJy4vX2NvbXBvc2VBcmdzLmpzJztcbmltcG9ydCBjb21wb3NlQXJnc1JpZ2h0IGZyb20gJy4vX2NvbXBvc2VBcmdzUmlnaHQuanMnO1xuaW1wb3J0IHJlcGxhY2VIb2xkZXJzIGZyb20gJy4vX3JlcGxhY2VIb2xkZXJzLmpzJztcblxuLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xudmFyIFBMQUNFSE9MREVSID0gJ19fbG9kYXNoX3BsYWNlaG9sZGVyX18nO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBmdW5jdGlvbiBtZXRhZGF0YS4gKi9cbnZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcgPSA0LFxuICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICpcbiAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZFxuICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAqIGV4ZWN1dGVkIGltcG9ydGFudCwgcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZVxuICogYW4gZXhjZXB0aW9uIGZvciBhIHNhZmUgY29tYmluZWQgY2FzZSB3aGVyZSBjdXJyaWVkIGZ1bmN0aW9ucyBoYXZlIGBfLmFyeWBcbiAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXRhZGF0YS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGF0YWAuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YShkYXRhLCBzb3VyY2UpIHtcbiAgdmFyIGJpdG1hc2sgPSBkYXRhWzFdLFxuICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgIG5ld0JpdG1hc2sgPSBiaXRtYXNrIHwgc3JjQml0bWFzayxcbiAgICAgIGlzQ29tbW9uID0gbmV3Qml0bWFzayA8IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyB8IFdSQVBfQVJZX0ZMQUcpO1xuXG4gIHZhciBpc0NvbWJvID1cbiAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSkgfHxcbiAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9SRUFSR19GTEFHKSAmJiAoZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSkgfHxcbiAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxuICBpZiAoIShpc0NvbW1vbiB8fCBpc0NvbWJvKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYHRoaXNBcmdgIGlmIGF2YWlsYWJsZS5cbiAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG4gICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbiAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gIH1cbiAgLy8gQ29tcG9zZSBwYXJ0aWFsIGFyZ3VtZW50cy5cbiAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICBpZiAodmFsdWUpIHtcbiAgICB2YXIgcGFydGlhbHMgPSBkYXRhWzNdO1xuICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs0XTtcbiAgfVxuICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XG4gICAgZGF0YVs2XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVs1XSwgUExBQ0VIT0xERVIpIDogc291cmNlWzZdO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuICB2YWx1ZSA9IHNvdXJjZVs3XTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgZGF0YVs3XSA9IHZhbHVlO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcbiAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG4gIH1cbiAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gIGlmIChkYXRhWzldID09IG51bGwpIHtcbiAgICBkYXRhWzldID0gc291cmNlWzldO1xuICB9XG4gIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cbiAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lcmdlRGF0YTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWVyZ2VEYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgdG9OdW1iZXIgZnJvbSAnLi90b051bWJlci5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b0Zpbml0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b0Zpbml0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvTnVtYmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvTnVtYmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUZsYXR0ZW4gZnJvbSAnLi9fYmFzZUZsYXR0ZW4uanMnO1xuaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCBiYXNlVW5pcSBmcm9tICcuL19iYXNlVW5pcS5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2VPYmplY3QgZnJvbSAnLi9pc0FycmF5TGlrZU9iamVjdC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgZ2l2ZW4gYXJyYXlzIHVzaW5nXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVuaW9uKFsyXSwgWzEsIDJdKTtcbiAqIC8vID0+IFsyLCAxXVxuICovXG52YXIgdW5pb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB1bmlvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy91bmlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IFNldCBmcm9tICcuL19TZXQuanMnO1xuaW1wb3J0IG5vb3AgZnJvbSAnLi9ub29wLmpzJztcbmltcG9ydCBzZXRUb0FycmF5IGZyb20gJy4vX3NldFRvQXJyYXkuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gKi9cbnZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZVNldC5qc1xuLy8gbW9kdWxlIGlkID0gMjY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VWYWx1ZXMgZnJvbSAnLi9fYmFzZVZhbHVlcy5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsdWVzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3ZhbHVlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VWYWx1ZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VWYWx1ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlU2xpY2UgZnJvbSAnLi9fYmFzZVNsaWNlLmpzJztcbmltcG9ydCB0b0ludGVnZXIgZnJvbSAnLi90b0ludGVnZXIuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZHJvcChbMSwgMiwgM10pO1xuICogLy8gPT4gWzIsIDNdXG4gKlxuICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gKiAvLyA9PiBbM11cbiAqXG4gKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAqIC8vID0+IFtdXG4gKlxuICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gKiAvLyA9PiBbMSwgMiwgM11cbiAqL1xuZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkcm9wO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Ryb3AuanNcbi8vIG1vZHVsZSBpZCA9IDI2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGNyZWF0ZUFzc2lnbmVyIGZyb20gJy4vX2NyZWF0ZUFzc2lnbmVyLmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIG93biBhbmRcbiAqIGluaGVyaXRlZCBzb3VyY2UgcHJvcGVydGllcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAYWxpYXMgZXh0ZW5kXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uYXNzaWduXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBmdW5jdGlvbiBCYXIoKSB7XG4gKiAgIHRoaXMuYyA9IDM7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gKlxuICogXy5hc3NpZ25Jbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMywgJ2QnOiA0IH1cbiAqL1xudmFyIGFzc2lnbkluID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnbkluO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Fzc2lnbkluLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGlzSXRlcmF0ZWVDYWxsIGZyb20gJy4vX2lzSXRlcmF0ZWVDYWxsLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQXNzaWduZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUFzc2lnbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYmFzZUhhcyBmcm9tICcuL19iYXNlSGFzLmpzJztcbmltcG9ydCBoYXNQYXRoIGZyb20gJy4vX2hhc1BhdGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAqIHZhciBvdGhlciA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2hhcy5qc1xuLy8gbW9kdWxlIGlkID0gMjcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSGFzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKlxuICogR2VuZXJhdGVkIGJ5IFBFRy5qcyAwLjEwLjAuXG4gKlxuICogaHR0cDovL3BlZ2pzLm9yZy9cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcbiAgZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gIGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcbn1cblxuZnVuY3Rpb24gcGVnJFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHtcbiAgdGhpcy5tZXNzYWdlICA9IG1lc3NhZ2U7XG4gIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgdGhpcy5mb3VuZCAgICA9IGZvdW5kO1xuICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gIHRoaXMubmFtZSAgICAgPSBcIlN5bnRheEVycm9yXCI7XG5cbiAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgcGVnJFN5bnRheEVycm9yKTtcbiAgfVxufVxuXG5wZWckc3ViY2xhc3MocGVnJFN5bnRheEVycm9yLCBFcnJvcik7XG5cbnBlZyRTeW50YXhFcnJvci5idWlsZE1lc3NhZ2UgPSBmdW5jdGlvbihleHBlY3RlZCwgZm91bmQpIHtcbiAgdmFyIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOUyA9IHtcbiAgICAgICAgbGl0ZXJhbDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gXCJcXFwiXCIgKyBsaXRlcmFsRXNjYXBlKGV4cGVjdGF0aW9uLnRleHQpICsgXCJcXFwiXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJjbGFzc1wiOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgICAgIHZhciBlc2NhcGVkUGFydHMgPSBcIlwiLFxuICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGF0aW9uLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlc2NhcGVkUGFydHMgKz0gZXhwZWN0YXRpb24ucGFydHNbaV0gaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICA/IGNsYXNzRXNjYXBlKGV4cGVjdGF0aW9uLnBhcnRzW2ldWzBdKSArIFwiLVwiICsgY2xhc3NFc2NhcGUoZXhwZWN0YXRpb24ucGFydHNbaV1bMV0pXG4gICAgICAgICAgICAgIDogY2xhc3NFc2NhcGUoZXhwZWN0YXRpb24ucGFydHNbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBcIltcIiArIChleHBlY3RhdGlvbi5pbnZlcnRlZCA/IFwiXlwiIDogXCJcIikgKyBlc2NhcGVkUGFydHMgKyBcIl1cIjtcbiAgICAgICAgfSxcblxuICAgICAgICBhbnk6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYW55IGNoYXJhY3RlclwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuZDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gXCJlbmQgb2YgaW5wdXRcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBvdGhlcjogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZXhwZWN0YXRpb24uZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgZnVuY3Rpb24gaGV4KGNoKSB7XG4gICAgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXRlcmFsRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgIC5yZXBsYWNlKC9cIi9nLCAgJ1xcXFxcIicpXG4gICAgICAucmVwbGFjZSgvXFwwL2csICdcXFxcMCcpXG4gICAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXG4gICAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpXG4gICAgICAucmVwbGFjZSgvW1xceDAwLVxceDBGXS9nLCAgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4JyAgKyBoZXgoY2gpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzRXNjYXBlKHMpIHtcbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgIC5yZXBsYWNlKC9cXF0vZywgJ1xcXFxdJylcbiAgICAgIC5yZXBsYWNlKC9cXF4vZywgJ1xcXFxeJylcbiAgICAgIC5yZXBsYWNlKC8tL2csICAnXFxcXC0nKVxuICAgICAgLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKVxuICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKVxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxuICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKVxuICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwRl0vZywgICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceDAnICsgaGV4KGNoKTsgfSlcbiAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg3Ri1cXHg5Rl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceCcgICsgaGV4KGNoKTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgcmV0dXJuIERFU0NSSUJFX0VYUEVDVEFUSU9OX0ZOU1tleHBlY3RhdGlvbi50eXBlXShleHBlY3RhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGVkKGV4cGVjdGVkKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9ucyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLFxuICAgICAgICBpLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdGlvbnNbaV0gPSBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGVkW2ldKTtcbiAgICB9XG5cbiAgICBkZXNjcmlwdGlvbnMuc29ydCgpO1xuXG4gICAgaWYgKGRlc2NyaXB0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGkgPSAxLCBqID0gMTsgaSA8IGRlc2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGVzY3JpcHRpb25zW2kgLSAxXSAhPT0gZGVzY3JpcHRpb25zW2ldKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb25zW2pdID0gZGVzY3JpcHRpb25zW2ldO1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVzY3JpcHRpb25zLmxlbmd0aCA9IGo7XG4gICAgfVxuXG4gICAgc3dpdGNoIChkZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF07XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uc1swXSArIFwiIG9yIFwiICsgZGVzY3JpcHRpb25zWzFdO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcbiAgICAgICAgICArIFwiLCBvciBcIlxuICAgICAgICAgICsgZGVzY3JpcHRpb25zW2Rlc2NyaXB0aW9ucy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXNjcmliZUZvdW5kKGZvdW5kKSB7XG4gICAgcmV0dXJuIGZvdW5kID8gXCJcXFwiXCIgKyBsaXRlcmFsRXNjYXBlKGZvdW5kKSArIFwiXFxcIlwiIDogXCJlbmQgb2YgaW5wdXRcIjtcbiAgfVxuXG4gIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZGVzY3JpYmVFeHBlY3RlZChleHBlY3RlZCkgKyBcIiBidXQgXCIgKyBkZXNjcmliZUZvdW5kKGZvdW5kKSArIFwiIGZvdW5kLlwiO1xufTtcblxuZnVuY3Rpb24gcGVnJHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XG5cbiAgdmFyIHBlZyRGQUlMRUQgPSB7fSxcblxuICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucyA9IHsgcHJvZ3JhbTogcGVnJHBhcnNlcHJvZ3JhbSB9LFxuICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uICA9IHBlZyRwYXJzZXByb2dyYW0sXG5cbiAgICAgIHBlZyRjMCA9IFwiO1wiLFxuICAgICAgcGVnJGMxID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjtcIiwgZmFsc2UpLFxuICAgICAgcGVnJGMyID0gZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHZhciBzdG10cyA9IFtwWzFdXTtcbiAgICAgICAgICBzdG10cyA9IHN0bXRzLmNvbmNhdChtYXAocFszXSwgZnVuY3Rpb24ocHApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBwWzJdO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEFzdC5Qcm9ncmFtKHN0bXRzKTtcbiAgICAgIH0sXG4gICAgICBwZWckYzMgPSBcIj1cIixcbiAgICAgIHBlZyRjNCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI9XCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNSA9IGZ1bmN0aW9uKGxocywgZSkgeyByZXR1cm4gbmV3IEFzdC5Bc3NpZ25tZW50KGxocywgZSk7IH0sXG4gICAgICBwZWckYzYgPSBcIitcIixcbiAgICAgIHBlZyRjNyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIrXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjOCA9IFwiLVwiLFxuICAgICAgcGVnJGM5ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi1cIiwgZmFsc2UpLFxuICAgICAgcGVnJGMxMCA9IFwiKlwiLFxuICAgICAgcGVnJGMxMSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIqXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMTIgPSBcIi9cIixcbiAgICAgIHBlZyRjMTMgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiL1wiLCBmYWxzZSksXG4gICAgICBwZWckYzE0ID0gXCIlXCIsXG4gICAgICBwZWckYzE1ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIiVcIiwgZmFsc2UpLFxuICAgICAgcGVnJGMxNiA9IFwiJlwiLFxuICAgICAgcGVnJGMxNyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCImXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMTggPSBcInxcIixcbiAgICAgIHBlZyRjMTkgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwifFwiLCBmYWxzZSksXG4gICAgICBwZWckYzIwID0gZnVuY3Rpb24oaGVhZCwgdGFpbCkgeyByZXR1cm4gbWFrZUJpbmFyeUV4cHIoaGVhZCwgdGFpbCk7IH0sXG4gICAgICBwZWckYzIxID0gZnVuY3Rpb24ob3AsIG9wZXIpIHsgcmV0dXJuIG5ldyBBc3QuVW5hcnlFeHByKG9wLCBvcGVyKTsgfSxcbiAgICAgIHBlZyRjMjIgPSAvXlthLXpBLVpfXS8sXG4gICAgICBwZWckYzIzID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgXCJfXCJdLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgcGVnJGMyNCA9IC9eW2EtekEtWl8wLTldLyxcbiAgICAgIHBlZyRjMjUgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiYVwiLCBcInpcIl0sIFtcIkFcIiwgXCJaXCJdLCBcIl9cIiwgW1wiMFwiLCBcIjlcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgcGVnJGMyNiA9IFwiKFwiLFxuICAgICAgcGVnJGMyNyA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIoXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjMjggPSBcIixcIixcbiAgICAgIHBlZyRjMjkgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLFwiLCBmYWxzZSksXG4gICAgICBwZWckYzMwID0gXCIpXCIsXG4gICAgICBwZWckYzMxID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIilcIiwgZmFsc2UpLFxuICAgICAgcGVnJGMzMiA9IGZ1bmN0aW9uKGZ1bmNOYW1lLCBhcmdzKSB7XG4gICAgICBcdFx0ICAgICAgICB2YXIgYXJnc0xpc3QgPSBbXTtcbiAgICAgIFx0XHQgICAgICAgIGVhY2goYXJnc1swXSwgZnVuY3Rpb24odG9rcykge1xuICAgICAgXHRcdCAgICAgICAgICAgIGFyZ3NMaXN0LnB1c2godG9rc1sxXSk7XG4gICAgICBcdFx0ICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzTGlzdC5wdXNoKGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXN0LkZ1bmNDYWxsKGZsYXR0ZW5DaGFycyhmdW5jTmFtZSksIGFyZ3NMaXN0KTtcbiAgICAgIFx0XHR9LFxuICAgICAgcGVnJGMzMyA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGU7IH0sXG4gICAgICBwZWckYzM0ID0gZnVuY3Rpb24odmFsKSB7IHJldHVybiBuZXcgQXN0LlByaW1hcnlFeHByKGZsYXR0ZW5DaGFycyh2YWwpLnRvTG93ZXJDYXNlKCksIFwiSURcIik7IH0sXG4gICAgICBwZWckYzM1ID0gXCIkXCIsXG4gICAgICBwZWckYzM2ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIiRcIiwgZmFsc2UpLFxuICAgICAgcGVnJGMzNyA9IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gbmV3IEFzdC5QcmltYXJ5RXhwcihmbGF0dGVuQ2hhcnModmFsKS50b0xvd2VyQ2FzZSgpLCBcIkNPTlNUXCIpOyB9LFxuICAgICAgcGVnJGMzOCA9IFwiQFwiLFxuICAgICAgcGVnJGMzOSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJAXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNDAgPSBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIG5ldyBBc3QuUHJpbWFyeUV4cHIoXCJfX1JFR19BVF9cIiArIGZsYXR0ZW5DaGFycyh2YWwpLnRvTG93ZXJDYXNlKCksIFwiUkVHXCIpOyB9LFxuICAgICAgcGVnJGM0MSA9IC9eW3JSXS8sXG4gICAgICBwZWckYzQyID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiclwiLCBcIlJcIl0sIGZhbHNlLCBmYWxzZSksXG4gICAgICBwZWckYzQzID0gL15bZUVdLyxcbiAgICAgIHBlZyRjNDQgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCJlXCIsIFwiRVwiXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgIHBlZyRjNDUgPSAvXltnR10vLFxuICAgICAgcGVnJGM0NiA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcImdcIiwgXCJHXCJdLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgcGVnJGM0NyA9IC9eWzAtOV0vLFxuICAgICAgcGVnJGM0OCA9IHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCIwXCIsIFwiOVwiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgICBwZWckYzQ5ID0gZnVuY3Rpb24odmFsKSB7IHJldHVybiBuZXcgQXN0LlByaW1hcnlFeHByKFwiX19SRUdfXCIgKyBmbGF0dGVuQ2hhcnModmFsKS50b0xvd2VyQ2FzZSgpLCBcIlJFR1wiKTsgfSxcbiAgICAgIHBlZyRjNTAgPSBcIi5cIixcbiAgICAgIHBlZyRjNTEgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiLlwiLCBmYWxzZSksXG4gICAgICBwZWckYzUyID0gL15bRWVdLyxcbiAgICAgIHBlZyRjNTMgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCJFXCIsIFwiZVwiXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgIHBlZyRjNTQgPSBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIG5ldyBBc3QuUHJpbWFyeUV4cHIocGFyc2VGbG9hdChmbGF0dGVuQ2hhcnModmFsKSksIFwiVkFMVUVcIik7IH0sXG4gICAgICBwZWckYzU1ID0gL15bYS1mQS1GMC05XS8sXG4gICAgICBwZWckYzU2ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcImFcIiwgXCJmXCJdLCBbXCJBXCIsIFwiRlwiXSwgW1wiMFwiLCBcIjlcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgcGVnJGM1NyA9IC9eW2hIXS8sXG4gICAgICBwZWckYzU4ID0gcGVnJGNsYXNzRXhwZWN0YXRpb24oW1wiaFwiLCBcIkhcIl0sIGZhbHNlLCBmYWxzZSksXG4gICAgICBwZWckYzU5ID0gZnVuY3Rpb24odmFsKSB7IHJldHVybiBuZXcgQXN0LlByaW1hcnlFeHByKHBhcnNlSW50KGZsYXR0ZW5DaGFycyh2YWwpLCAxNiksIFwiVkFMVUVcIik7IH0sXG4gICAgICBwZWckYzYwID0gL15bZERdLyxcbiAgICAgIHBlZyRjNjEgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCJkXCIsIFwiRFwiXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgIHBlZyRjNjIgPSBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIG5ldyBBc3QuUHJpbWFyeUV4cHIocGFyc2VJbnQoZmxhdHRlbkNoYXJzKHZhbCksIDEwKSwgXCJWQUxVRVwiKTsgfSxcbiAgICAgIHBlZyRjNjMgPSAvXltcXHRcXHgwQlxcZiBcXHhBMFxcdUZFRkZdLyxcbiAgICAgIHBlZyRjNjQgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCJcXHRcIiwgXCJcXHgwQlwiLCBcIlxcZlwiLCBcIiBcIiwgXCJcXHhBMFwiLCBcIlxcdUZFRkZcIl0sIGZhbHNlLCBmYWxzZSksXG4gICAgICBwZWckYzY1ID0gL15bXFxuXFxyXFx1MjAyOFxcdTIwMjldLyxcbiAgICAgIHBlZyRjNjYgPSBwZWckY2xhc3NFeHBlY3RhdGlvbihbXCJcXG5cIiwgXCJcXHJcIiwgXCJcXHUyMDI4XCIsIFwiXFx1MjAyOVwiXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgIHBlZyRjNjcgPSBcIi8qXCIsXG4gICAgICBwZWckYzY4ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi8qXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNjkgPSBcIiovXCIsXG4gICAgICBwZWckYzcwID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIiovXCIsIGZhbHNlKSxcbiAgICAgIHBlZyRjNzEgPSBwZWckYW55RXhwZWN0YXRpb24oKSxcbiAgICAgIHBlZyRjNzIgPSBcIi8vXCIsXG4gICAgICBwZWckYzczID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi8vXCIsIGZhbHNlKSxcblxuICAgICAgcGVnJGN1cnJQb3MgICAgICAgICAgPSAwLFxuICAgICAgcGVnJHNhdmVkUG9zICAgICAgICAgPSAwLFxuICAgICAgcGVnJHBvc0RldGFpbHNDYWNoZSAgPSBbeyBsaW5lOiAxLCBjb2x1bW46IDEgfV0sXG4gICAgICBwZWckbWF4RmFpbFBvcyAgICAgICA9IDAsXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkICA9IFtdLFxuICAgICAgcGVnJHNpbGVudEZhaWxzICAgICAgPSAwLFxuXG4gICAgICBwZWckcmVzdWx0O1xuXG4gIGlmIChcInN0YXJ0UnVsZVwiIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlRnVuY3Rpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3RhcnQgcGFyc2luZyBmcm9tIHJ1bGUgXFxcIlwiICsgb3B0aW9ucy5zdGFydFJ1bGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cblxuICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbnNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7XG4gIH1cblxuICBmdW5jdGlvbiBleHBlY3RlZChkZXNjcmlwdGlvbiwgbG9jYXRpb24pIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uICE9PSB2b2lkIDAgPyBsb2NhdGlvbiA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcylcblxuICAgIHRocm93IHBlZyRidWlsZFN0cnVjdHVyZWRFcnJvcihcbiAgICAgIFtwZWckb3RoZXJFeHBlY3RhdGlvbihkZXNjcmlwdGlvbildLFxuICAgICAgaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpLFxuICAgICAgbG9jYXRpb25cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgbG9jYXRpb24pIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uICE9PSB2b2lkIDAgPyBsb2NhdGlvbiA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcylcblxuICAgIHRocm93IHBlZyRidWlsZFNpbXBsZUVycm9yKG1lc3NhZ2UsIGxvY2F0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24odGV4dCwgaWdub3JlQ2FzZSkge1xuICAgIHJldHVybiB7IHR5cGU6IFwibGl0ZXJhbFwiLCB0ZXh0OiB0ZXh0LCBpZ25vcmVDYXNlOiBpZ25vcmVDYXNlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckY2xhc3NFeHBlY3RhdGlvbihwYXJ0cywgaW52ZXJ0ZWQsIGlnbm9yZUNhc2UpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImNsYXNzXCIsIHBhcnRzOiBwYXJ0cywgaW52ZXJ0ZWQ6IGludmVydGVkLCBpZ25vcmVDYXNlOiBpZ25vcmVDYXNlIH07XG4gIH1cblxuICBmdW5jdGlvbiBwZWckYW55RXhwZWN0YXRpb24oKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJhbnlcIiB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGVuZEV4cGVjdGF0aW9uKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZW5kXCIgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRvdGhlckV4cGVjdGF0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpIHtcbiAgICB2YXIgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcG9zXSwgcDtcblxuICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICByZXR1cm4gZGV0YWlscztcbiAgICB9IGVsc2Uge1xuICAgICAgcCA9IHBvcyAtIDE7XG4gICAgICB3aGlsZSAoIXBlZyRwb3NEZXRhaWxzQ2FjaGVbcF0pIHtcbiAgICAgICAgcC0tO1xuICAgICAgfVxuXG4gICAgICBkZXRhaWxzID0gcGVnJHBvc0RldGFpbHNDYWNoZVtwXTtcbiAgICAgIGRldGFpbHMgPSB7XG4gICAgICAgIGxpbmU6ICAgZGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IGRldGFpbHMuY29sdW1uXG4gICAgICB9O1xuXG4gICAgICB3aGlsZSAocCA8IHBvcykge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwKSA9PT0gMTApIHtcbiAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgfVxuXG4gICAgICAgIHArKztcbiAgICAgIH1cblxuICAgICAgcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdID0gZGV0YWlscztcbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRjb21wdXRlTG9jYXRpb24oc3RhcnRQb3MsIGVuZFBvcykge1xuICAgIHZhciBzdGFydFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoc3RhcnRQb3MpLFxuICAgICAgICBlbmRQb3NEZXRhaWxzICAgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoZW5kUG9zKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydDoge1xuICAgICAgICBvZmZzZXQ6IHN0YXJ0UG9zLFxuICAgICAgICBsaW5lOiAgIHN0YXJ0UG9zRGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IHN0YXJ0UG9zRGV0YWlscy5jb2x1bW5cbiAgICAgIH0sXG4gICAgICBlbmQ6IHtcbiAgICAgICAgb2Zmc2V0OiBlbmRQb3MsXG4gICAgICAgIGxpbmU6ICAgZW5kUG9zRGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IGVuZFBvc0RldGFpbHMuY29sdW1uXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRmYWlsKGV4cGVjdGVkKSB7XG4gICAgaWYgKHBlZyRjdXJyUG9zIDwgcGVnJG1heEZhaWxQb3MpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAocGVnJGN1cnJQb3MgPiBwZWckbWF4RmFpbFBvcykge1xuICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgPSBbXTtcbiAgICB9XG5cbiAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGJ1aWxkU2ltcGxlRXJyb3IobWVzc2FnZSwgbG9jYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IHBlZyRTeW50YXhFcnJvcihtZXNzYWdlLCBudWxsLCBudWxsLCBsb2NhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoZXhwZWN0ZWQsIGZvdW5kLCBsb2NhdGlvbikge1xuICAgIHJldHVybiBuZXcgcGVnJFN5bnRheEVycm9yKFxuICAgICAgcGVnJFN5bnRheEVycm9yLmJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBmb3VuZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXByb2dyYW0oKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNywgczgsIHM5LCBzMTA7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJGN1cnJQb3M7XG4gICAgczIgPSBwZWckcGFyc2VfXygpO1xuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczMgPSBwZWckcGFyc2VzdGF0ZW1lbnQoKTtcbiAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzNCA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM1ID0gW107XG4gICAgICAgICAgczYgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU5KSB7XG4gICAgICAgICAgICBzNyA9IHBlZyRjMDtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM3ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM4ID0gcGVnJHBhcnNlX18oKTtcbiAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzOSA9IHBlZyRwYXJzZXN0YXRlbWVudCgpO1xuICAgICAgICAgICAgICBpZiAoczkgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzMTAgPSBwZWckcGFyc2VfXygpO1xuICAgICAgICAgICAgICAgIGlmIChzMTAgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM3ID0gW3M3LCBzOCwgczksIHMxMF07XG4gICAgICAgICAgICAgICAgICBzNiA9IHM3O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM2O1xuICAgICAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM2O1xuICAgICAgICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNjtcbiAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHM2O1xuICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1LnB1c2goczYpO1xuICAgICAgICAgICAgczYgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTkpIHtcbiAgICAgICAgICAgICAgczcgPSBwZWckYzA7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM4ID0gcGVnJHBhcnNlX18oKTtcbiAgICAgICAgICAgICAgaWYgKHM4ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczkgPSBwZWckcGFyc2VzdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoczkgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHMxMCA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczEwICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHM3ID0gW3M3LCBzOCwgczksIHMxMF07XG4gICAgICAgICAgICAgICAgICAgIHM2ID0gczc7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM2O1xuICAgICAgICAgICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczY7XG4gICAgICAgICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczY7XG4gICAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM2O1xuICAgICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA1OSkge1xuICAgICAgICAgICAgICBzNiA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczYgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlX18oKTtcbiAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczIgPSBbczIsIHMzLCBzNCwgczUsIHM2LCBzN107XG4gICAgICAgICAgICAgICAgczEgPSBzMjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMxO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMxO1xuICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMxO1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMxO1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgczEgPSBwZWckYzIoczEpO1xuICAgIH1cbiAgICBzMCA9IHMxO1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlc3RhdGVtZW50KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZWFzc2lnbmFibGUoKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlX18oKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDYxKSB7XG4gICAgICAgICAgczMgPSBwZWckYzM7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQgPSBwZWckcGFyc2VfXygpO1xuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczUgPSBwZWckcGFyc2Vib29sZWFuX2V4cHIoKTtcbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczEgPSBwZWckYzUoczEsIHM1KTtcbiAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRwYXJzZWJvb2xlYW5fZXhwcigpO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXVuYXJ5X29wcygpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQzKSB7XG4gICAgICBzMCA9IHBlZyRjNjtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3KTsgfVxuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDUpIHtcbiAgICAgICAgczAgPSBwZWckYzg7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM5KTsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWFkZGl0aXZlX29wcygpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQzKSB7XG4gICAgICBzMCA9IHBlZyRjNjtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3KTsgfVxuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDUpIHtcbiAgICAgICAgczAgPSBwZWckYzg7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM5KTsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW11bHRpcGxpY2F0aXZlX29wcygpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQyKSB7XG4gICAgICBzMCA9IHBlZyRjMTA7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTEpOyB9XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nykge1xuICAgICAgICBzMCA9IHBlZyRjMTI7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMyk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM3KSB7XG4gICAgICAgICAgczAgPSBwZWckYzE0O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxNSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWJvb2xlYW5fb3BzKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzgpIHtcbiAgICAgIHMwID0gcGVnJGMxNjtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxNyk7IH1cbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyNCkge1xuICAgICAgICBzMCA9IHBlZyRjMTg7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxOSk7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2Vib29sZWFuX2V4cHIoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VhZGRpdGl2ZV9leHByKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IFtdO1xuICAgICAgczMgPSBwZWckY3VyclBvcztcbiAgICAgIHM0ID0gcGVnJHBhcnNlX18oKTtcbiAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzNSA9IHBlZyRwYXJzZWJvb2xlYW5fb3BzKCk7XG4gICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM2ID0gcGVnJHBhcnNlX18oKTtcbiAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlYWRkaXRpdmVfZXhwcigpO1xuICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM0ID0gW3M0LCBzNSwgczYsIHM3XTtcbiAgICAgICAgICAgICAgczMgPSBzNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgczMgPSBwZWckY3VyclBvcztcbiAgICAgICAgczQgPSBwZWckcGFyc2VfXygpO1xuICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNSA9IHBlZyRwYXJzZWJvb2xlYW5fb3BzKCk7XG4gICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNiA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczcgPSBwZWckcGFyc2VhZGRpdGl2ZV9leHByKCk7XG4gICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM0ID0gW3M0LCBzNSwgczYsIHM3XTtcbiAgICAgICAgICAgICAgICBzMyA9IHM0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMyMChzMSwgczIpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWFkZGl0aXZlX2V4cHIoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VtdWx0aXBsaWNhdGl2ZV9leHByKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IFtdO1xuICAgICAgczMgPSBwZWckY3VyclBvcztcbiAgICAgIHM0ID0gcGVnJHBhcnNlX18oKTtcbiAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzNSA9IHBlZyRwYXJzZWFkZGl0aXZlX29wcygpO1xuICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNiA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNyA9IHBlZyRwYXJzZW11bHRpcGxpY2F0aXZlX2V4cHIoKTtcbiAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNCA9IFtzNCwgczUsIHM2LCBzN107XG4gICAgICAgICAgICAgIHMzID0gczQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgIHMzID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHM0ID0gcGVnJHBhcnNlX18oKTtcbiAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczUgPSBwZWckcGFyc2VhZGRpdGl2ZV9vcHMoKTtcbiAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlX18oKTtcbiAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZW11bHRpcGxpY2F0aXZlX2V4cHIoKTtcbiAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczQgPSBbczQsIHM1LCBzNiwgczddO1xuICAgICAgICAgICAgICAgIHMzID0gczQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzIwKHMxLCBzMik7XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbXVsdGlwbGljYXRpdmVfZXhwcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3O1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZXVuYXJ5KCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IFtdO1xuICAgICAgczMgPSBwZWckY3VyclBvcztcbiAgICAgIHM0ID0gcGVnJHBhcnNlX18oKTtcbiAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzNSA9IHBlZyRwYXJzZW11bHRpcGxpY2F0aXZlX29wcygpO1xuICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNiA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNyA9IHBlZyRwYXJzZXVuYXJ5KCk7XG4gICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczQgPSBbczQsIHM1LCBzNiwgczddO1xuICAgICAgICAgICAgICBzMyA9IHM0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzNCA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNlbXVsdGlwbGljYXRpdmVfb3BzKCk7XG4gICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNiA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczcgPSBwZWckcGFyc2V1bmFyeSgpO1xuICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNCA9IFtzNCwgczUsIHM2LCBzN107XG4gICAgICAgICAgICAgICAgczMgPSBzNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMjAoczEsIHMyKTtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2V1bmFyeSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNldW5hcnlfb3BzKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBwZWckcGFyc2VmdW5jX2NhbGwoKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzIxKHMxLCBzMyk7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJHBhcnNlZnVuY19jYWxsKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlZnVuY19jYWxsKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczcsIHM4LCBzOSwgczEwO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChwZWckYzIyLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyMyk7IH1cbiAgICB9XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMyA9IFtdO1xuICAgICAgaWYgKHBlZyRjMjQudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyNSk7IH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgaWYgKHBlZyRjMjQudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjUpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IFtzMiwgczNdO1xuICAgICAgICBzMSA9IHMyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMxO1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlX18oKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQwKSB7XG4gICAgICAgICAgczMgPSBwZWckYzI2O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyNyk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHM1ID0gW107XG4gICAgICAgICAgczYgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBzNyA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzOCA9IHBlZyRwYXJzZWJvb2xlYW5fZXhwcigpO1xuICAgICAgICAgICAgaWYgKHM4ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM5ID0gcGVnJHBhcnNlX18oKTtcbiAgICAgICAgICAgICAgaWYgKHM5ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgICAgICAgICAgczEwID0gcGVnJGMyODtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHMxMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjkpOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzMTAgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM3ID0gW3M3LCBzOCwgczksIHMxMF07XG4gICAgICAgICAgICAgICAgICBzNiA9IHM3O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM2O1xuICAgICAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM2O1xuICAgICAgICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNjtcbiAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHM2O1xuICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1LnB1c2goczYpO1xuICAgICAgICAgICAgczYgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlX18oKTtcbiAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzOCA9IHBlZyRwYXJzZWJvb2xlYW5fZXhwcigpO1xuICAgICAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzOSA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgICAgICAgICAgaWYgKHM5ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHMxMCA9IHBlZyRjMjg7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzMTAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjkpOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoczEwICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHM3ID0gW3M3LCBzOCwgczksIHMxMF07XG4gICAgICAgICAgICAgICAgICAgIHM2ID0gczc7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM2O1xuICAgICAgICAgICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczY7XG4gICAgICAgICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczY7XG4gICAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM2O1xuICAgICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczYgPSBwZWckcGFyc2VfXygpO1xuICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlYm9vbGVhbl9leHByKCk7XG4gICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM1ID0gW3M1LCBzNiwgczddO1xuICAgICAgICAgICAgICAgIHM0ID0gczU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNDtcbiAgICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczQ7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNDtcbiAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM0ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfXygpO1xuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDEpIHtcbiAgICAgICAgICAgICAgICBzNiA9IHBlZyRjMzA7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMxKTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJGMzMihzMSwgczQpO1xuICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRwYXJzZXByaW1hcnlfZXhwcigpO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXByaW1hcnlfZXhwcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRwYXJzZXZhbHVlKCk7XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRwYXJzZWNvbnN0YW50KCk7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckcGFyc2VyZWdpc3RlcigpO1xuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRwYXJzZWlkZW50aWZpZXIoKTtcbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQwKSB7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGMyNjtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI3KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlYm9vbGVhbl9leHByKCk7XG4gICAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDEpIHtcbiAgICAgICAgICAgICAgICAgIHMzID0gcGVnJGMzMDtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMSk7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMzMyhzMik7XG4gICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWFzc2lnbmFibGUoKSB7XG4gICAgdmFyIHMwO1xuXG4gICAgczAgPSBwZWckcGFyc2VyZWdpc3RlcigpO1xuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckcGFyc2VpZGVudGlmaWVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlaWRlbnRpZmllcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChwZWckYzIyLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyMyk7IH1cbiAgICB9XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMyA9IFtdO1xuICAgICAgaWYgKHBlZyRjMjQudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyNSk7IH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgaWYgKHBlZyRjMjQudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjUpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IFtzMiwgczNdO1xuICAgICAgICBzMSA9IHMyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMxO1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgczEgPSBwZWckYzM0KHMxKTtcbiAgICB9XG4gICAgczAgPSBzMTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWNvbnN0YW50KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNikge1xuICAgICAgczEgPSBwZWckYzM1O1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM2KTsgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gW107XG4gICAgICBpZiAocGVnJGMyNC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMzID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI1KTsgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICBpZiAocGVnJGMyNC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgczMgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyNSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMzcoczIpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXJlZ2lzdGVyKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNjtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA2NCkge1xuICAgICAgczEgPSBwZWckYzM4O1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM5KTsgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gW107XG4gICAgICBpZiAocGVnJGMyNC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMzID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI1KTsgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICBpZiAocGVnJGMyNC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgczMgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyNSk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjNDAoczIpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKHBlZyRjNDEudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0Mik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAocGVnJGM0My50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgczMgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0NCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAocGVnJGM0NS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDYpOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKHBlZyRjNDcudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICBzNSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0OCk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAocGVnJGM0Ny50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICAgICAgczYgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0OCk7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzMiA9IFtzMiwgczMsIHM0LCBzNSwgczZdO1xuICAgICAgICAgICAgICAgIHMxID0gczI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczE7XG4gICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczE7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzQ5KHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNldmFsdWUoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNywgczg7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJGN1cnJQb3M7XG4gICAgczIgPSBbXTtcbiAgICBpZiAocGVnJGM0Ny50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDgpOyB9XG4gICAgfVxuICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIucHVzaChzMyk7XG4gICAgICBpZiAocGVnJGM0Ny50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMzID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ4KTsgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDYpIHtcbiAgICAgICAgczMgPSBwZWckYzUwO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTEpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczQgPSBbXTtcbiAgICAgICAgaWYgKHBlZyRjNDcudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDgpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgd2hpbGUgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgICAgIGlmIChwZWckYzQ3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgICAgczUgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDgpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNSA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIGlmIChwZWckYzUyLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgIHM2ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM2ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Myk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNyA9IFtdO1xuICAgICAgICAgICAgaWYgKHBlZyRjNDcudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICBzOCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzOCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0OCk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICB3aGlsZSAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNy5wdXNoKHM4KTtcbiAgICAgICAgICAgICAgICBpZiAocGVnJGM0Ny50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICAgICAgICBzOCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzOCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDgpOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczYgPSBbczYsIHM3XTtcbiAgICAgICAgICAgICAgczUgPSBzNjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNTtcbiAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM1ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIgPSBbczIsIHMzLCBzNCwgczVdO1xuICAgICAgICAgICAgczEgPSBzMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczE7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgIHMxID0gcGVnJGM1NChzMSk7XG4gICAgfVxuICAgIHMwID0gczE7XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBbXTtcbiAgICAgIGlmIChwZWckYzU1LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTYpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgaWYgKHBlZyRjNTUudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU2KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChwZWckYzU3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU4KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM1OShzMSk7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gW107XG4gICAgICAgIGlmIChwZWckYzQ3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ4KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgICBpZiAocGVnJGM0Ny50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ4KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKHBlZyRjNjAudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYxKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMyID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGM2MihzMSk7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZV9fKCkge1xuICAgIHZhciBzMCwgczE7XG5cbiAgICBzMCA9IFtdO1xuICAgIHMxID0gcGVnJHBhcnNld2hpdGVTcGFjZSgpO1xuICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckcGFyc2VsaW5lRW5kKCk7XG4gICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckcGFyc2Vjb21tZW50KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAucHVzaChzMSk7XG4gICAgICBzMSA9IHBlZyRwYXJzZXdoaXRlU3BhY2UoKTtcbiAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRwYXJzZWxpbmVFbmQoKTtcbiAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2Vjb21tZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2V3aGl0ZVNwYWNlKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChwZWckYzYzLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2NCk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VsaW5lRW5kKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChwZWckYzY1LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2Nik7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2Vjb21tZW50KCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGM2Nykge1xuICAgICAgczEgPSBwZWckYzY3O1xuICAgICAgcGVnJGN1cnJQb3MgKz0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzY4KTsgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gW107XG4gICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgczQgPSBwZWckY3VyclBvcztcbiAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMikgPT09IHBlZyRjNjkpIHtcbiAgICAgICAgczUgPSBwZWckYzY5O1xuICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNzApOyB9XG4gICAgICB9XG4gICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgIGlmIChzNSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzNCA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczQ7XG4gICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcGVnJGN1cnJQb3MpIHtcbiAgICAgICAgICBzNSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcxKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gW3M0LCBzNV07XG4gICAgICAgICAgczMgPSBzNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzNCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMikgPT09IHBlZyRjNjkpIHtcbiAgICAgICAgICBzNSA9IHBlZyRjNjk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcwKTsgfVxuICAgICAgICB9XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgICBpZiAoczUgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IHZvaWQgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHM0O1xuICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcGVnJGN1cnJQb3MpIHtcbiAgICAgICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3MSk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IFtzNCwgczVdO1xuICAgICAgICAgICAgczMgPSBzNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGM2OSkge1xuICAgICAgICAgIHMzID0gcGVnJGM2OTtcbiAgICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNzApOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBbczEsIHMyLCBzM107XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGM3Mikge1xuICAgICAgICBzMSA9IHBlZyRjNzI7XG4gICAgICAgIHBlZyRjdXJyUG9zICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3Myk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IFtdO1xuICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzNCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgICAgczUgPSBwZWckcGFyc2VsaW5lRW5kKCk7XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgICBpZiAoczUgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IHZvaWQgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHM0O1xuICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcGVnJGN1cnJQb3MpIHtcbiAgICAgICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3MSk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IFtzNCwgczVdO1xuICAgICAgICAgICAgczMgPSBzNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgczMgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBzNCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNlbGluZUVuZCgpO1xuICAgICAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgICAgIGlmIChzNSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQgPSB2b2lkIDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczQ7XG4gICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBlZyRjdXJyUG9zKSB7XG4gICAgICAgICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcxKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM0ID0gW3M0LCBzNV07XG4gICAgICAgICAgICAgIHMzID0gczQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxID0gW3MxLCBzMl07XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG5cbiAgICAgIHZhciBmbGF0dGVuID0gcmVxdWlyZSgnbG9kYXNoLWVzL2ZsYXR0ZW4nKS5kZWZhdWx0O1xuICAgICAgdmFyIG1hcCA9IHJlcXVpcmUoJ2xvZGFzaC1lcy9tYXAnKS5kZWZhdWx0O1xuICAgICAgdmFyIGVhY2ggPSByZXF1aXJlKCdsb2Rhc2gtZXMvZWFjaCcpLmRlZmF1bHQ7XG4gICAgICB2YXIgQXN0ID0gcmVxdWlyZSgnLi9Bc3QudHMnKTtcblxuICAgICAgZnVuY3Rpb24gbWFrZUJpbmFyeUV4cHIoaGVhZCwgdGFpbCkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBoZWFkO1xuICAgICAgICAgIHRhaWwuZm9yRWFjaChmdW5jdGlvbih0YWlsSXRlbSkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQXN0LkJpbmFyeUV4cHIodGFpbEl0ZW1bMV0sIHJlc3VsdCwgdGFpbEl0ZW1bM10pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZsYXR0ZW5DaGFycyh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gZmxhdHRlbih2YWwpLmpvaW4oXCJcIik7XG4gICAgICB9XG5cblxuICBwZWckcmVzdWx0ID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uKCk7XG5cbiAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiBwZWckcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICBwZWckZmFpbChwZWckZW5kRXhwZWN0YXRpb24oKSk7XG4gICAgfVxuXG4gICAgdGhyb3cgcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKFxuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCxcbiAgICAgIHBlZyRtYXhGYWlsUG9zIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KHBlZyRtYXhGYWlsUG9zKSA6IG51bGwsXG4gICAgICBwZWckbWF4RmFpbFBvcyA8IGlucHV0Lmxlbmd0aFxuICAgICAgICA/IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJG1heEZhaWxQb3MsIHBlZyRtYXhGYWlsUG9zICsgMSlcbiAgICAgICAgOiBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRtYXhGYWlsUG9zLCBwZWckbWF4RmFpbFBvcylcbiAgICApO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTeW50YXhFcnJvcjogcGVnJFN5bnRheEVycm9yLFxuICBwYXJzZTogICAgICAgcGVnJHBhcnNlXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZXhwci9FeHByR3JhbW1hci5wZWdqc1xuLy8gbW9kdWxlIGlkID0gMjczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IENvbXBvbmVudCwgeyBJQ29udGFpbmVyIH0gZnJvbSBcIi4uL0NvbXBvbmVudFwiO1xuaW1wb3J0IElNYWluIGZyb20gXCIuLi9JTWFpblwiO1xuaW1wb3J0IHsgQmxlbmRNb2RlIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgQnVmZmVyU2F2ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIElCdWZmZXJTYXZlT3B0cyB7XG4gICAgLyoqXG4gICAgICogQWN0aW9uIHRvIGJlIHRha2VuIHNlZSBbW0J1ZmZlclNhdmVBY3Rpb25dXVxuICAgICAqL1xuICAgIGFjdGlvbjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEEgdW5pcXVlIG5hbWUgZm9yIHRoZSBidWZmZXJcbiAgICAgKi9cbiAgICBidWZmZXJJZDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEJsZW5kTW9kZSB3aGVuIHJlc3RvcmluZ1xuICAgICAqL1xuICAgIGJsZW5kTW9kZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEFjdGlvbnMgZm9yIEJ1ZmZlclNhdmVcbiAqL1xuZW51bSBCdWZmZXJTYXZlQWN0aW9uIHtcbiAgICBTQVZFID0gMCxcbiAgICBSRVNUT1JFLFxuICAgIFNBVkVSRVNUT1JFLFxuICAgIFJFU1RPUkVTQVZFLFxufVxuXG4vKipcbiAqIEEgY29tcG9uZW50IHRoYXQgc2F2ZXMgb3IgcmVzdG9yZXMgYSBjb3B5IG9mIHRoZSBjdXJyZW50XG4gKiBmcmFtZSBidWZmZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnVmZmVyU2F2ZSBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgcHVibGljIHN0YXRpYyBjb21wb25lbnROYW1lOiBzdHJpbmcgPSBcIkJ1ZmZlclNhdmVcIjtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudFRhZzogc3RyaW5nID0gXCJtaXNjXCI7XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBvcHRVcGRhdGVIYW5kbGVycyA9IHtcbiAgICAgICAgYWN0aW9uOiBcInVwZGF0ZUFjdGlvblwiLFxuICAgICAgICBibGVuZE1vZGU6IFwidXBkYXRlQmxlbmRNb2RlXCIsXG4gICAgICAgIGJ1ZmZlcklkOiBcInVwZGF0ZUJ1ZmZlclwiLFxuICAgIH07XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkZWZhdWx0T3B0aW9uczogSUJ1ZmZlclNhdmVPcHRzID0ge1xuICAgICAgICBhY3Rpb246IFwiU0FWRVwiLFxuICAgICAgICBibGVuZE1vZGU6IFwiUkVQTEFDRVwiLFxuICAgICAgICBidWZmZXJJZDogXCJidWZmZXIxXCIsXG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBvcHRzOiBJQnVmZmVyU2F2ZU9wdHM7XG4gICAgcHJpdmF0ZSBhY3Rpb246IEJ1ZmZlclNhdmVBY3Rpb247XG4gICAgcHJpdmF0ZSBuZXh0QWN0aW9uOiBCdWZmZXJTYXZlQWN0aW9uO1xuICAgIHByaXZhdGUgYmxlbmRNb2RlOiBCbGVuZE1vZGU7XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluOiBJTWFpbiwgcGFyZW50OiBJQ29udGFpbmVyLCBvcHRzOiBhbnkpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgcGFyZW50LCBvcHRzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaW5pdCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVBY3Rpb24oKTtcbiAgICAgICAgdGhpcy51cGRhdGVCbGVuZE1vZGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVCdWZmZXIoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZHJhdygpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRBY3Rpb247XG4gICAgICAgIGlmICh0aGlzLmFjdGlvbiA9PT0gQnVmZmVyU2F2ZUFjdGlvbi5TQVZFUkVTVE9SRSB8fFxuICAgICAgICAgICB0aGlzLmFjdGlvbiA9PT0gQnVmZmVyU2F2ZUFjdGlvbi5SRVNUT1JFU0FWRSkge1xuICAgICAgICAgICAgY3VycmVudEFjdGlvbiA9IHRoaXMubmV4dEFjdGlvbjtcbiAgICAgICAgICAgIC8vIHRvZ2dsZSBuZXh0IGFjdGlvblxuICAgICAgICAgICAgdGhpcy5uZXh0QWN0aW9uID1cbiAgICAgICAgICAgICAgICAodGhpcy5uZXh0QWN0aW9uID09PSBCdWZmZXJTYXZlQWN0aW9uLlNBVkUpID8gQnVmZmVyU2F2ZUFjdGlvbi5SRVNUT1JFIDogQnVmZmVyU2F2ZUFjdGlvbi5TQVZFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudEFjdGlvbiA9IHRoaXMuYWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVtcFRTTSA9IHRoaXMubWFpbi5nZXRUZW1wVFNNKCk7XG4gICAgICAgIHN3aXRjaCAoY3VycmVudEFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBCdWZmZXJTYXZlQWN0aW9uLlNBVkU6XG4gICAgICAgICAgICAgICAgdGVtcFRTTS5zZXRBc1JlbmRlclRhcmdldCh0aGlzLm9wdHMuYnVmZmVySWQpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFpbi5nZXRDb3BpZXIoKS5ydW4obnVsbCwgeyBzcmNUZXh0dXJlOiB0aGlzLnBhcmVudC5nZXRUU00oKS5nZXRDdXJyZW50VGV4dHVyZSgpIH0pO1xuICAgICAgICAgICAgICAgIHRlbXBUU00udW5zZXRBc1JlbmRlclRhcmdldCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWZmZXJTYXZlQWN0aW9uLlJFU1RPUkU6XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLmdldENvcGllcigpLnJ1bihcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuZ2V0VFNNKCksIHsgc3JjVGV4dHVyZTogdGVtcFRTTS5nZXRUZXh0dXJlKHRoaXMub3B0cy5idWZmZXJJZCkgfSwgdGhpcy5ibGVuZE1vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tYWluLmdldFRlbXBUU00oKS5yZW1vdmVUZXh0dXJlKHRoaXMub3B0cy5idWZmZXJJZCk7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZUFjdGlvbigpIHtcbiAgICAgICAgdGhpcy5hY3Rpb24gPSBCdWZmZXJTYXZlQWN0aW9uW3RoaXMub3B0cy5hY3Rpb25dO1xuICAgICAgICBpZiAodGhpcy5hY3Rpb24gPT09IEJ1ZmZlclNhdmVBY3Rpb24uU0FWRVJFU1RPUkUpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dEFjdGlvbiA9IEJ1ZmZlclNhdmVBY3Rpb24uU0FWRTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFjdGlvbiA9PT0gQnVmZmVyU2F2ZUFjdGlvbi5SRVNUT1JFU0FWRSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0QWN0aW9uID0gQnVmZmVyU2F2ZUFjdGlvbi5SRVNUT1JFO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZUJ1ZmZlcih2YWx1ZT8sIGtleT8sIG9sZFZhbHVlPykge1xuICAgICAgICAvLyBidWZmZXIgbmFtZXMgaW4gVGV4dHVyZVNldE1hbmFnZXIgaGF2ZSB0byBiZSBzdHJpbmdcbiAgICAgICAgLy8gY29udmVydGluZyB0byBzdHJpbmcgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICB0aGlzLm9wdHMuYnVmZmVySWQgPSB0aGlzLm9wdHMuYnVmZmVySWQgKyBcIlwiO1xuICAgICAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5nZXRUZW1wVFNNKCkucmVtb3ZlVGV4dHVyZShvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluLmdldFRlbXBUU00oKS5hZGRUZXh0dXJlKHRoaXMub3B0cy5idWZmZXJJZCk7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZUJsZW5kTW9kZSgpIHtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSBCbGVuZE1vZGVbdGhpcy5vcHRzLmJsZW5kTW9kZV07XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21pc2MvQnVmZmVyU2F2ZS50cyIsImltcG9ydCBDb21wb25lbnQsIHsgSUNvbnRhaW5lciB9IGZyb20gXCIuLi9Db21wb25lbnRcIjtcbmltcG9ydCBDb2RlSW5zdGFuY2UgZnJvbSBcIi4uL2V4cHIvQ29kZUluc3RhbmNlXCI7XG5pbXBvcnQgY29tcGlsZUV4cHIgZnJvbSBcIi4uL2V4cHIvY29tcGlsZUV4cHJcIjtcbmltcG9ydCBJTWFpbiBmcm9tIFwiLi4vSU1haW5cIjtcblxuZXhwb3J0IGludGVyZmFjZSBJR2xvYmFsVmFyT3B0cyB7XG4gICAgY29kZToge1xuICAgICAgICBpbml0OiBzdHJpbmcsXG4gICAgICAgIG9uQmVhdDogc3RyaW5nLFxuICAgICAgICBwZXJGcmFtZTogc3RyaW5nLFxuICAgIH07XG59XG5cbmludGVyZmFjZSBJR2xvYmFsVmFyQ29kZUluc3RhbmNlIGV4dGVuZHMgQ29kZUluc3RhbmNlIHtcbiAgICBiOiBudW1iZXI7XG4gICAgaW5pdDogKCkgPT4gdm9pZDtcbiAgICBwZXJGcmFtZTogKCkgPT4gdm9pZDtcbiAgICBvbkJlYXQ6ICgpID0+IHZvaWQ7XG59XG5cbi8vIEEgY29tcG9uZW50IHRoYXQgc2ltcGx5IHJ1bnMgc29tZSBhdnMgZXhwcmVzc2lvbnMuXG4vLyBVc2VmdWwgdG8gbWFpbnRhaW4gZ2xvYmFsIHN0YXRlXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHbG9iYWxWYXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHB1YmxpYyBzdGF0aWMgY29tcG9uZW50TmFtZTogc3RyaW5nID0gXCJHbG9iYWxWYXJcIjtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudFRhZzogc3RyaW5nID0gXCJtaXNjXCI7XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBvcHRVcGRhdGVIYW5kbGVycyA9IHtcbiAgICAgICAgY29kZTogXCJ1cGRhdGVDb2RlXCIsXG4gICAgfTtcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlZmF1bHRPcHRpb25zOiBJR2xvYmFsVmFyT3B0cyA9IHtcbiAgICAgICAgY29kZToge1xuICAgICAgICAgICAgaW5pdDogXCJcIixcbiAgICAgICAgICAgIG9uQmVhdDogXCJcIixcbiAgICAgICAgICAgIHBlckZyYW1lOiBcIlwiLFxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgb3B0czogSUdsb2JhbFZhck9wdHM7XG4gICAgcHJpdmF0ZSBjb2RlOiBJR2xvYmFsVmFyQ29kZUluc3RhbmNlO1xuICAgIHByaXZhdGUgaW5pdGVkOiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IobWFpbjogSU1haW4sIHBhcmVudDogSUNvbnRhaW5lciwgb3B0czogYW55KSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHBhcmVudCwgb3B0cyk7XG4gICAgfVxuXG4gICAgcHVibGljIGluaXQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29kZSgpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubWFpbiwgXCJyZXNpemVcIiwgKCkgPT4gdGhpcy5oYW5kbGVSZXNpemUoKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGRyYXcoKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLmNvZGU7XG4gICAgICAgIGNvZGUuYiA9IHRoaXMubWFpbi5nZXRBbmFseXNlcigpLmlzQmVhdCgpID8gMSA6IDA7XG5cbiAgICAgICAgaWYgKCF0aGlzLmluaXRlZCkge1xuICAgICAgICAgICAgY29kZS5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLmluaXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYWluLmdldEFuYWx5c2VyKCkuaXNCZWF0KCkpIHtcbiAgICAgICAgICAgIGNvZGUub25CZWF0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlLnBlckZyYW1lKCk7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZUNvZGUoKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvbXBpbGVFeHByKHRoaXMub3B0cy5jb2RlLCBbXCJpbml0XCIsIFwib25CZWF0XCIsIFwicGVyRnJhbWVcIl0pLmNvZGVJbnN0IGFzIElHbG9iYWxWYXJDb2RlSW5zdGFuY2U7XG4gICAgICAgIHRoaXMuY29kZS5zZXR1cCh0aGlzLm1haW4pO1xuICAgICAgICB0aGlzLmluaXRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHB1YmxpYyBoYW5kbGVSZXNpemUoKSB7XG4gICAgICAgIHRoaXMuY29kZS51cGRhdGVEaW1WYXJzKHRoaXMubWFpbi5nZXRSY3R4KCkuZ2V0R2woKSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21pc2MvR2xvYmFsVmFyLnRzIiwiaW1wb3J0IENvbXBvbmVudCwge0lDb250YWluZXJ9IGZyb20gXCIuLi9Db21wb25lbnRcIjtcbmltcG9ydCBJTWFpbiBmcm9tIFwiLi4vSU1haW5cIjtcbmltcG9ydCB7QmxlbmRNb2RlLCBDb2xvciwgcGFyc2VDb2xvck5vcm19IGZyb20gXCIuLi91dGlsc1wiO1xuaW1wb3J0IENsZWFyU2NyZWVuUHJvZ3JhbSBmcm9tIFwiLi4vd2ViZ2wvQ2xlYXJTY3JlZW5Qcm9ncmFtXCI7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tIFwiLi4vd2ViZ2wvU2hhZGVyUHJvZ3JhbVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIElDbGVhclNjcmVlbk9wdHMge1xuICAgIGJlYXRDb3VudDogbnVtYmVyO1xuICAgIGNvbG9yOiBzdHJpbmc7XG4gICAgYmxlbmRNb2RlOiBzdHJpbmc7XG59XG5cbi8vIEEgY29tcG9uZW50IHRoYXQgY2xlYXJzIHRoZSBzY3JlZW5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENsZWFyU2NyZWVuIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudE5hbWUgPSBcIkNsZWFyU2NyZWVuXCI7XG4gICAgcHVibGljIHN0YXRpYyBjb21wb25lbnRUYWcgPSBcInJlbmRlclwiO1xuICAgIHByb3RlY3RlZCBzdGF0aWMgZGVmYXVsdE9wdGlvbnM6IElDbGVhclNjcmVlbk9wdHMgPSB7XG4gICAgICAgIGJlYXRDb3VudDogMCxcbiAgICAgICAgYmxlbmRNb2RlOiBcIlJFUExBQ0VcIixcbiAgICAgICAgY29sb3I6IFwiIzAwMDAwMFwiLFxuICAgIH07XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBvcHRVcGRhdGVIYW5kbGVycyA9IHtcbiAgICAgICAgYmxlbmRNb2RlOiBcInVwZGF0ZVByb2dyYW1cIixcbiAgICAgICAgY29sb3I6IFwidXBkYXRlQ29sb3JcIixcbiAgICB9O1xuICAgIHByb3RlY3RlZCBvcHRzOiBJQ2xlYXJTY3JlZW5PcHRzO1xuXG4gICAgcHJpdmF0ZSBwcmV2QmVhdDogYm9vbGVhbjtcbiAgICBwcml2YXRlIGJlYXRDb3VudDogbnVtYmVyO1xuICAgIHByaXZhdGUgcHJvZ3JhbTogQ2xlYXJTY3JlZW5Qcm9ncmFtO1xuICAgIHByaXZhdGUgY29sb3I6IENvbG9yO1xuXG4gICAgY29uc3RydWN0b3IobWFpbjogSU1haW4sIHBhcmVudDogSUNvbnRhaW5lciwgb3B0czogYW55KSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHBhcmVudCwgb3B0cyk7XG4gICAgfVxuXG4gICAgcHVibGljIGluaXQoKSB7XG4gICAgICAgIHRoaXMucHJldkJlYXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5iZWF0Q291bnQgPSAwO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQ29sb3IoKTtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9ncmFtKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGRyYXcoKSB7XG4gICAgICAgIGxldCBjbGVhciA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmJlYXRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgY2xlYXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMubWFpbi5nZXRBbmFseXNlcigpLmlzQmVhdCgpICYmICF0aGlzLnByZXZCZWF0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iZWF0Q291bnQrKztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iZWF0Q291bnQgPj0gdGhpcy5vcHRzLmJlYXRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmVhdENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXZCZWF0ID0gdGhpcy5tYWluLmdldEFuYWx5c2VyKCkuaXNCZWF0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xlYXIpIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS5ydW4odGhpcy5wYXJlbnQuZ2V0VFNNKCksIHtjb2xvcjogdGhpcy5jb2xvcn0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlQ29sb3IoKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBwYXJzZUNvbG9yTm9ybSh0aGlzLm9wdHMuY29sb3IpO1xuICAgIH1cblxuICAgIHB1YmxpYyB1cGRhdGVQcm9ncmFtKCkge1xuICAgICAgICBjb25zdCBibGVuZE1vZGUgPSBCbGVuZE1vZGVbdGhpcy5vcHRzLmJsZW5kTW9kZV07XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgQ2xlYXJTY3JlZW5Qcm9ncmFtKHRoaXMubWFpbi5nZXRSY3R4KCksIGJsZW5kTW9kZSk7XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyL0NsZWFyU2NyZWVuLnRzIiwiaW1wb3J0IGJhc2VJbmRleE9mIGZyb20gJy4vX2Jhc2VJbmRleE9mLmpzJztcbmltcG9ydCB0b0ludGVnZXIgZnJvbSAnLi90b0ludGVnZXIuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzIHRoZVxuICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4T2Y7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaW5kZXhPZi5qc1xuLy8gbW9kdWxlIGlkID0gMjc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IENvbXBvbmVudCwge0lDb250YWluZXJ9IGZyb20gXCIuLi9Db21wb25lbnRcIjtcbmltcG9ydCBJTWFpbiBmcm9tIFwiLi4vSU1haW5cIjtcbmltcG9ydCB7IEJsZW5kTW9kZSwgQ29sb3IsIHBhcnNlQ29sb3JOb3JtLCBXZWJHTFZhclR5cGUgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCBCdWZmZXIgZnJvbSBcIi4uL3dlYmdsL0J1ZmZlclwiO1xuaW1wb3J0IHsgY2lyY2xlR2VvbWV0cnkgfSBmcm9tIFwiLi4vd2ViZ2wvZ2VvbWV0cmllc1wiO1xuaW1wb3J0IFJlbmRlcmluZ0NvbnRleHQgZnJvbSBcIi4uL3dlYmdsL1JlbmRlcmluZ0NvbnRleHRcIjtcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gXCIuLi93ZWJnbC9TaGFkZXJQcm9ncmFtXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU1vdmluZ1BhcnRpY2xlT3B0cyB7XG4gICAgY29sb3I6IHN0cmluZztcbiAgICBkaXN0YW5jZTogbnVtYmVyO1xuICAgIHBhcnRpY2xlU2l6ZTogbnVtYmVyO1xuICAgIG9uQmVhdFNpemVDaGFuZ2U6IGJvb2xlYW47XG4gICAgb25CZWF0UGFydGljbGVTaXplOiBudW1iZXI7XG4gICAgYmxlbmRNb2RlOiBzdHJpbmc7XG59XG5cbi8vIEEgcGFydGljbGUgdGhhdCBtb3ZlcyBhcm91bmQgZGVwZW5kaW5nIG9uIGJlYXQgY2hhbmdlc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW92aW5nUGFydGljbGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHB1YmxpYyBzdGF0aWMgY29tcG9uZW50TmFtZTogc3RyaW5nID0gXCJNb3ZpbmdQYXJ0aWNsZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgY29tcG9uZW50VGFnOiBzdHJpbmcgPSBcInJlbmRlclwiO1xuICAgIHByb3RlY3RlZCBzdGF0aWMgb3B0VXBkYXRlSGFuZGxlcnMgPSB7XG4gICAgICAgIGJsZW5kTW9kZTogXCJ1cGRhdGVCbGVuZE1vZGVcIixcbiAgICAgICAgY29sb3I6IFwidXBkYXRlQ29sb3JcIixcbiAgICB9O1xuICAgIHByb3RlY3RlZCBzdGF0aWMgZGVmYXVsdE9wdGlvbnM6IElNb3ZpbmdQYXJ0aWNsZU9wdHMgPSB7XG4gICAgICAgIGJsZW5kTW9kZTogXCJSRVBMQUNFXCIsXG4gICAgICAgIGNvbG9yOiBcIiNGRkZGRkZcIixcbiAgICAgICAgZGlzdGFuY2U6IDAuNyxcbiAgICAgICAgb25CZWF0UGFydGljbGVTaXplOiAxMCxcbiAgICAgICAgb25CZWF0U2l6ZUNoYW5nZTogZmFsc2UsXG4gICAgICAgIHBhcnRpY2xlU2l6ZTogMTAsXG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBvcHRzOiBJTW92aW5nUGFydGljbGVPcHRzO1xuICAgIHByaXZhdGUgY2VudGVyWDogbnVtYmVyO1xuICAgIHByaXZhdGUgY2VudGVyWTogbnVtYmVyO1xuICAgIHByaXZhdGUgdmVsb2NpdHlYOiBudW1iZXI7XG4gICAgcHJpdmF0ZSB2ZWxvY2l0eVk6IG51bWJlcjtcbiAgICBwcml2YXRlIHBvc1g6IG51bWJlcjtcbiAgICBwcml2YXRlIHBvc1k6IG51bWJlcjtcbiAgICBwcml2YXRlIHByb2dyYW06IFNoYWRlclByb2dyYW07XG4gICAgcHJpdmF0ZSBibGVuZE1vZGU6IEJsZW5kTW9kZTtcbiAgICBwcml2YXRlIGNvbG9yOiBDb2xvcjtcblxuICAgIGNvbnN0cnVjdG9yKG1haW46IElNYWluLCBwYXJlbnQ6IElDb250YWluZXIsIG9wdHM6IGFueSkge1xuICAgICAgICBzdXBlcihtYWluLCBwYXJlbnQsIG9wdHMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbml0KCkge1xuICAgICAgICB0aGlzLmNlbnRlclggPSAwO1xuICAgICAgICB0aGlzLmNlbnRlclkgPSAwO1xuICAgICAgICB0aGlzLnZlbG9jaXR5WCA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHlZID0gMDtcbiAgICAgICAgdGhpcy5wb3NYID0gMDtcbiAgICAgICAgdGhpcy5wb3NZID0gMDtcblxuICAgICAgICB0aGlzLnVwZGF0ZUJsZW5kTW9kZSgpO1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMubWFpbi5nZXRSY3R4KCkuZ2V0R2woKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbmV3IFNoYWRlclByb2dyYW0odGhpcy5tYWluLmdldFJjdHgoKSwge1xuICAgICAgICAgICAgYmluZGluZ3M6IHtcbiAgICAgICAgICAgICAgICBhdHRyaWJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogeyBuYW1lOiBcImFfcG9pbnRzXCIsIGRyYXdNb2RlOiBnbC5UUklBTkdMRV9GQU4gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAgICB7IG5hbWU6IFwidV9jb2xvclwiLCB2YWx1ZVR5cGU6IFdlYkdMVmFyVHlwZS5fM0ZWIH0sXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IG5hbWU6IFwidV9wb3NpdGlvblwiLCB2YWx1ZVR5cGU6IFdlYkdMVmFyVHlwZS5fMkZWIH0sXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiAgICB7IG5hbWU6IFwidV9zY2FsZVwiLCB2YWx1ZVR5cGU6IFdlYkdMVmFyVHlwZS5fMkZWIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb3B5T25Td2FwOiB0cnVlLFxuICAgICAgICAgICAgZHluYW1pY0JsZW5kOiB0cnVlLFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGBcbiAgICAgICAgICAgICAgICB1bmlmb3JtIHZlYzMgdV9jb2xvcjtcbiAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgc2V0RnJhZ0NvbG9yKHZlYzQodV9jb2xvciwgMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGAsXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGBcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhX3BvaW50O1xuICAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjMiB1X3Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjMiB1X3NjYWxlO1xuICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICAgICBzZXRQb3NpdGlvbigoYV9wb2ludCp1X3NjYWxlKSt1X3Bvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVDb2xvcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkcmF3KCkge1xuICAgICAgICBpZiAodGhpcy5tYWluLmdldEFuYWx5c2VyKCkuaXNCZWF0KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2VudGVyWCA9IChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogMC4zO1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJZID0gKE1hdGgucmFuZG9tKCkgKiAyIC0gMSkgKiAwLjM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZlbG9jaXR5WCAtPSAwLjAwNCAqICh0aGlzLnBvc1ggLSB0aGlzLmNlbnRlclgpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5WSAtPSAwLjAwNCAqICh0aGlzLnBvc1kgLSB0aGlzLmNlbnRlclkpO1xuXG4gICAgICAgIHRoaXMucG9zWCArPSB0aGlzLnZlbG9jaXR5WDtcbiAgICAgICAgdGhpcy5wb3NZICs9IHRoaXMudmVsb2NpdHlZO1xuXG4gICAgICAgIHRoaXMudmVsb2NpdHlYICo9IDAuOTkxO1xuICAgICAgICB0aGlzLnZlbG9jaXR5WSAqPSAwLjk5MTtcblxuICAgICAgICBjb25zdCB4ID0gdGhpcy5wb3NYICogdGhpcy5vcHRzLmRpc3RhbmNlO1xuICAgICAgICBjb25zdCB5ID0gdGhpcy5wb3NZICogdGhpcy5vcHRzLmRpc3RhbmNlO1xuXG4gICAgICAgIGxldCBzY2FsZVg7XG4gICAgICAgIGxldCBzY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMub25CZWF0U2l6ZUNoYW5nZSAmJiB0aGlzLm1haW4uZ2V0QW5hbHlzZXIoKS5pc0JlYXQoKSkge1xuICAgICAgICAgICAgc2NhbGVYID0gdGhpcy5vcHRzLm9uQmVhdFBhcnRpY2xlU2l6ZTtcbiAgICAgICAgICAgIHNjYWxlWSA9IHRoaXMub3B0cy5vbkJlYXRQYXJ0aWNsZVNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FsZVggPSB0aGlzLm9wdHMucGFydGljbGVTaXplO1xuICAgICAgICAgICAgc2NhbGVZID0gdGhpcy5vcHRzLnBhcnRpY2xlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnbCA9IHRoaXMubWFpbi5nZXRSY3R4KCkuZ2V0R2woKTtcbiAgICAgICAgc2NhbGVYID0gMiAqIHNjYWxlWCAvIGdsLmRyYXdpbmdCdWZmZXJXaWR0aDtcbiAgICAgICAgc2NhbGVZID0gMiAqIHNjYWxlWSAvIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5wcm9ncmFtLnJ1bihcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmdldFRTTSgpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgICAgICAgIHBvaW50czogY2lyY2xlR2VvbWV0cnkodGhpcy5tYWluLmdldFJjdHgoKSksXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFt4LCB5XSxcbiAgICAgICAgICAgICAgICBzY2FsZTogW3NjYWxlWCwgc2NhbGVZXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlQmxlbmRNb2RlKCkge1xuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IEJsZW5kTW9kZVt0aGlzLm9wdHMuYmxlbmRNb2RlXTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlQ29sb3IoKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBwYXJzZUNvbG9yTm9ybSh0aGlzLm9wdHMuY29sb3IpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucHJvZ3JhbS5kZXN0cm95KCk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlci9Nb3ZpbmdQYXJ0aWNsZS50cyIsImltcG9ydCBDb21wb25lbnQsIHtJQ29udGFpbmVyfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG5pbXBvcnQgSU1haW4gZnJvbSBcIi4uL0lNYWluXCI7XG5pbXBvcnQgeyBXZWJHTFZhclR5cGUgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCBCdWZmZXIgZnJvbSBcIi4uL3dlYmdsL0J1ZmZlclwiO1xuaW1wb3J0IHsgc3F1YXJlR2VvbWV0cnkgfSBmcm9tIFwiLi4vd2ViZ2wvZ2VvbWV0cmllc1wiO1xuaW1wb3J0IFJlbmRlcmluZ0NvbnRleHQgZnJvbSBcIi4uL3dlYmdsL1JlbmRlcmluZ0NvbnRleHRcIjtcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gXCIuLi93ZWJnbC9TaGFkZXJQcm9ncmFtXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVBpY3R1cmVPcHRzIHtcbiAgICBzcmM6IHN0cmluZztcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xufVxuXG4vLyBBIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgYW4gaW1hZ2Ugb250byB0aGUgc2NyZWVuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaWN0dXJlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudE5hbWU6IHN0cmluZyA9IFwiUGljdHVyZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgY29tcG9uZW50VGFnOiBzdHJpbmcgPSBcInJlbmRlclwiO1xuICAgIHByb3RlY3RlZCBzdGF0aWMgb3B0VXBkYXRlSGFuZGxlcnMgPSB7XG4gICAgICAgIHNyYzogXCJ1cGRhdGVJbWFnZVwiLFxuICAgIH07XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkZWZhdWx0T3B0aW9uczogSVBpY3R1cmVPcHRzID0ge1xuICAgICAgICBzcmM6IFwiYXZzcmVzX3RleGVyX2NpcmNsZV9lZGdlb25seV8xOXgxOS5ibXBcIixcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIG9wdHM6IElQaWN0dXJlT3B0cztcbiAgICBwcml2YXRlIHByb2dyYW06IFNoYWRlclByb2dyYW07XG4gICAgcHJpdmF0ZSB0ZXh0dXJlOiBXZWJHTFRleHR1cmU7XG4gICAgcHJpdmF0ZSB3aWR0aDogbnVtYmVyO1xuICAgIHByaXZhdGUgaGVpZ2h0OiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluOiBJTWFpbiwgcGFyZW50OiBJQ29udGFpbmVyLCBvcHRzOiBhbnkpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgcGFyZW50LCBvcHRzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaW5pdCgpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLm1haW4uZ2V0UmN0eCgpLmdldEdsKCk7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKHRoaXMubWFpbi5nZXRSY3R4KCksIHtcbiAgICAgICAgICAgIGJpbmRpbmdzOiB7XG4gICAgICAgICAgICAgICAgYXR0cmliczoge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHsgbmFtZTogXCJhX3RleFZlcnRleFwiLCBkcmF3TW9kZTogZ2wuVFJJQU5HTEVTIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZTogICAgeyBuYW1lOiBcInVfaW1hZ2VcIiwgdmFsdWVUeXBlOiBXZWJHTFZhclR5cGUuVEVYVFVSRTJEIH0sXG4gICAgICAgICAgICAgICAgICAgIGltYWdlUmVzOiB7IG5hbWU6IFwidV90ZXhSZXNcIiwgdmFsdWVUeXBlOiBXZWJHTFZhclR5cGUuXzJGViB9LFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyBuYW1lOiBcInVfcG9zXCIsIHZhbHVlVHlwZTogV2ViR0xWYXJUeXBlLl8yRlYgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvcHlPblN3YXA6IHRydWUsXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogYFxuICAgICAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XG4gICAgICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgIHNldEZyYWdDb2xvcih0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGAsXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGBcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhX3RleFZlcnRleDtcbiAgICAgICAgICAgICAgICB1bmlmb3JtIHZlYzIgdV9wb3M7XG4gICAgICAgICAgICAgICAgdW5pZm9ybSB2ZWMyIHVfdGV4UmVzO1xuICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xuXG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgIHZfdGV4Q29vcmQgPSBhX3RleFZlcnRleDtcbiAgICAgICAgICAgICAgICAgICBzZXRQb3NpdGlvbihhX3RleFZlcnRleCoodV90ZXhSZXMvdV9yZXNvbHV0aW9uKSp2ZWMyKDIsLTIpK3VfcG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVJbWFnZSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkcmF3KCkge1xuICAgICAgICB0aGlzLnByb2dyYW0ucnVuKFxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZ2V0VFNNKCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW1hZ2U6IHRoaXMudGV4dHVyZSxcbiAgICAgICAgICAgICAgICBpbWFnZVJlczogW3RoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSxcbiAgICAgICAgICAgICAgICBwb2ludHM6IHNxdWFyZUdlb21ldHJ5KHRoaXMubWFpbi5nZXRSY3R4KCksIHRydWUpLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbdGhpcy5vcHRzLngsIC10aGlzLm9wdHMueV0sXG4gICAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucHJvZ3JhbS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubWFpbi5nZXRSY3R4KCkuZ2V0R2woKS5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZUltYWdlKCkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMubWFpbi5nZXRSY3R4KCkuZ2V0R2woKTtcbiAgICAgICAgdGhpcy5tYWluLmdldFJzcmNNYW4oKS5nZXRJbWFnZShcbiAgICAgICAgICAgIHRoaXMub3B0cy5zcmMsXG4gICAgICAgICAgICAoaW1hZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyL1BpY3R1cmUudHMiLCJpbXBvcnQgZWFjaCBmcm9tIFwibG9kYXNoLWVzL2VhY2hcIjtcbmltcG9ydCBtYXAgZnJvbSBcImxvZGFzaC1lcy9tYXBcIjtcbmltcG9ydCBDb21wb25lbnQsIHtJQ29udGFpbmVyfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG5pbXBvcnQgQ29kZUluc3RhbmNlIGZyb20gXCIuLi9leHByL0NvZGVJbnN0YW5jZVwiO1xuaW1wb3J0IGNvbXBpbGVFeHByLCB7IElDb21waWxlUmVzdWx0IH0gZnJvbSBcIi4uL2V4cHIvY29tcGlsZUV4cHJcIjtcbmltcG9ydCBJTWFpbiBmcm9tIFwiLi4vSU1haW5cIjtcbmltcG9ydCB7IEJsZW5kTW9kZSwgQ2hhbm5lbHMsIENvbG9yLCBwYXJzZUNvbG9yTm9ybSwgU291cmNlLCBXZWJHTFZhclR5cGUgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCBCdWZmZXIgZnJvbSBcIi4uL3dlYmdsL0J1ZmZlclwiO1xuaW1wb3J0IFJlbmRlcmluZ0NvbnRleHQgZnJvbSBcIi4uL3dlYmdsL1JlbmRlcmluZ0NvbnRleHRcIjtcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gXCIuLi93ZWJnbC9TaGFkZXJQcm9ncmFtXCI7XG5cbi8qKlxuICogRHJhd2luZyBtb2RlcyBmb3IgdGhlIFtbU3VwZXJTY29wZV1dIGNvbXBvbmVudFxuICovXG5lbnVtIFN1cGVyU2NvcGVEcmF3TW9kZSB7XG4gICAgTElORVMgPSAxLFxuICAgIERPVFMsXG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgdGhlIFtbU3VwZXJTY29wZV1dIGNvbXBvbmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIElTdXBlclNjb3BlT3B0cyB7XG4gICAgLyoqXG4gICAgICogRUVMIGNvZGUgdG8gY29udHJvbCBkcmF3aW5nIG9mIHNjb3BlXG4gICAgICpcbiAgICAgKiBFRUwgVmFyaWFibGVzOlxuICAgICAqICsgYHJlZDogYChSZWFkV3JpdGUsIHBlclBvaW50KWAgU2V0IHJlZCBvZiBjb2xvciAoMC0xKVxuICAgICAqICsgYGdyZWVuYDogYChSZWFkV3JpdGUsIHBlclBvaW50KWAgU2V0IGdyZWVuIG9mIGNvbG9yICgwLTEpXG4gICAgICogKyBgYmx1ZWA6IGAoUmVhZFdyaXRlLCBwZXJQb2ludClgIFNldCBibHVlIG9mIGNvbG9yICgwLTEpXG4gICAgICogKyBgbmA6IGAoUmVhZFdyaXRlLCBpbml0L3BlckZyYW1lL29uQmVhdClgIFNldCB0aGUgbnVtYmVyIG9mIHBvaW50cyB0byBiZSBkcmF3blxuICAgICAqICsgYGJgOiBgKFJlYWQsIG9uQmVhdC9wZXJGcmFtZS9wZXJQaXhlbClgIC0gMC8xIHZhbHVlIGluZGljYXRlIGEgYmVhdFxuICAgICAqICsgYGlgOiBgKFJlYWQsIHBlclBpeGVsKWAgLSAoMC0xKSB2YWx1ZSBpbmRpY2F0aW5nIGluZGV4IG9mIGN1cnJlbnQgcG9pbnRcbiAgICAgKiArIGB2YDogYChSZWFkLCBwZXJQaXhlbClgIC0gKDAtMSkgdmFsdWUgaW5kaWNhdGluZyB2YWx1ZSBvZiBzY29wZSBhdCBjdXJyZW50IHBvaW50XG4gICAgICogKyBgeGA6IGAoV3JpdGUsIHBlclBpeGVsKWAgLSBzZXQgdGhpcyB0byBzZXQgcG9zaXRpb24gb2YgY3VycmVudCBwb2ludFxuICAgICAqICsgYHlgOiBgKFdyaXRlLCBwZXJQaXhlbClgIC0gc2V0IHRoaXMgdG8gc2V0IHBvc2l0aW9uIG9mIGN1cnJlbnQgcG9pbnRcbiAgICAgKi9cbiAgICBjb2RlOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFRUwgdGhhdCdsbCBiZSBydW4gb24gaW5pdFxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICogRUVMIGNvZGUgdGhhdCdzIHJ1biBwZXIgZnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIHBlckZyYW1lOiBzdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFRUwgY29kZSB0aGF0J3MgcnVuIG9uIGJlYXRcbiAgICAgICAgICovXG4gICAgICAgIG9uQmVhdDogc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICogRUVMIGNvZGUgdGhhdCdzIHJ1biBmb3IgZWFjaCBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgcGVyUG9pbnQ6IHN0cmluZyxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJsZW5kIG1vZGUgZm9yIHN1cGVyc2NvcGUuIERlZmF1bHQ6IGBSRVBMQUNFYFxuICAgICAqL1xuICAgIGJsZW5kTW9kZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIENoYW5uZWwgZm9yIHNjb3BlIHZhbHVlcy4gRGVmYXVsdDogYENFTlRFUmBcbiAgICAgKi9cbiAgICBjaGFubmVsOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogRGF0YSBzb3VyY2Ugb2Ygc2NvcGUgdmFsdWUuIERlZmF1bHQ6IGBTUEVDVFJVTWBcbiAgICAgKi9cbiAgICBzb3VyY2U6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBEcmF3aW5nIG1vZGUgZm9yIHRoZSBzY29wZS4gc2VlIFtbU3VwZXJTY29wZURyYXdNb2RlXV0uIERlZmF1bHQ6IGBMSU5FU2BcbiAgICAgKi9cbiAgICBkcmF3TW9kZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoaWNrbmVzcyBvZiBkb3RzL2xpbmUuIERlZmF1bHQ6IDFcbiAgICAgKi9cbiAgICB0aGlja25lc3M6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgdGltZXMgdGhpcyBzdXBlcnNjb3BlIGluc3RhbmNlIHNob3VsZCBiZSBjbG9uZWQuIERlZmF1bHQ6IDFcbiAgICAgKi9cbiAgICBjbG9uZTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIENvbG9ycyB0aGF0IHRoZSBzdXBlcnNjb3BlIHNob3VsZCBjeWNsZSB0aHJvdWdoLlxuICAgICAqIFJHQiB2YWx1ZXMgc2V0IHRocm91Z2ggRUVMIG92ZXJyaWRlIHRoaXMgY29sb3IuXG4gICAgICogRGVmYXVsdDogYFtcIiNGRkZGRkZcIl1gXG4gICAgICovXG4gICAgY29sb3JzOiBzdHJpbmdbXTtcbiAgICAvKipcbiAgICAgKiBTcGVlZCBhdCB3aGljaCBzdXBlcnNjb3BlIGNvbG9ycyB3aWxsIGJlIGN5Y2xlZC5cbiAgICAgKiBEZWZhdWx0OiBgMC4wMWBcbiAgICAgKi9cbiAgICBjeWNsZVNwZWVkOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBJU3VwZXJTY29wZVNoYWRlclZhbHVlcyB7XG4gICAgcG9pbnRTaXplOiBudW1iZXI7XG4gICAgcG9pbnRzOiBCdWZmZXI7XG4gICAgY29sb3JzOiBCdWZmZXI7XG4gICAgaXNEb3RzOiBib29sZWFuO1xuICAgIGRyYXdUcmlhbmdsZXM6IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBJU1NDb2RlSW5zdGFuY2UgZXh0ZW5kcyBDb2RlSW5zdGFuY2Uge1xuICAgIHJlZDogbnVtYmVyO1xuICAgIGdyZWVuOiBudW1iZXI7XG4gICAgYmx1ZTogbnVtYmVyO1xuICAgIG46IG51bWJlcjtcbiAgICBiOiBudW1iZXI7XG4gICAgaTogbnVtYmVyO1xuICAgIHY6IG51bWJlcjtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIGluaXQ6ICgpID0+IHZvaWQ7XG4gICAgcGVyRnJhbWU6ICgpID0+IHZvaWQ7XG4gICAgb25CZWF0OiAoKSA9PiB2b2lkO1xuICAgIHBlclBvaW50OiAoKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBzY29wZSwgdGhhdCBjYW4gZHJhdyBwb2ludHMgb3IgbGluZXMgYmFzZWQgb24gdXNlciBjb2RlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1cGVyU2NvcGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHB1YmxpYyBzdGF0aWMgY29tcG9uZW50TmFtZTogc3RyaW5nID0gXCJTdXBlclNjb3BlXCI7XG4gICAgcHVibGljIHN0YXRpYyBjb21wb25lbnRUYWc6IHN0cmluZyA9IFwicmVuZGVyXCI7XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBvcHRVcGRhdGVIYW5kbGVycyA9IHtcbiAgICAgICAgYmxlbmRNb2RlOiBcInVwZGF0ZVByb2dyYW1cIixcbiAgICAgICAgY2hhbm5lbDogXCJ1cGRhdGVDaGFubmVsXCIsXG4gICAgICAgIGNsb25lOiBcInVwZGF0ZUNsb25lc1wiLFxuICAgICAgICBjb2RlOiBbIFwidXBkYXRlQ29kZVwiLCBcInVwZGF0ZUNsb25lc1wiXSxcbiAgICAgICAgY29sb3JzOiBcInVwZGF0ZUNvbG9yc1wiLFxuICAgICAgICBjeWNsZVNwZWVkOiBcInVwZGF0ZVNwZWVkXCIsXG4gICAgICAgIGRyYXdNb2RlOiBcInVwZGF0ZURyYXdNb2RlXCIsXG4gICAgICAgIHNvdXJjZTogXCJ1cGRhdGVTb3VyY2VcIixcbiAgICAgICAgdGhpY2tuZXNzOiBcInVwZGF0ZVRoaWNrbmVzc1wiLFxuICAgIH07XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkZWZhdWx0T3B0aW9uczogSVN1cGVyU2NvcGVPcHRzID0ge1xuICAgICAgICBibGVuZE1vZGU6IFwiUkVQTEFDRVwiLFxuICAgICAgICBjaGFubmVsOiBcIkNFTlRFUlwiLFxuICAgICAgICBjbG9uZTogMSxcbiAgICAgICAgY29kZToge1xuICAgICAgICAgICAgaW5pdDogXCJuPTgwMFwiLFxuICAgICAgICAgICAgb25CZWF0OiBcIlwiLFxuICAgICAgICAgICAgcGVyRnJhbWU6IFwidD10LTAuMDVcIixcbiAgICAgICAgICAgIHBlclBvaW50OiBcImQ9aSt2KjAuMjsgcj10K2kqJFBJKjQ7IHg9Y29zKHIpKmQ7IHk9c2luKHIpKmRcIixcbiAgICAgICAgfSxcbiAgICAgICAgY29sb3JzOiBbXCIjZmZmZmZmXCJdLFxuICAgICAgICBjeWNsZVNwZWVkOiAwLjAxLFxuICAgICAgICBkcmF3TW9kZTogXCJMSU5FU1wiLFxuICAgICAgICBzb3VyY2U6IFwiU1BFQ1RSVU1cIixcbiAgICAgICAgdGhpY2tuZXNzOiAxLFxuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgb3B0czogSVN1cGVyU2NvcGVPcHRzO1xuICAgIHByaXZhdGUgcG9pbnRCdWZmZXI6IEJ1ZmZlcjtcbiAgICBwcml2YXRlIGNvbG9yQnVmZmVyOiBCdWZmZXI7XG4gICAgcHJpdmF0ZSBjb2RlOiBJU1NDb2RlSW5zdGFuY2VbXTtcbiAgICBwcml2YXRlIGluaXRlZDogYm9vbGVhbjtcbiAgICBwcml2YXRlIHByb2dyYW06IFNoYWRlclByb2dyYW08SVN1cGVyU2NvcGVTaGFkZXJWYWx1ZXM+O1xuICAgIHByaXZhdGUgc291cmNlOiBTb3VyY2U7XG4gICAgcHJpdmF0ZSBjaGFubmVsOiBDaGFubmVscztcbiAgICBwcml2YXRlIGRyYXdNb2RlOiBTdXBlclNjb3BlRHJhd01vZGU7XG4gICAgcHJpdmF0ZSB2ZXJ5VGhpY2s6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBjb2xvcnM6IENvbG9yW107XG4gICAgcHJpdmF0ZSBjdXJDb2xvcklkOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBtYXhTdGVwOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBjdXJTdGVwOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluOiBJTWFpbiwgcGFyZW50OiBJQ29udGFpbmVyLCBvcHRzOiBhbnkpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgcGFyZW50LCBvcHRzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaW5pdCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVEcmF3TW9kZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNvdXJjZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVByb2dyYW0oKTtcbiAgICAgICAgdGhpcy51cGRhdGVDb2RlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ2xvbmVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3BlZWQoKTtcbiAgICAgICAgdGhpcy51cGRhdGVDb2xvcnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVDaGFubmVsKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVGhpY2tuZXNzKCk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tYWluLCBcInJlc2l6ZVwiLCAoKSA9PiB0aGlzLmhhbmRsZVJlc2l6ZSgpKTtcblxuICAgICAgICB0aGlzLnBvaW50QnVmZmVyID0gbmV3IEJ1ZmZlcih0aGlzLm1haW4uZ2V0UmN0eCgpKTtcbiAgICAgICAgdGhpcy5jb2xvckJ1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5tYWluLmdldFJjdHgoKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGRyYXcoKSB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fbWFrZUNvbG9yKCk7XG4gICAgICAgIGVhY2godGhpcy5jb2RlLCAoY29kZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcmF3U2NvcGUoY29kZSwgY29sb3IsICF0aGlzLmluaXRlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmluaXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wb2ludEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY29sb3JCdWZmZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbmRlcnMgdGhlIHNjb3BlXG4gICAgICogQG1lbWJlcm9mIFdlYnZzLlN1cGVyU2NvcGUjXG4gICAgICovXG4gICAgcHJpdmF0ZSBkcmF3U2NvcGUoY29kZTogSVNTQ29kZUluc3RhbmNlLCBjb2xvcjogQ29sb3IsIHJ1bkluaXQ6IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLm1haW4uZ2V0UmN0eCgpLmdldEdsKCk7XG5cbiAgICAgICAgY29kZS5yZWQgPSBjb2xvclswXTtcbiAgICAgICAgY29kZS5ncmVlbiA9IGNvbG9yWzFdO1xuICAgICAgICBjb2RlLmJsdWUgPSBjb2xvclsyXTtcblxuICAgICAgICBpZiAocnVuSW5pdCkge1xuICAgICAgICAgICAgY29kZS5pbml0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiZWF0ID0gdGhpcy5tYWluLmdldEFuYWx5c2VyKCkuaXNCZWF0KCk7XG4gICAgICAgIGNvZGUuYiA9IGJlYXQgPyAxIDogMDtcbiAgICAgICAgY29kZS5wZXJGcmFtZSgpO1xuICAgICAgICBpZiAoYmVhdCkge1xuICAgICAgICAgICAgY29kZS5vbkJlYXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGNvZGUubik7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFNvdXJjZS5TUEVDVFJVTSkge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMubWFpbi5nZXRBbmFseXNlcigpLmdldFNwZWN0cnVtKHRoaXMuY2hhbm5lbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5tYWluLmdldEFuYWx5c2VyKCkuZ2V0V2F2ZWZvcm0odGhpcy5jaGFubmVsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb3RzID0gdGhpcy5kcmF3TW9kZSA9PT0gU3VwZXJTY29wZURyYXdNb2RlLkRPVFM7XG4gICAgICAgIGNvbnN0IGJ1Y2tldFNpemUgPSBkYXRhLmxlbmd0aCAvIG5Qb2ludHM7XG4gICAgICAgIGxldCBwYmkgPSAwO1xuICAgICAgICBsZXQgY2RpID0gMDtcblxuICAgICAgICBsZXQgYnVmZmVyU2l6ZTtcbiAgICAgICAgbGV0IHRoaWNrWDtcbiAgICAgICAgbGV0IHRoaWNrWTtcbiAgICAgICAgbGV0IGxhc3RYO1xuICAgICAgICBsZXQgbGFzdFk7XG4gICAgICAgIGxldCBsYXN0UjtcbiAgICAgICAgbGV0IGxhc3RHO1xuICAgICAgICBsZXQgbGFzdEI7XG4gICAgICAgIGlmICh0aGlzLnZlcnlUaGljaykge1xuICAgICAgICAgICAgYnVmZmVyU2l6ZSA9IChkb3RzID8gKG5Qb2ludHMgKiA2KSA6IChuUG9pbnRzICogNiAtIDYpKTtcbiAgICAgICAgICAgIHRoaWNrWCA9IHRoaXMub3B0cy50aGlja25lc3MgLyBnbC5kcmF3aW5nQnVmZmVyV2lkdGg7XG4gICAgICAgICAgICB0aGlja1kgPSB0aGlzLm9wdHMudGhpY2tuZXNzIC8gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlclNpemUgPSAoZG90cyA/IG5Qb2ludHMgOiAoblBvaW50cyAqIDIgLSAyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwb2ludEJ1ZmZlckRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUgKiAyKTtcbiAgICAgICAgY29uc3QgY29sb3JEYXRhID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJTaXplICogMyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgblBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IE1hdGguZmxvb3IoaSAqIGJ1Y2tldFNpemUpOyBqIDwgKGkgKyAxKSAqIGJ1Y2tldFNpemU7IGorKywgc2l6ZSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gZGF0YVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBzaXplO1xuXG4gICAgICAgICAgICBjb25zdCBwb3MgPSBpIC8gKChuUG9pbnRzID4gMSkgPyAoblBvaW50cyAtIDEpIDogMSk7XG4gICAgICAgICAgICBjb2RlLmkgPSBwb3M7XG4gICAgICAgICAgICBjb2RlLnYgPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvZGUucGVyUG9pbnQoKTtcbiAgICAgICAgICAgIGNvZGUueSAqPSAtMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZlcnlUaGljaykge1xuICAgICAgICAgICAgICAgIGlmIChkb3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgYSBib3ggYXQgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICAgICAgICBwb2ludEJ1ZmZlckRhdGFbcGJpKytdID0gY29kZS54IC0gdGhpY2tYO1xuICAgICAgICAgICAgICAgICAgICBwb2ludEJ1ZmZlckRhdGFbcGJpKytdID0gY29kZS55IC0gdGhpY2tZO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvaW50QnVmZmVyRGF0YVtwYmkrK10gPSBjb2RlLnggKyB0aGlja1g7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50QnVmZmVyRGF0YVtwYmkrK10gPSBjb2RlLnkgLSB0aGlja1k7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRCdWZmZXJEYXRhW3BiaSsrXSA9IGNvZGUueCAtIHRoaWNrWDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRCdWZmZXJEYXRhW3BiaSsrXSA9IGNvZGUueSArIHRoaWNrWTtcblxuICAgICAgICAgICAgICAgICAgICBwb2ludEJ1ZmZlckRhdGFbcGJpKytdID0gY29kZS54ICsgdGhpY2tYO1xuICAgICAgICAgICAgICAgICAgICBwb2ludEJ1ZmZlckRhdGFbcGJpKytdID0gY29kZS55IC0gdGhpY2tZO1xuXG4gICAgICAgICAgICAgICAgICAgIHBvaW50QnVmZmVyRGF0YVtwYmkrK10gPSBjb2RlLnggLSB0aGlja1g7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50QnVmZmVyRGF0YVtwYmkrK10gPSBjb2RlLnkgKyB0aGlja1k7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRCdWZmZXJEYXRhW3BiaSsrXSA9IGNvZGUueCArIHRoaWNrWDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRCdWZmZXJEYXRhW3BiaSsrXSA9IGNvZGUueSArIHRoaWNrWTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDY7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JEYXRhW2NkaSsrXSA9IGNvZGUucmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JEYXRhW2NkaSsrXSA9IGNvZGUuZ3JlZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvckRhdGFbY2RpKytdID0gY29kZS5ibHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHhkaWZmID0gTWF0aC5hYnMobGFzdFggLSBjb2RlLngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeWRpZmYgPSBNYXRoLmFicyhsYXN0WSAtIGNvZGUueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4b2ZmID0gKHhkaWZmIDw9IHlkaWZmKSA/IHRoaWNrWCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB5b2ZmID0gKHhkaWZmID4gIHlkaWZmKSA/IHRoaWNrWSA6IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgcmVjdGFuZ2xlIGZyb20gbGFzdCBwb2ludCB0byB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRCdWZmZXJEYXRhW3BiaSsrXSA9IGxhc3RYICsgeG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50QnVmZmVyRGF0YVtwYmkrK10gPSBsYXN0WSArIHlvZmY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50QnVmZmVyRGF0YVtwYmkrK10gPSBjb2RlLnggKyB4b2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRCdWZmZXJEYXRhW3BiaSsrXSA9IGNvZGUueSArIHlvZmY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50QnVmZmVyRGF0YVtwYmkrK10gPSBsYXN0WCAtIHhvZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEJ1ZmZlckRhdGFbcGJpKytdID0gbGFzdFkgLSB5b2ZmO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEJ1ZmZlckRhdGFbcGJpKytdID0gY29kZS54ICsgeG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50QnVmZmVyRGF0YVtwYmkrK10gPSBjb2RlLnkgKyB5b2ZmO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEJ1ZmZlckRhdGFbcGJpKytdID0gbGFzdFggLSB4b2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRCdWZmZXJEYXRhW3BiaSsrXSA9IGxhc3RZIC0geW9mZjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRCdWZmZXJEYXRhW3BiaSsrXSA9IGNvZGUueCAtIHhvZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEJ1ZmZlckRhdGFbcGJpKytdID0gY29kZS55IC0geW9mZjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA2OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvckRhdGFbY2RpKytdID0gY29kZS5yZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JEYXRhW2NkaSsrXSA9IGNvZGUuZ3JlZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JEYXRhW2NkaSsrXSA9IGNvZGUuYmx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0WCA9IGNvZGUueDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFkgPSBjb2RlLnk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSID0gY29kZS5yZWQ7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RHID0gY29kZS5ncmVlbjtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEIgPSBjb2RlLmJsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZG90cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGEgcG9pbnQgYXQgdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRCdWZmZXJEYXRhW3BiaSsrXSA9IGNvZGUueDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRCdWZmZXJEYXRhW3BiaSsrXSA9IGNvZGUueTtcblxuICAgICAgICAgICAgICAgICAgICBjb2xvckRhdGFbY2RpKytdID0gY29kZS5yZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yRGF0YVtjZGkrK10gPSBjb2RlLmdyZWVuO1xuICAgICAgICAgICAgICAgICAgICBjb2xvckRhdGFbY2RpKytdID0gY29kZS5ibHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsaW5lcyBmcm9tIGxhc3QgcG9pbnQgdG8gY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRCdWZmZXJEYXRhW3BiaSsrXSA9IGxhc3RYO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRCdWZmZXJEYXRhW3BiaSsrXSA9IGxhc3RZO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEJ1ZmZlckRhdGFbcGJpKytdID0gY29kZS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRCdWZmZXJEYXRhW3BiaSsrXSA9IGNvZGUueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgY3VycmVudCBjb2xvciBmb3IgYm90aCBwb2ludHMgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbnQgd2FudCBjb2xvciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JEYXRhW2NkaSsrXSA9IGNvZGUucmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yRGF0YVtjZGkrK10gPSBjb2RlLmdyZWVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yRGF0YVtjZGkrK10gPSBjb2RlLmJsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdFggPSBjb2RlLng7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RZID0gY29kZS55O1xuICAgICAgICAgICAgICAgICAgICBsYXN0UiA9IGNvZGUucmVkO1xuICAgICAgICAgICAgICAgICAgICBsYXN0RyA9IGNvZGUuZ3JlZW47XG4gICAgICAgICAgICAgICAgICAgIGxhc3RCID0gY29kZS5ibHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9pbnRCdWZmZXIuc2V0RGF0YShwb2ludEJ1ZmZlckRhdGEpO1xuICAgICAgICB0aGlzLmNvbG9yQnVmZmVyLnNldERhdGEoY29sb3JEYXRhKTtcblxuICAgICAgICB0aGlzLnByb2dyYW0ucnVuKFxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZ2V0VFNNKCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sb3JzOiB0aGlzLmNvbG9yQnVmZmVyLFxuICAgICAgICAgICAgICAgIGRyYXdUcmlhbmdsZXM6IHRoaXMudmVyeVRoaWNrLFxuICAgICAgICAgICAgICAgIGlzRG90czogZG90cyxcbiAgICAgICAgICAgICAgICBwb2ludFNpemU6IHRoaXMudmVyeVRoaWNrID8gMSA6IHRoaXMub3B0cy50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgcG9pbnRzOiB0aGlzLnBvaW50QnVmZmVyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVByb2dyYW0oKSB7XG4gICAgICAgIGNvbnN0IGJsZW5kTW9kZTogQmxlbmRNb2RlID0gQmxlbmRNb2RlW3RoaXMub3B0cy5ibGVuZE1vZGVdO1xuICAgICAgICBjb25zdCBwcm9ncmFtID0gbmV3IFNoYWRlclByb2dyYW08SVN1cGVyU2NvcGVTaGFkZXJWYWx1ZXM+KHRoaXMubWFpbi5nZXRSY3R4KCksIHtcbiAgICAgICAgICAgIGJpbmRpbmdzOiB7XG4gICAgICAgICAgICAgICAgYXR0cmliczoge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnM6IHsgbmFtZTogXCJhX2NvbG9yXCIsIHNpemU6IDMgfSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiB7IG5hbWU6IFwiYV9wb3NpdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgICAgICAgICBwb2ludFNpemU6IHsgbmFtZTogXCJ1X3BvaW50U2l6ZVwiLCB2YWx1ZVR5cGU6IFdlYkdMVmFyVHlwZS5fMUYgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJsZW5kTW9kZSxcbiAgICAgICAgICAgIGNvcHlPblN3YXA6IHRydWUsXG4gICAgICAgICAgICBkcmF3SG9vazogKHZhbHVlcywgZ2wpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcHJldkxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlcy5pc0RvdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldkxpbmVXaWR0aCA9IGdsLmdldFBhcmFtZXRlcihnbC5MSU5FX1dJRFRIKTtcbiAgICAgICAgICAgICAgICAgICAgZ2wubGluZVdpZHRoKHZhbHVlcy5wb2ludFNpemUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBtb2RlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMuZHJhd1RyaWFuZ2xlcykge1xuICAgICAgICAgICAgICAgICAgICBtb2RlID0gZ2wuVFJJQU5HTEVTO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVzLmlzRG90cykge1xuICAgICAgICAgICAgICAgICAgICBtb2RlID0gZ2wuUE9JTlRTO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBnbC5MSU5FUztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhtb2RlLCAwLCB2YWx1ZXMucG9pbnRzLmdldExlbmd0aCgpIC8gMik7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlcy5pc0RvdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wubGluZVdpZHRoKHByZXZMaW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogYFxuICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2X2NvbG9yO1xuICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RnJhZ0NvbG9yKHZlYzQodl9jb2xvciwgMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGAsXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGBcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMzIGFfY29sb3I7XG4gICAgICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZfY29sb3I7XG4gICAgICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1X3BvaW50U2l6ZTtcbiAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsX1BvaW50U2l6ZSA9IHVfcG9pbnRTaXplO1xuICAgICAgICAgICAgICAgICAgICBzZXRQb3NpdGlvbihhX3Bvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdl9jb2xvciA9IGFfY29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUNvZGUoKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBjb21waWxlRXhwcihcbiAgICAgICAgICAgIHRoaXMub3B0cy5jb2RlLFxuICAgICAgICAgICAgW1wiaW5pdFwiLCBcIm9uQmVhdFwiLCBcInBlckZyYW1lXCIsIFwicGVyUG9pbnRcIl0sXG4gICAgICAgICkuY29kZUluc3QgYXMgSVNTQ29kZUluc3RhbmNlO1xuICAgICAgICBjb2RlLm4gPSAxMDA7XG4gICAgICAgIGNvZGUuc2V0dXAodGhpcy5tYWluKTtcbiAgICAgICAgdGhpcy5pbml0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2RlID0gW2NvZGVdO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlQ2xvbmVzKCkge1xuICAgICAgICB0aGlzLmNvZGUgPSBDb2RlSW5zdGFuY2UuY2xvbmUodGhpcy5jb2RlLCB0aGlzLm9wdHMuY2xvbmUpIGFzIElTU0NvZGVJbnN0YW5jZVtdO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlQ29sb3JzKCkge1xuICAgICAgICB0aGlzLmNvbG9ycyA9IG1hcCh0aGlzLm9wdHMuY29sb3JzLCBwYXJzZUNvbG9yTm9ybSk7XG4gICAgICAgIHRoaXMuY3VyQ29sb3JJZCA9IDA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVTcGVlZCgpIHtcbiAgICAgICAgY29uc3Qgb2xkTWF4U3RlcCA9IHRoaXMubWF4U3RlcDtcbiAgICAgICAgdGhpcy5tYXhTdGVwID0gTWF0aC5mbG9vcigxIC8gdGhpcy5vcHRzLmN5Y2xlU3BlZWQpO1xuICAgICAgICBpZiAodGhpcy5jdXJTdGVwKSB7XG4gICAgICAgICAgICAvLyBjdXJTdGVwIGFkanVzdG1lbnQgd2hlbiBzcGVlZCBjaGFuZ2VzXG4gICAgICAgICAgICB0aGlzLmN1clN0ZXAgPSBNYXRoLmZsb29yKCh0aGlzLmN1clN0ZXAgLyBvbGRNYXhTdGVwKSAqIHRoaXMubWF4U3RlcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1clN0ZXAgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVDaGFubmVsKCkge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBDaGFubmVsc1t0aGlzLm9wdHMuY2hhbm5lbF07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVTb3VyY2UoKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gU291cmNlW3RoaXMub3B0cy5zb3VyY2VdO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlRHJhd01vZGUoKSB7XG4gICAgICAgIHRoaXMuZHJhd01vZGUgPSBTdXBlclNjb3BlRHJhd01vZGVbdGhpcy5vcHRzLmRyYXdNb2RlXTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRoaWNrbmVzcygpIHtcbiAgICAgICAgbGV0IHJhbmdlO1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMubWFpbi5nZXRSY3R4KCkuZ2V0R2woKTtcbiAgICAgICAgaWYgKHRoaXMuZHJhd01vZGUgPT09IFN1cGVyU2NvcGVEcmF3TW9kZS5ET1RTKSB7XG4gICAgICAgICAgICByYW5nZSA9IGdsLmdldFBhcmFtZXRlcihnbC5BTElBU0VEX1BPSU5UX1NJWkVfUkFOR0UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2UgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLnRoaWNrbmVzcyA8IHJhbmdlWzBdIHx8IHRoaXMub3B0cy50aGlja25lc3MgPiByYW5nZVsxXSkge1xuICAgICAgICAgICAgdGhpcy52ZXJ5VGhpY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52ZXJ5VGhpY2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX21ha2VDb2xvcigpOiBDb2xvciB7XG4gICAgICAgIGlmICh0aGlzLmNvbG9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbG9yc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yOiBDb2xvciA9IFswLCAwLCAwXTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb2xvciA9IHRoaXMuY29sb3JzW3RoaXMuY3VyQ29sb3JJZF07XG4gICAgICAgICAgICBjb25zdCBuZXh0Q29sb3IgPSB0aGlzLmNvbG9yc1sodGhpcy5jdXJDb2xvcklkICsgMSkgJSB0aGlzLmNvbG9ycy5sZW5ndGhdO1xuICAgICAgICAgICAgY29uc3QgbWl4ID0gdGhpcy5jdXJTdGVwIC8gdGhpcy5tYXhTdGVwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb2xvcltpXSA9IGN1cnJlbnRDb2xvcltpXSAqICgxIC0gbWl4KSArIG5leHRDb2xvcltpXSAqIG1peDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VyU3RlcCA9ICh0aGlzLmN1clN0ZXAgKyAxKSAlIHRoaXMubWF4U3RlcDtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1clN0ZXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1ckNvbG9ySWQgPSAodGhpcy5jdXJDb2xvcklkICsgMSkgJSB0aGlzLmNvbG9ycy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZVJlc2l6ZSgpIHtcbiAgICAgICAgZWFjaCh0aGlzLmNvZGUsIChjb2RlKSA9PiB7XG4gICAgICAgICAgICBjb2RlLnVwZGF0ZURpbVZhcnModGhpcy5tYWluLmdldFJjdHgoKS5nZXRHbCgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlbmRlci9TdXBlclNjb3BlLnRzIiwiaW1wb3J0IGVhY2ggZnJvbSBcImxvZGFzaC1lcy9lYWNoXCI7XG5pbXBvcnQgQ29tcG9uZW50LCB7IElDb250YWluZXIgfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG5pbXBvcnQgQ29kZUluc3RhbmNlIGZyb20gXCIuLi9leHByL0NvZGVJbnN0YW5jZVwiO1xuaW1wb3J0IGNvbXBpbGVFeHByIGZyb20gXCIuLi9leHByL2NvbXBpbGVFeHByXCI7XG5pbXBvcnQgSU1haW4gZnJvbSBcIi4uL0lNYWluXCI7XG5pbXBvcnQgeyBTb3VyY2UsIFdlYkdMVmFyVHlwZSB9IGZyb20gXCIuLi91dGlsc1wiO1xuaW1wb3J0IEJ1ZmZlciBmcm9tIFwiLi4vd2ViZ2wvQnVmZmVyXCI7XG5pbXBvcnQgUmVuZGVyaW5nQ29udGV4dCBmcm9tIFwiLi4vd2ViZ2wvUmVuZGVyaW5nQ29udGV4dFwiO1xuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSBcIi4uL3dlYmdsL1NoYWRlclByb2dyYW1cIjtcblxuZXhwb3J0IGludGVyZmFjZSBJVGV4ZXJPcHRzIHtcbiAgICBjb2RlOiB7XG4gICAgICAgIGluaXQ6IHN0cmluZyxcbiAgICAgICAgb25CZWF0OiBzdHJpbmcsXG4gICAgICAgIHBlckZyYW1lOiBzdHJpbmcsXG4gICAgICAgIHBlclBvaW50OiBzdHJpbmcsXG4gICAgfTtcbiAgICBpbWFnZVNyYzogc3RyaW5nO1xuICAgIHNvdXJjZTogc3RyaW5nO1xuICAgIHJlc2l6aW5nOiBib29sZWFuO1xuICAgIHdyYXBBcm91bmQ6IGJvb2xlYW47XG4gICAgY2xvbmU6IG51bWJlcjtcbiAgICBjb2xvckZpbHRlcmluZzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIElUZXhlckNvZGVJbnN0YW5jZSBleHRlbmRzIENvZGVJbnN0YW5jZSB7XG4gICAgbjogbnVtYmVyO1xuICAgIGI6IG51bWJlcjtcbiAgICBpOiBudW1iZXI7XG4gICAgdjogbnVtYmVyO1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG4gICAgc2l6ZXg6IG51bWJlcjtcbiAgICBzaXpleTogbnVtYmVyO1xuICAgIHJlZDogbnVtYmVyO1xuICAgIGdyZWVuOiBudW1iZXI7XG4gICAgYmx1ZTogbnVtYmVyO1xuICAgIGluaXQ6ICgpID0+IHZvaWQ7XG4gICAgcGVyRnJhbWU6ICgpID0+IHZvaWQ7XG4gICAgcGVyUG9pbnQ6ICgpID0+IHZvaWQ7XG4gICAgb25CZWF0OiAoKSA9PiB2b2lkO1xufVxuXG4vLyBBIFN1cGVyU2NvcGUgbGlrZSBjb21wb25lbnQgdGhhdCBwbGFjZXMgaW1hZ2VzIGF0IHBvaW50cy5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudE5hbWU6IHN0cmluZyA9IFwiVGV4ZXJcIjtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudFRhZzogc3RyaW5nID0gXCJyZW5kZXJcIjtcbiAgICBwcm90ZWN0ZWQgc3RhdGljIG9wdFVwZGF0ZUhhbmRsZXJzID0ge1xuICAgICAgICBjbG9uZTogXCJ1cGRhdGVDbG9uZVwiLFxuICAgICAgICBjb2RlOiBcInVwZGF0ZUNvZGVcIixcbiAgICAgICAgaW1hZ2VTcmM6IFwidXBkYXRlSW1hZ2VcIixcbiAgICAgICAgc291cmNlOiBcInVwZGF0ZVNvdXJjZVwiLFxuICAgIH07XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkZWZhdWx0T3B0aW9uczogSVRleGVyT3B0cyA9IHtcbiAgICAgICAgY2xvbmU6IDEsXG4gICAgICAgIGNvZGU6IHtcbiAgICAgICAgICAgIGluaXQ6IFwiXCIsXG4gICAgICAgICAgICBvbkJlYXQ6IFwiXCIsXG4gICAgICAgICAgICBwZXJGcmFtZTogXCJcIixcbiAgICAgICAgICAgIHBlclBvaW50OiBcIlwiLFxuICAgICAgICB9LFxuICAgICAgICBjb2xvckZpbHRlcmluZzogdHJ1ZSxcbiAgICAgICAgaW1hZ2VTcmM6IFwiYXZzcmVzX3RleGVyX2NpcmNsZV9lZGdlb25seV8xOXgxOS5ibXBcIixcbiAgICAgICAgcmVzaXppbmc6IGZhbHNlLFxuICAgICAgICBzb3VyY2U6IFwiU1BFQ1RSVU1cIixcbiAgICAgICAgd3JhcEFyb3VuZDogZmFsc2UsXG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBvcHRzOiBJVGV4ZXJPcHRzO1xuICAgIHByaXZhdGUgcHJvZ3JhbTogU2hhZGVyUHJvZ3JhbTtcbiAgICBwcml2YXRlIHZlcnRleEJ1ZmZlcjogQnVmZmVyO1xuICAgIHByaXZhdGUgdGV4VmVydGV4QnVmZmVyOiBCdWZmZXI7XG4gICAgcHJpdmF0ZSBjb2xvckJ1ZmZlcjogQnVmZmVyO1xuICAgIHByaXZhdGUgaW5kZXhCdWZmZXI6IEJ1ZmZlcjtcbiAgICBwcml2YXRlIGNvZGU6IElUZXhlckNvZGVJbnN0YW5jZVtdO1xuICAgIHByaXZhdGUgaW5pdGVkOiBib29sZWFuO1xuICAgIHByaXZhdGUgdGV4dHVyZTogV2ViR0xUZXh0dXJlO1xuICAgIHByaXZhdGUgaW1hZ2VXaWR0aDogbnVtYmVyO1xuICAgIHByaXZhdGUgaW1hZ2VIZWlnaHQ6IG51bWJlcjtcbiAgICBwcml2YXRlIHNvdXJjZTogU291cmNlO1xuXG4gICAgY29uc3RydWN0b3IobWFpbjogSU1haW4sIHBhcmVudDogSUNvbnRhaW5lciwgb3B0czogYW55KSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHBhcmVudCwgb3B0cyk7XG4gICAgfVxuXG4gICAgcHVibGljIGhhbmRsZVJlc2l6ZSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBjb2RlSW5zdCBvZiB0aGlzLmNvZGUpIHtcbiAgICAgICAgICAgIGNvZGVJbnN0LnVwZGF0ZURpbVZhcnModGhpcy5tYWluLmdldFJjdHgoKS5nZXRHbCgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBpbml0KCkge1xuICAgICAgICBjb25zdCByY3R4ID0gdGhpcy5tYWluLmdldFJjdHgoKTtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLm1haW4uZ2V0UmN0eCgpLmdldEdsKCk7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKHJjdHgsIHtcbiAgICAgICAgICAgIGJpbmRpbmdzOiB7XG4gICAgICAgICAgICAgICAgYXR0cmliczoge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnM6ICAgICAgeyBuYW1lOiBcImFfY29sb3JcIiwgc2l6ZTogMyB9LFxuICAgICAgICAgICAgICAgICAgICB0ZXhWZXJ0aWNlczogeyBuYW1lOiBcImFfdGV4VmVydGV4XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXM6ICAgIHsgbmFtZTogXCJhX3ZlcnRleFwiIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbmRleDoge1xuICAgICAgICAgICAgICAgICAgICBkcmF3TW9kZTogZ2wuVFJJQU5HTEVTLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZU5hbWU6IFwiaW5kaWNlc1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JGaWx0ZXI6IHsgbmFtZTogXCJ1X2NvbG9yRmlsdGVyXCIsIHZhbHVlVHlwZTogV2ViR0xWYXJUeXBlLl8xSSB9LFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogICAgICAgeyBuYW1lOiBcInVfaW1hZ2VcIiwgdmFsdWVUeXBlOiBXZWJHTFZhclR5cGUuVEVYVFVSRTJEIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb3B5T25Td2FwOiB0cnVlLFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGBcbiAgICAgICAgICAgICAgICB1bmlmb3JtIGJvb2wgdV9jb2xvckZpbHRlcjtcbiAgICAgICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xuICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2X3RleFZlcnRleDtcbiAgICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdl9jb2xvcjtcbiAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgdmVjMyBvdXRDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleFZlcnRleCkucmdiO1xuICAgICAgICAgICAgICAgICAgIGlmKHVfY29sb3JGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgb3V0Q29sb3IgPSBvdXRDb2xvcip2X2NvbG9yO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBzZXRGcmFnQ29sb3IodmVjNChvdXRDb2xvciwgMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGAsXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGBcbiAgICAgICAgICAgICAgICB1bmlmb3JtIGJvb2wgdV9jb2xvckZpbHRlcjtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhX3RleFZlcnRleDtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhX3ZlcnRleDtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhX2NvbG9yO1xuICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2X3RleFZlcnRleDtcbiAgICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdl9jb2xvcjtcbiAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgaWYodV9jb2xvckZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICB2X2NvbG9yID0gYV9jb2xvcjtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgdl90ZXhWZXJ0ZXggPSBhX3RleFZlcnRleDtcbiAgICAgICAgICAgICAgICAgICBzZXRQb3NpdGlvbihhX3ZlcnRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlQ29kZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNsb25lKCk7XG4gICAgICAgIHRoaXMudXBkYXRlSW1hZ2UoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTb3VyY2UoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1haW4sIFwicmVzaXplXCIsICgpID0+IHRoaXMuaGFuZGxlUmVzaXplKCkpO1xuXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyID0gbmV3IEJ1ZmZlcihyY3R4KTtcbiAgICAgICAgdGhpcy50ZXhWZXJ0ZXhCdWZmZXIgPSBuZXcgQnVmZmVyKHJjdHgpO1xuICAgICAgICB0aGlzLmNvbG9yQnVmZmVyID0gbmV3IEJ1ZmZlcihyY3R4KTtcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXIocmN0eCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGRyYXcoKSB7XG4gICAgICAgIGVhY2godGhpcy5jb2RlLCAoY29kZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZHJhd1Njb3BlKGNvZGUsICF0aGlzLmluaXRlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmluaXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5tYWluLmdldFJjdHgoKS5nZXRHbCgpO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucHJvZ3JhbS5kZXN0cm95KCk7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnRleFZlcnRleEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY29sb3JCdWZmZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUNvZGUoKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBjb21waWxlRXhwcihcbiAgICAgICAgICAgIHRoaXMub3B0cy5jb2RlLFxuICAgICAgICAgICAgW1wiaW5pdFwiLCBcIm9uQmVhdFwiLCBcInBlckZyYW1lXCIsIFwicGVyUG9pbnRcIl0sXG4gICAgICAgICkuY29kZUluc3QgYXMgSVRleGVyQ29kZUluc3RhbmNlO1xuICAgICAgICBjb2RlLm4gPSAxMDA7XG4gICAgICAgIGNvZGUuc2V0dXAodGhpcy5tYWluKTtcbiAgICAgICAgdGhpcy5pbml0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2RlID0gW2NvZGVdO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlQ2xvbmUoKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IENvZGVJbnN0YW5jZS5jbG9uZSh0aGlzLmNvZGUsIHRoaXMub3B0cy5jbG9uZSkgYXMgSVRleGVyQ29kZUluc3RhbmNlW107XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVJbWFnZSgpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLm1haW4uZ2V0UmN0eCgpLmdldEdsKCk7XG4gICAgICAgIHRoaXMubWFpbi5nZXRSc3JjTWFuKCkuZ2V0SW1hZ2UoXG4gICAgICAgICAgICB0aGlzLm9wdHMuaW1hZ2VTcmMsXG4gICAgICAgICAgICAoaW1hZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlV2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlSGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlU291cmNlKCkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IFNvdXJjZVt0aGlzLm9wdHMuc291cmNlXTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9kcmF3U2NvcGUoY29kZTogSVRleGVyQ29kZUluc3RhbmNlLCBydW5Jbml0OiBib29sZWFuKSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5tYWluLmdldFJjdHgoKS5nZXRHbCgpO1xuICAgICAgICBpZiAocnVuSW5pdCkge1xuICAgICAgICAgICAgY29kZS5pbml0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiZWF0ID0gdGhpcy5tYWluLmdldEFuYWx5c2VyKCkuaXNCZWF0KCk7XG4gICAgICAgIGNvZGUuYiA9IGJlYXQgPyAxIDogMDtcbiAgICAgICAgY29kZS5wZXJGcmFtZSgpO1xuICAgICAgICBpZiAoYmVhdCkge1xuICAgICAgICAgICAgY29kZS5vbkJlYXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBNYXRoLmZsb29yKGNvZGUubik7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFNvdXJjZS5TUEVDVFJVTSkge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMubWFpbi5nZXRBbmFseXNlcigpLmdldFNwZWN0cnVtKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5tYWluLmdldEFuYWx5c2VyKCkuZ2V0V2F2ZWZvcm0oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWNrZXRTaXplID0gZGF0YS5sZW5ndGggLyBuUG9pbnRzO1xuXG4gICAgICAgIGNvbnN0IHZlcnRleERhdGEgPSBbXTtcbiAgICAgICAgY29uc3QgdGV4VmVydGV4RGF0YSA9IFtdO1xuICAgICAgICBjb25zdCB2ZXJ0ZXhJbmRpY2VzID0gW107XG4gICAgICAgIGNvbnN0IGNvbG9yRGF0YSA9IHRoaXMub3B0cy5jb2xvckZpbHRlcmluZyA/IFtdIDogbnVsbDtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgYWRkUmVjdCA9IChjb3JueCwgY29ybnksIHNpemV4LCBzaXpleSwgcmVkLCBncmVlbiwgYmx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvcm54IDwgLTEgLSBzaXpleCB8fCBjb3JueCA+IDEgfHxcbiAgICAgICAgICAgICAgIGNvcm55IDwgLTEgLSBzaXpleSB8fCBjb3JueSA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIHZlcnRleERhdGEucHVzaChcbiAgICAgICAgICAgICAgICBjb3JueCwgICAgICAgY29ybnksXG4gICAgICAgICAgICAgICAgY29ybnggKyBzaXpleCwgY29ybnksXG4gICAgICAgICAgICAgICAgY29ybnggKyBzaXpleCwgY29ybnkgKyBzaXpleSxcbiAgICAgICAgICAgICAgICBjb3JueCwgICAgICAgY29ybnkgKyBzaXpleSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIHRleHR1cmUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIHRleFZlcnRleERhdGEucHVzaChcbiAgICAgICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgICAgIDEsIDAsXG4gICAgICAgICAgICAgICAgMSwgMSxcbiAgICAgICAgICAgICAgICAwLCAxLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKGNvbG9yRGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbG9yIGRhdGFcbiAgICAgICAgICAgICAgICBjb2xvckRhdGEucHVzaChcbiAgICAgICAgICAgICAgICAgICAgcmVkLCBncmVlbiwgYmx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVkLCBncmVlbiwgYmx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVkLCBncmVlbiwgYmx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVkLCBncmVlbiwgYmx1ZSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbmRpY2VzXG4gICAgICAgICAgICB2ZXJ0ZXhJbmRpY2VzLnB1c2goXG4gICAgICAgICAgICAgICAgaW5kZXggKyAwLCBpbmRleCArIDEsIGluZGV4ICsgMixcbiAgICAgICAgICAgICAgICBpbmRleCArIDAsIGluZGV4ICsgMiwgaW5kZXggKyAzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaW1hZ2VTaXpleCA9ICh0aGlzLmltYWdlV2lkdGggLyBnbC5kcmF3aW5nQnVmZmVyV2lkdGgpICogMjtcbiAgICAgICAgY29uc3QgaW1hZ2VTaXpleSA9ICh0aGlzLmltYWdlSGVpZ2h0IC8gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCkgKiAyO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgblBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IE1hdGguZmxvb3IoaSAqIGJ1Y2tldFNpemUpOyBqIDwgKGkgKyAxKSAqIGJ1Y2tldFNpemU7IGorKywgc2l6ZSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gZGF0YVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBzaXplO1xuXG4gICAgICAgICAgICBjb25zdCBwb3MgPSBpIC8gKG5Qb2ludHMgLSAxKTtcbiAgICAgICAgICAgIGNvZGUuaSA9IHBvcztcbiAgICAgICAgICAgIGNvZGUudiA9IHZhbHVlO1xuICAgICAgICAgICAgY29kZS5zaXpleCA9IDE7XG4gICAgICAgICAgICBjb2RlLnNpemV5ID0gMTtcbiAgICAgICAgICAgIGNvZGUucmVkID0gMTtcbiAgICAgICAgICAgIGNvZGUuZ3JlZW4gPSAxO1xuICAgICAgICAgICAgY29kZS5ibHVlID0gMTtcbiAgICAgICAgICAgIGNvZGUucGVyUG9pbnQoKTtcblxuICAgICAgICAgICAgbGV0IHNpemV4ID0gaW1hZ2VTaXpleDtcbiAgICAgICAgICAgIGxldCBzaXpleSA9IGltYWdlU2l6ZXk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnJlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgc2l6ZXggKj0gY29kZS5zaXpleDtcbiAgICAgICAgICAgICAgICBzaXpleSAqPSBjb2RlLnNpemV5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29ybnggPSBjb2RlLnggLSBzaXpleCAvIDI7XG4gICAgICAgICAgICBjb25zdCBjb3JueSA9ICgtY29kZS55KSAtIHNpemV5IC8gMjtcblxuICAgICAgICAgICAgYWRkUmVjdChjb3JueCwgY29ybnksIHNpemV4LCBzaXpleSwgY29kZS5yZWQsIGNvZGUuZ3JlZW4sIGNvZGUuYmx1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLndyYXBBcm91bmQpIHtcbiAgICAgICAgICAgICAgICAvLyB3cmFwcGVkIGFyb3VuZCB4IHZhbHVlIGlzIDEtKC0xLWNvcm54KSBvciAtMS0oMS1jb3JueClcbiAgICAgICAgICAgICAgICAvLyBkZXBlbmRpbmcgb24gdGhlIGVkZ2VcbiAgICAgICAgICAgICAgICAvLyBpZS4gMitjb3JueCBvciAtMitjb3JueFxuICAgICAgICAgICAgICAgIGNvbnN0IHh3cmFwID0gKGNvcm54IDwgLTEpID8gMiA6ICgoY29ybnggPiAoMSAtIHNpemV4KSkgPyAtMiA6IDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHl3cmFwID0gKGNvcm55IDwgLTEpID8gMiA6ICgoY29ybnkgPiAoMSAtIHNpemV5KSkgPyAtMiA6IDApO1xuICAgICAgICAgICAgICAgIGlmICh4d3JhcCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRSZWN0KHh3cmFwICsgY29ybngsIGNvcm55LCBzaXpleCwgc2l6ZXksIGNvZGUucmVkLCBjb2RlLmdyZWVuLCBjb2RlLmJsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeXdyYXApIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkUmVjdChjb3JueCwgeXdyYXAgKyBjb3JueSwgc2l6ZXgsIHNpemV5LCBjb2RlLnJlZCwgY29kZS5ncmVlbiwgY29kZS5ibHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHh3cmFwICYmIHl3cmFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFJlY3QoeHdyYXAgKyBjb3JueCwgeXdyYXAgKyBjb3JueSwgc2l6ZXgsIHNpemV5LCBjb2RlLnJlZCwgY29kZS5ncmVlbiwgY29kZS5ibHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlci5zZXREYXRhKHZlcnRleERhdGEpO1xuICAgICAgICB0aGlzLnRleFZlcnRleEJ1ZmZlci5zZXREYXRhKHRleFZlcnRleERhdGEpO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyLnNldERhdGEobmV3IFVpbnQxNkFycmF5KHZlcnRleEluZGljZXMpKTtcbiAgICAgICAgaWYgKGNvbG9yRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5jb2xvckJ1ZmZlci5zZXREYXRhKGNvbG9yRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9ncmFtLnJ1bihcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmdldFRTTSgpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbG9yRmlsdGVyOiBjb2xvckRhdGEgPyAxIDogMCxcbiAgICAgICAgICAgICAgICBjb2xvcnM6IGNvbG9yRGF0YSA/IHRoaXMuY29sb3JCdWZmZXIgOiBudWxsLFxuICAgICAgICAgICAgICAgIGltYWdlOiB0aGlzLnRleHR1cmUsXG4gICAgICAgICAgICAgICAgaW5kaWNlczogdGhpcy5pbmRleEJ1ZmZlcixcbiAgICAgICAgICAgICAgICB0ZXhWZXJ0aWNlczogdGhpcy50ZXhWZXJ0ZXhCdWZmZXIsXG4gICAgICAgICAgICAgICAgdmVydGljZXM6IHRoaXMudmVydGV4QnVmZmVyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyL1RleGVyLnRzIiwiaW1wb3J0IGNsb25lIGZyb20gXCJsb2Rhc2gtZXMvY2xvbmVcIjtcbmltcG9ydCBleHRlbmQgZnJvbSBcImxvZGFzaC1lcy9leHRlbmRcIjtcbmltcG9ydCBpc0FycmF5IGZyb20gXCJsb2Rhc2gtZXMvaXNBcnJheVwiO1xuaW1wb3J0IHBpY2tCeSBmcm9tIFwibG9kYXNoLWVzL3BpY2tCeVwiO1xuaW1wb3J0IE1vZGVsIGZyb20gXCIuL01vZGVsXCI7XG5cbi8qKlxuICogRGVmaW5lcyBhIHJlc291cmNlIHBhY2suIFJlc291cmNlIFBhY2tzXG4gKiBjYW4gYmUgYWRkZWQgdG8gcmVzb3VyY2UgbWFuYWdlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJUGFjayB7XG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgUmVzb3VyY2UgUGFja1xuICAgICAqL1xuICAgIG5hbWU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBVUkwgcHJlZml4IGZvciB0aGUgUmVzb3VyY2UgUGFjay4gRnVsbCBVUkwgdG9cbiAgICAgKiBhIGZpbGUgaW4gdGhpcyBwYWNrIGlzIG9idGFpbmVkIGJ5IGFwcGVuZGluZyB0aGUgZmlsZW5hbWVcbiAgICAgKiB0byB0aGlzIHByZWZpeFxuICAgICAqL1xuICAgIHByZWZpeDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIE5hbWVzIG9mIHRoZSBmaWxlcy5cbiAgICAgKi9cbiAgICBmaWxlTmFtZXM6IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIFJlc291cmNlTWFuYWdlciBtYW5hZ2VzIGFzeW5jIGxvYWRpbmcgYW5kIGNhY2hpbmcgb2YgcmVzb3VyY2VzLlxuICpcbiAqIFJlc291cmNlTWFuYWdlciBCYXNpY2FsbHksIGl0IG1haW50YWlucyBhIG1hcCBvZiBmaWxlTmFtZXMgdG8gVVJJIGZvclxuICogdGhlIHJlc291cmNlLiBXaGVuIGEgcmVxdWVzdCBmb3IgcmVzb3VyY2UgZmlsZU5hbWUgaXMgcmVjZWl2ZWQsIHRoZSB1cmkgaXMgbG9va2VkIHVwXG4gKiBhbmQgdGhlIGZpbGUgaXMgZWl0aGVyIGFzeW5jIGxvYWRlZCBvciBzZXJ2ZWQgZnJvbSBjYWNoZS4gVGhpcyBhbHNvIG1hbmFnZXNcbiAqIGEgcmVhZHkgc3RhdGUgd2l0aCBjYWxsYmFja3MgdGhhdCB0ZWxscyB3aGVuIG9uZSBvciBtb3JlIHJlc291cmNlcyBhcmUgYmVpbmcgbG9hZGVkIGFuZFxuICogd2hlbiBhbGwgcmVzb3VyY2VzIGFyZSByZWFkeS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzb3VyY2VNYW5hZ2VyIGV4dGVuZHMgTW9kZWwge1xuICAgIHB1YmxpYyByZWFkeTogYm9vbGVhbiA9IHRydWU7XG4gICAgcHJpdmF0ZSBwYWNrczogSVBhY2tbXTtcbiAgICBwcml2YXRlIHVyaXM6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge307XG4gICAgcHJpdmF0ZSBpbWFnZXM6IHtba2V5OiBzdHJpbmddOiBIVE1MSW1hZ2VFbGVtZW50fSA9IHt9O1xuICAgIHByaXZhdGUgd2FpdEltYWdlczoge1trZXk6IHN0cmluZ106IEhUTUxJbWFnZUVsZW1lbnR9ID0ge307XG4gICAgcHJpdmF0ZSB3YWl0Q291bnQ6IG51bWJlciA9IDA7XG5cbiAgICBjb25zdHJ1Y3RvcihwYWNrczogSVBhY2sgfCBJUGFja1tdKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChwYWNrcykge1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5KHBhY2tzKSkge1xuICAgICAgICAgICAgICAgIHBhY2tzID0gW3BhY2tzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFja3MgPSBwYWNrcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFja3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBmaWxlbmFtZSBhbmQgYSBVUkkgaW4gdGhlIHJlc291cmNlIG1hbmFnZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZU5hbWUgbmFtZSBvZiB0aGUgZmlsZSBvciBtYXAgb2YgZmlsZW5hbWU6IHVyaS5cbiAgICAgKiBAcGFyYW0gdXJpIHVyaSB3aGVuIHN0cmluZyBmaWxlTmFtZSBpcyBzcGVjaWZpZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVnaXN0ZXJVcmkoZmlsZU5hbWU6IHN0cmluZyB8IGFueSwgdXJpPzogc3RyaW5nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZU5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy51cmlzW2ZpbGVOYW1lXSA9IHVyaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0VXJpcyA9IGZpbGVOYW1lO1xuICAgICAgICAgICAgZXh0ZW5kKHRoaXMudXJpcywgaW5wdXRVcmlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoaXMgUmVzb3VyY2VNYW5hZ2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUuIE9ubHkgYFwidXJpc1wiYCBpcyBhY2NlcHRhYmxlLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQoa2V5OiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJ1cmlzXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVyaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlc291cmNlIG1hbmFnZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJpczogY2xvbmUodGhpcy51cmlzKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgc3RhdGUsIHVyaSBtYXBwaW5ncyBhbmQgY2FjaGVzLiBCcm93c2VyIGNhY2hlcyBzdGlsbCBhcHBseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXlzIHRoZSBrZXlzIHdoaWNoIHNob3VsZCBiZSBjbGVhcmVkLiBEZWZhdWx0IGNsZWFycyBldmVyeXRoaW5nLlxuICAgICAqL1xuICAgIHB1YmxpYyBjbGVhcihrZXlzOiBzdHJpbmdbXSA9IG51bGwpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWxlTmFtZSBpbiB0aGlzLndhaXRJbWFnZXMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy53YWl0SW1hZ2VzLmhhc093blByb3BlcnR5KGZpbGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLndhaXRJbWFnZXNbZmlsZU5hbWVdO1xuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIGltYWdlLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FpdEltYWdlcyA9IHt9O1xuICAgICAgICBpZiAoa2V5cykge1xuICAgICAgICAgICAgY29uc3QgcGlja1ByZWRpY2F0ZSA9ICh2YWwsIGtleSkgPT4ga2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgICAgICAgICAgdGhpcy51cmlzID0gcGlja0J5KHRoaXMudXJpcywgcGlja1ByZWRpY2F0ZSk7XG4gICAgICAgICAgICB0aGlzLmltYWdlcyA9IHBpY2tCeSh0aGlzLmltYWdlcywgcGlja1ByZWRpY2F0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVyaXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YWl0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbiBJbWFnZSByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlTmFtZSBmaWxlTmFtZSBvZiB0aGUgaW1hZ2UgdG8gYmUgcmV0dXJuZWRcbiAgICAgKiBAcGFyYW0gc3VjY2VzcyBoYW5kbGVyIHRoYXQnbGwgYmUgY2FsbGVkIG9uIHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0gZXJyb3IgaGFuZGxlciB0aGF0J2xsIGJlIGNhbGxlZCBvbiBlcnJvclxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRJbWFnZShmaWxlTmFtZTogc3RyaW5nLCBzdWNjZXNzOiAoaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQpID0+IHZvaWQsIGVycm9yPzogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICBsZXQgaW1hZ2UgPSB0aGlzLmltYWdlc1tmaWxlTmFtZV07XG4gICAgICAgIGlmIChpbWFnZSkgeyAvLyBjaGVjayBpbiBjYWNoZVxuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzKGltYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxvYWQgZmlsZVxuICAgICAgICBjb25zdCB1cmkgPSB0aGlzLl9nZXRVcmkoZmlsZU5hbWUpO1xuICAgICAgICBpZiAoIXVyaSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBpbWFnZSBmaWxlIFwiICsgZmlsZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGlmICh1cmkuaW5kZXhPZihcImRhdGE6XCIpICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBhZGQgY3Jvc3Mgb3JpZ2luIGF0dHJpYnV0ZSBmb3JcbiAgICAgICAgICAgIC8vIHJlbW90ZSBpbWFnZXNcbiAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICAgICAgfVxuICAgICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy53YWl0SW1hZ2VzW2ZpbGVOYW1lXTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzW2ZpbGVOYW1lXSA9IGltYWdlO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzKGltYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xvYWRFbmQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBpbWFnZS5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndhaXRJbWFnZXNbZmlsZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gd2UgdHJlYXQgdGhpcyBsb2FkIGFzIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBoYW5kbGVkIHByb3Blcmx5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRFbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvYWRTdGFydCgpO1xuICAgICAgICBpbWFnZS5zcmMgPSB1cmk7XG4gICAgICAgIHRoaXMud2FpdEltYWdlc1tmaWxlTmFtZV0gPSBpbWFnZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2V0QXR0cmlidXRlKGtleTogc3RyaW5nLCB2YWx1ZTogYW55LCBvcHRpb25zOiBhbnkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJ1cmlzXCIpIHtcbiAgICAgICAgICAgIHRoaXMudXJpcyA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2dldFVyaShmaWxlTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgdXJpID0gdGhpcy51cmlzW2ZpbGVOYW1lXTtcbiAgICAgICAgaWYgKHVyaSkge1xuICAgICAgICAgICAgcmV0dXJuIHVyaTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5wYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgcGFjayA9IHRoaXMucGFja3NbaV07XG4gICAgICAgICAgICBpZiAocGFjay5maWxlTmFtZXMuaW5kZXhPZihmaWxlTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhY2sucHJlZml4ICsgZmlsZU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9sb2FkU3RhcnQoKSB7XG4gICAgICAgIHRoaXMud2FpdENvdW50Kys7XG4gICAgICAgIGlmICh0aGlzLndhaXRDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwid2FpdFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX2xvYWRFbmQoKSB7XG4gICAgICAgIHRoaXMud2FpdENvdW50LS07XG4gICAgICAgIGlmICh0aGlzLndhaXRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWFkeVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9SZXNvdXJjZU1hbmFnZXIudHMiLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGJhc2VQaWNrQnkgZnJvbSAnLi9fYmFzZVBpY2tCeS5qcyc7XG5pbXBvcnQgZ2V0QWxsS2V5c0luIGZyb20gJy4vX2dldEFsbEtleXNJbi5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJuc1xuICogdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBbcHJvcF07XG4gIH0pO1xuICBwcmVkaWNhdGUgPSBiYXNlSXRlcmF0ZWUocHJlZGljYXRlKTtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBpY2tCeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9waWNrQnkuanNcbi8vIG1vZHVsZSBpZCA9IDI4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBmbGF0TWFwIGZyb20gXCJsb2Rhc2gtZXMvZmxhdE1hcFwiO1xuaW1wb3J0IENvbXBvbmVudCwgeyBJQ29udGFpbmVyIH0gZnJvbSBcIi4uL0NvbXBvbmVudFwiO1xuaW1wb3J0IElNYWluIGZyb20gXCIuLi9JTWFpblwiO1xuaW1wb3J0IHsgV2ViR0xWYXJUeXBlIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5pbXBvcnQgUmVuZGVyaW5nQ29udGV4dCBmcm9tIFwiLi4vd2ViZ2wvUmVuZGVyaW5nQ29udGV4dFwiO1xuaW1wb3J0IFNoYWRlclByb2dyYW0gZnJvbSBcIi4uL3dlYmdsL1NoYWRlclByb2dyYW1cIjtcblxuLyoqXG4gKiBPcHRpb25zIGZvciBbW0NoYW5uZWxTaGlmdF1dIGNvbXBvbmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDaGFubmVsU2hpZnRPcHRzIHtcbiAgICAvKipcbiAgICAgKiBDaGFubmVsIHNoaWZ0IG1vZGUuIHNlZSBbW0NoYW5uZWxTaGlmdE1vZGVdXVxuICAgICAqL1xuICAgIGNoYW5uZWw6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBJZiBlbmFibGVkLCBjaGFubmVsIHNoaWZ0IG1vZGUgd2lsbCByYW5kb21pemUgb24gYmVhdFxuICAgICAqL1xuICAgIG9uQmVhdFJhbmRvbTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBDaGFubmVsIHNoaWZ0IG1vZGUgZm9yIFtbQ2hhbm5lbFNoaWZ0XV0gY29tcG9uZW50XG4gKi9cbmVudW0gQ2hhbm5lbFNoaWZ0TW9kZSB7XG4gICAgUkdCID0gMCxcbiAgICBSQkcsXG4gICAgQlJHLFxuICAgIEJHUixcbiAgICBHQlIsXG4gICAgR1JCLFxufVxuY29uc3QgU2hpZnRDaGFubmVsc0tleXMgPSBPYmplY3Qua2V5cyhDaGFubmVsU2hpZnRNb2RlKS5maWx0ZXIoKHMpID0+IGlzTmFOKHBhcnNlSW50KHMsIDEwKSkpO1xuXG4vKipcbiAqIEEgY29tcG9uZW50IHRoYXQgc3dpenpsZXMgdGhlIGNvbG9yIGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFubmVsU2hpZnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHB1YmxpYyBzdGF0aWMgY29tcG9uZW50TmFtZTogc3RyaW5nID0gXCJDaGFubmVsU2hpZnRcIjtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudFRhZzogc3RyaW5nID0gXCJ0cmFuc1wiO1xuICAgIHByb3RlY3RlZCBzdGF0aWMgb3B0VXBkYXRlSGFuZGxlcnMgPSB7XG4gICAgICAgIGNoYW5uZWw6IFwidXBkYXRlQ2hhbm5lbFwiLFxuICAgIH07XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkZWZhdWx0T3B0aW9uczogSUNoYW5uZWxTaGlmdE9wdHMgPSB7XG4gICAgICAgIGNoYW5uZWw6IFwiUkdCXCIsXG4gICAgICAgIG9uQmVhdFJhbmRvbTogZmFsc2UsXG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBvcHRzOiBJQ2hhbm5lbFNoaWZ0T3B0cztcbiAgICBwcml2YXRlIHByb2dyYW06IFNoYWRlclByb2dyYW07XG4gICAgcHJpdmF0ZSBjaGFubmVsOiBDaGFubmVsU2hpZnRNb2RlO1xuXG4gICAgY29uc3RydWN0b3IobWFpbjogSU1haW4sIHBhcmVudDogSUNvbnRhaW5lciwgb3B0czogYW55KSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHBhcmVudCwgb3B0cyk7XG4gICAgfVxuXG4gICAgcHVibGljIGluaXQoKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKHRoaXMubWFpbi5nZXRSY3R4KCksIHtcbiAgICAgICAgICAgIGJpbmRpbmdzOiB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogeyBuYW1lOiBcInVfY2hhbm5lbFwiLCB2YWx1ZVR5cGU6IFdlYkdMVmFyVHlwZS5fMUkgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBgXG4gICAgICAgICAgICAgICAgdW5pZm9ybSBpbnQgdV9jaGFubmVsO1xuICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVjMyBjb2xvciA9IGdldFNyY0NvbG9yKCkucmdiO1xuICAgICAgICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhdE1hcChTaGlmdENoYW5uZWxzS2V5cywgKGNoYW5uZWwpID0+IGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih1X2NoYW5uZWwgPT0gJHtDaGFubmVsU2hpZnRNb2RlW2NoYW5uZWxdfSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRGcmFnQ29sb3IodmVjNChjb2xvci4ke2NoYW5uZWwudG9Mb3dlckNhc2UoKX0sIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBgKS5qb2luKFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgLFxuICAgICAgICAgICAgc3dhcEZyYW1lOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVDaGFubmVsKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGRyYXcoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMub25CZWF0UmFuZG9tICYmIHRoaXMubWFpbi5nZXRBbmFseXNlcigpLmlzQmVhdCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBTaGlmdENoYW5uZWxzS2V5cy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvZ3JhbS5ydW4odGhpcy5wYXJlbnQuZ2V0VFNNKCksIHsgY2hhbm5lbDogdGhpcy5jaGFubmVsIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucHJvZ3JhbS5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVDaGFubmVsKCkge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBDaGFubmVsU2hpZnRNb2RlW3RoaXMub3B0cy5jaGFubmVsXTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdHJhbnMvQ2hhbm5lbFNoaWZ0LnRzIiwiaW1wb3J0IGJhc2VGbGF0dGVuIGZyb20gJy4vX2Jhc2VGbGF0dGVuLmpzJztcbmltcG9ydCBtYXAgZnJvbSAnLi9tYXAuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmbGF0dGVuZWQgYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYFxuICogdGhydSBgaXRlcmF0ZWVgIGFuZCBmbGF0dGVuaW5nIHRoZSBtYXBwZWQgcmVzdWx0cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICogICByZXR1cm4gW24sIG5dO1xuICogfVxuICpcbiAqIF8uZmxhdE1hcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAqL1xuZnVuY3Rpb24gZmxhdE1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgMSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZsYXRNYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZmxhdE1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMjg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IENvbXBvbmVudCwgeyBJQ29udGFpbmVyIH0gZnJvbSBcIi4uL0NvbXBvbmVudFwiO1xuaW1wb3J0IElNYWluIGZyb20gXCIuLi9JTWFpblwiO1xuaW1wb3J0IHsgQ29sb3IsIHBhcnNlQ29sb3JOb3JtLCBXZWJHTFZhclR5cGUgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCBSZW5kZXJpbmdDb250ZXh0IGZyb20gXCIuLi93ZWJnbC9SZW5kZXJpbmdDb250ZXh0XCI7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tIFwiLi4vd2ViZ2wvU2hhZGVyUHJvZ3JhbVwiO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHRoZSBbW0NvbG9yQ2xpcF1dIGNvbXBvbmVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDb2xvckNsaXBPcHRzIHtcbiAgICAvKipcbiAgICAgKiBDbGlwcGluZyBtb2RlLiBzZWUgW1tDb2xvckNsaXBNb2RlXV1cbiAgICAgKi9cbiAgICBtb2RlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQ2xpcCBDb2xvclxuICAgICAqL1xuICAgIGNvbG9yOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogT3V0cHV0IGNvbG9yXG4gICAgICovXG4gICAgb3V0Q29sb3I6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBkaXN0YW5jZSB2YWx1ZSB3aGVuIG1vZGUgaXMgYE5FQVJgXG4gICAgICovXG4gICAgbGV2ZWw6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDbGlwcGluZyBtb2RlciBmb3IgdGhlIFtbQ29sb3JDbGlwXV0gY29tcG9uZW50XG4gKi9cbmVudW0gQ29sb3JDbGlwTW9kZSB7XG4gICAgQkVMT1cgPSAwLFxuICAgIEFCT1ZFLFxuICAgIE5FQVIsXG59XG5cbi8qKlxuICogQSBjb21wb25lbnQgdGhhdCBjbGlwcyBjb2xvcnMgdG8gYSBkaWZmZXJlbnQgY29sb3IgZGVwZW5kaW5nXG4gKiBvbiB3aGV0aGVyIHRoZSBzb3VyY2UgY29sb3JzIGFyZSBhYm92ZSBvciBiZWxvdyBhIHJlZmVyZW5jZSBjb2xvci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sb3JDbGlwIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudE5hbWU6IHN0cmluZyA9IFwiQ29sb3JDbGlwXCI7XG4gICAgcHVibGljIHN0YXRpYyBjb21wb25lbnRUYWc6IHN0cmluZyA9IFwidHJhbnNcIjtcbiAgICBwcm90ZWN0ZWQgc3RhdGljIG9wdFVwZGF0ZUhhbmRsZXJzID0ge1xuICAgICAgICBjb2xvcjogXCJ1cGRhdGVDb2xvclwiLFxuICAgICAgICBtb2RlOiBcInVwZGF0ZU1vZGVcIixcbiAgICAgICAgb3V0Q29sb3I6IFwidXBkYXRlQ29sb3JcIixcbiAgICB9O1xuICAgIHByb3RlY3RlZCBzdGF0aWMgZGVmYXVsdE9wdGlvbnM6IElDb2xvckNsaXBPcHRzID0ge1xuICAgICAgICBjb2xvcjogXCIjMjAyMDIwXCIsXG4gICAgICAgIGxldmVsOiAwLFxuICAgICAgICBtb2RlOiBcIkJFTE9XXCIsXG4gICAgICAgIG91dENvbG9yOiBcIiMyMDIwMjBcIixcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIG9wdHM6IElDb2xvckNsaXBPcHRzO1xuICAgIHByaXZhdGUgcHJvZ3JhbTogU2hhZGVyUHJvZ3JhbTtcbiAgICBwcml2YXRlIG1vZGU6IENvbG9yQ2xpcE1vZGU7XG4gICAgcHJpdmF0ZSBjb2xvcjogQ29sb3I7XG4gICAgcHJpdmF0ZSBvdXRDb2xvcjogQ29sb3I7XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluOiBJTWFpbiwgcGFyZW50OiBJQ29udGFpbmVyLCBvcHRzOiBhbnkpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgcGFyZW50LCBvcHRzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbmV3IFNoYWRlclByb2dyYW0odGhpcy5tYWluLmdldFJjdHgoKSwge1xuICAgICAgICAgICAgYmluZGluZ3M6IHtcbiAgICAgICAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogICAgeyBuYW1lOiBcInVfY29sb3JcIiwgdmFsdWVUeXBlOiBXZWJHTFZhclR5cGUuXzNGViB9LFxuICAgICAgICAgICAgICAgICAgICBsZXZlbDogICAgeyBuYW1lOiBcInVfbGV2ZWxcIiwgdmFsdWVUeXBlOiBXZWJHTFZhclR5cGUuXzFGIH0sXG4gICAgICAgICAgICAgICAgICAgIG1vZGU6ICAgICB7IG5hbWU6IFwidV9tb2RlXCIsIHZhbHVlVHlwZTogV2ViR0xWYXJUeXBlLl8xSSB9LFxuICAgICAgICAgICAgICAgICAgICBvdXRDb2xvcjogeyBuYW1lOiBcInVfb3V0Q29sb3JcIiwgdmFsdWVUeXBlOiBXZWJHTFZhclR5cGUuXzNGViB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGBcbiAgICAgICAgICAgICAgICB1bmlmb3JtIGludCB1X21vZGU7XG4gICAgICAgICAgICAgICAgdW5pZm9ybSB2ZWMzIHVfY29sb3I7XG4gICAgICAgICAgICAgICAgdW5pZm9ybSB2ZWMzIHVfb3V0Q29sb3I7XG4gICAgICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB1X2xldmVsO1xuXG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgIHZlYzQgaW5Db2xvcjQgPSBnZXRTcmNDb2xvcigpO1xuICAgICAgICAgICAgICAgICAgIHZlYzMgaW5Db2xvciA9IGluQ29sb3I0LnJnYjtcbiAgICAgICAgICAgICAgICAgICBib29sIGNsaXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICBpZih1X21vZGUgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpcCA9IGFsbChsZXNzVGhhbkVxdWFsKGluQ29sb3IsIHVfY29sb3IpKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgaWYodV9tb2RlID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaXAgPSBhbGwoZ3JlYXRlclRoYW5FcXVhbChpbkNvbG9yLCB1X2NvbG9yKSk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIGlmKHVfbW9kZSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwID0gKGRpc3RhbmNlKGluQ29sb3IsIHVfY29sb3IpIDw9IHVfbGV2ZWwqMC41KTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgaWYoY2xpcCkge1xuICAgICAgICAgICAgICAgICAgICAgICBzZXRGcmFnQ29sb3IodmVjNCh1X291dENvbG9yLCBpbkNvbG9yNC5hKSk7XG4gICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgc2V0RnJhZ0NvbG9yKGluQ29sb3I0KTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYCxcbiAgICAgICAgICAgIHN3YXBGcmFtZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlQ29sb3IoKTtcbiAgICAgICAgdGhpcy51cGRhdGVNb2RlKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGRyYXcoKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbS5ydW4oXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5nZXRUU00oKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICAgICAgICBsZXZlbDogdGhpcy5vcHRzLmxldmVsLFxuICAgICAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICAgICAgICBvdXRDb2xvcjogdGhpcy5vdXRDb2xvcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZU1vZGUoKSB7XG4gICAgICAgIHRoaXMubW9kZSA9IENvbG9yQ2xpcE1vZGVbdGhpcy5vcHRzLm1vZGVdO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlQ29sb3IoKSB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBwYXJzZUNvbG9yTm9ybSh0aGlzLm9wdHMuY29sb3IpO1xuICAgICAgICB0aGlzLm91dENvbG9yID0gcGFyc2VDb2xvck5vcm0odGhpcy5vcHRzLm91dENvbG9yKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdHJhbnMvQ29sb3JDbGlwLnRzIiwiaW1wb3J0IGVhY2ggZnJvbSBcImxvZGFzaC1lcy9lYWNoXCI7XG5pbXBvcnQgZmlsdGVyIGZyb20gXCJsb2Rhc2gtZXMvZmlsdGVyXCI7XG5pbXBvcnQgZmlyc3QgZnJvbSBcImxvZGFzaC1lcy9maXJzdFwiO1xuaW1wb3J0IGxhc3QgZnJvbSBcImxvZGFzaC1lcy9sYXN0XCI7XG5pbXBvcnQgbWFwIGZyb20gXCJsb2Rhc2gtZXMvbWFwXCI7XG5pbXBvcnQgc29ydEJ5IGZyb20gXCJsb2Rhc2gtZXMvc29ydEJ5XCI7XG5pbXBvcnQgdGFrZSBmcm9tIFwibG9kYXNoLWVzL3Rha2VcIjtcbmltcG9ydCB0YWtlUmlnaHQgZnJvbSBcImxvZGFzaC1lcy90YWtlUmlnaHRcIjtcbmltcG9ydCB0aW1lcyBmcm9tIFwibG9kYXNoLWVzL3RpbWVzXCI7XG5pbXBvcnQgdW5pcSBmcm9tIFwibG9kYXNoLWVzL3VuaXFcIjtcbmltcG9ydCB6aXAgZnJvbSBcImxvZGFzaC1lcy96aXBcIjtcbmltcG9ydCBDb21wb25lbnQsIHsgSUNvbnRhaW5lciB9IGZyb20gXCIuLi9Db21wb25lbnRcIjtcbmltcG9ydCBJTWFpbiBmcm9tIFwiLi4vSU1haW5cIjtcbmltcG9ydCB7IEJsZW5kTW9kZSwgQ29sb3IsIHBhcnNlQ29sb3IsIFdlYkdMVmFyVHlwZSB9IGZyb20gXCIuLi91dGlsc1wiO1xuaW1wb3J0IFJlbmRlcmluZ0NvbnRleHQgZnJvbSBcIi4uL3dlYmdsL1JlbmRlcmluZ0NvbnRleHRcIjtcbmltcG9ydCBTaGFkZXJQcm9ncmFtIGZyb20gXCIuLi93ZWJnbC9TaGFkZXJQcm9ncmFtXCI7XG5cbi8qKlxuICogQ29sb3IgTWFwIEl0ZW0gZm9yIFtbSUNvbG9yTWFwRGVmXV1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJQ29sb3JNYXBJdGVtIHtcbiAgICBwb3NpdGlvbjogbnVtYmVyO1xuICAgIGNvbG9yOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBzaW5nbGUgQ29sb3IgTWFwIChhIGxpc3Qgb2YgY29sb3JzIHdpdGggcG9zaXRpb24pIGZvciBbW0ljb2xvck1hcE9wdHNdXVxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDb2xvck1hcERlZiB7XG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSB0aGUgY29sb3IgbWFwIGNhbiBiZSBjaG9zZW4gdGhyb3VnaCBvbmUgb2YgdGhlXG4gICAgICogW1tDb2xvck1hcEN5Y2xlTW9kZV1dcy5cbiAgICAgKi9cbiAgICBlbmFibGVkOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIENvbG9ycyBhbmQgdGhlaXIgcG9zaXRpb24gaW4gdGhlIFtbQ29sb3JNYXBLZXldXSBzcGFjZVxuICAgICAqL1xuICAgIGNvbG9yczogSUNvbG9yTWFwSXRlbVtdO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIFtbQ29sb3JNYXBdXSBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJQ29sb3JNYXBPcHRzIHtcbiAgICAvKipcbiAgICAgKiBLZXkgYnkgd2hpY2ggY29sb3Igc2hvdWxkIGJlIG1hcHBlZC4gc2VlIFtbQ29sb3JNYXBLZXldXVxuICAgICAqL1xuICAgIGtleTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIE91dHB1dCBibGVuZGluZyBtb2RlLiBzZWUgW1tCbGVuZE1vZGVdXVxuICAgICAqL1xuICAgIG91dHB1dDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIENvbG9yIG1hcCBjeWNsaW5nIG1vZGUuIHNlZSBbW0NvbG9yTWFwQ3ljbGVNb2RlXV1cbiAgICAgKi9cbiAgICBtYXBDeWNsZU1vZGU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDb2xvciBtYXAgaXRlbXNcbiAgICAgKi9cbiAgICBtYXBzOiBJQ29sb3JNYXBEZWZbXTtcbn1cblxuLyoqXG4gKiBDb2xvciBtYXBwaW5nIGtleSBmb3IgW1tDb2xvck1hcF1dIGNvbXBvbmVudFxuICovXG5lbnVtIENvbG9yTWFwS2V5IHtcbiAgICBSRUQgPSAwLFxuICAgIEdSRUVOLFxuICAgIEJMVUUsXG4gICAgXCIoUitHK0IpLzJcIixcbiAgICBcIihSK0crQikvM1wiLFxuICAgIE1BWCxcbn1cblxuLyoqXG4gKiBDb2xvciBtYXAgY3ljbGluZyBtb2RlcyBmb3IgW1tDb2xvck1hcF1dIGNvbXBvbmVudFxuICovXG5lbnVtIENvbG9yTWFwQ3ljbGVNb2RlIHtcbiAgICBTSU5HTEUgPSAwLFxuICAgIE9OQkVBVFJBTkRPTSxcbiAgICBPTkJFQVRTRVFVRU5USUFMLFxufVxuXG4vKipcbiAqIEEgY29tcG9uZW50IHRoYXQgY2hhbmdlcyBjb2xvcnMgYWNjb3JkaW5nIHRvIGEgZ3JhZGllbnQgbWFwIHVzaW5nXG4gKiBhIGtleSBnZW5lcmF0ZWQgZnJvbSB0aGUgc291cmNlIGNvbG9yc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvck1hcCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgcHVibGljIHN0YXRpYyBjb21wb25lbnROYW1lOiBzdHJpbmcgPSBcIkNvbG9yTWFwXCI7XG4gICAgcHVibGljIHN0YXRpYyBjb21wb25lbnRUYWc6IHN0cmluZyA9IFwidHJhbnNcIjtcbiAgICBwcm90ZWN0ZWQgc3RhdGljIG9wdFVwZGF0ZUhhbmRsZXJzID0ge1xuICAgICAgICBrZXk6IFwidXBkYXRlS2V5XCIsXG4gICAgICAgIG1hcEN5Y2xlTW9kZTogXCJ1cGRhdGVDeWNsZU1vZGVcIixcbiAgICAgICAgbWFwczogXCJ1cGRhdGVNYXBcIixcbiAgICAgICAgb3V0cHV0OiBcInVwZGF0ZUJsZW5kTW9kZVwiLFxuICAgIH07XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkZWZhdWx0T3B0aW9uczogSUNvbG9yTWFwT3B0cyA9IHtcbiAgICAgICAga2V5OiBcIlJFRFwiLFxuICAgICAgICBtYXBDeWNsZU1vZGU6IFwiU0lOR0xFXCIsXG4gICAgICAgIG1hcHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbG9yczogW1xuICAgICAgICAgICAgICAgICAgICB7cG9zaXRpb246IDAsIGNvbG9yOiBcIiMwMDAwMDBcIn0sXG4gICAgICAgICAgICAgICAgICAgIHtwb3NpdGlvbjogMjU1LCBjb2xvcjogXCIjRkZGRkZGXCJ9LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0OiBcIlJFUExBQ0VcIixcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIG9wdHM6IElDb2xvck1hcE9wdHM7XG4gICAgcHJpdmF0ZSBwcm9ncmFtOiBTaGFkZXJQcm9ncmFtO1xuICAgIHByaXZhdGUgbWFwQ3ljbGVNb2RlOiBDb2xvck1hcEN5Y2xlTW9kZTtcbiAgICBwcml2YXRlIGN1cnJlbnRNYXA6IENvbG9yTWFwS2V5O1xuICAgIHByaXZhdGUgY29sb3JNYXBzOiBXZWJHTFRleHR1cmVbXTtcbiAgICBwcml2YXRlIGJsZW5kTW9kZTogQmxlbmRNb2RlO1xuICAgIHByaXZhdGUga2V5OiBDb2xvck1hcEtleTtcblxuICAgIGNvbnN0cnVjdG9yKG1haW46IElNYWluLCBwYXJlbnQ6IElDb250YWluZXIsIG9wdHM6IGFueSkge1xuICAgICAgICBzdXBlcihtYWluLCBwYXJlbnQsIG9wdHMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbml0KCkge1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbSh0aGlzLm1haW4uZ2V0UmN0eCgpLCB7XG4gICAgICAgICAgICBiaW5kaW5nczoge1xuICAgICAgICAgICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yTWFwOiB7IG5hbWU6IFwidV9jb2xvck1hcFwiLCB2YWx1ZVR5cGU6IFdlYkdMVmFyVHlwZS5URVhUVVJFMkQgfSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiAgICAgIHsgbmFtZTogXCJ1X2tleVwiLCB2YWx1ZVR5cGU6IFdlYkdMVmFyVHlwZS5fMUkgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR5bmFtaWNCbGVuZDogdHJ1ZSxcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBgXG4gICAgICAgICAgICAgICAgdW5pZm9ybSBpbnQgdV9rZXk7XG4gICAgICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9jb2xvck1hcDtcbiAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgdmVjNCBzcmNDb2xvciA9IGdldFNyY0NvbG9yKCk7XG4gICAgICAgICAgICAgICAgICAgZmxvYXQga2V5O1xuICAgICAgICAgICAgICAgICAgIGlmKHVfa2V5ID09ICR7Q29sb3JNYXBLZXkuUkVEfSAgICAgICAgICApIHsga2V5ID0gc3JjQ29sb3IucjsgfVxuICAgICAgICAgICAgICAgICAgIGlmKHVfa2V5ID09ICR7Q29sb3JNYXBLZXkuR1JFRU59ICAgICAgICApIHsga2V5ID0gc3JjQ29sb3IuZzsgfVxuICAgICAgICAgICAgICAgICAgIGlmKHVfa2V5ID09ICR7Q29sb3JNYXBLZXkuQkxVRX0gICAgICAgICApIHsga2V5ID0gc3JjQ29sb3IuYjsgfVxuICAgICAgICAgICAgICAgICAgIGlmKHVfa2V5ID09ICR7Q29sb3JNYXBLZXlbXCIoUitHK0IpLzJcIl19ICkgeyBrZXkgPSBtaW4oKHNyY0NvbG9yLnIrc3JjQ29sb3IuZytzcmNDb2xvci5iKS8yLjAsIDEuMCk7IH1cbiAgICAgICAgICAgICAgICAgICBpZih1X2tleSA9PSAke0NvbG9yTWFwS2V5W1wiKFIrRytCKS8zXCJdfSApIHsga2V5ID0gKHNyY0NvbG9yLnIrc3JjQ29sb3IuZytzcmNDb2xvci5iKS8zLjA7IH1cbiAgICAgICAgICAgICAgICAgICBpZih1X2tleSA9PSAke0NvbG9yTWFwS2V5Lk1BWH0gICAgICAgICAgKSB7IGtleSA9IG1heChzcmNDb2xvci5yLCBtYXgoc3JjQ29sb3IuZywgc3JjQ29sb3IuYikpOyB9XG4gICAgICAgICAgICAgICAgICAgc2V0RnJhZ0NvbG9yKHRleHR1cmUyRCh1X2NvbG9yTWFwLCB2ZWMyKGtleSwgMCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgLFxuICAgICAgICAgICAgc3dhcEZyYW1lOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVNYXAoKTtcbiAgICAgICAgdGhpcy51cGRhdGVLZXkoKTtcbiAgICAgICAgdGhpcy51cGRhdGVDeWNsZU1vZGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVCbGVuZE1vZGUoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZHJhdygpIHtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5nZXRBbmFseXNlcigpLmlzQmVhdCgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXBDeWNsZU1vZGUgPT09ICBDb2xvck1hcEN5Y2xlTW9kZS5PTkJFQVRSQU5ET00pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNYXAgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLm9wdHMubWFwcy5sZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1hcEN5Y2xlTW9kZSA9PT0gQ29sb3JNYXBDeWNsZU1vZGUuT05CRUFUU0VRVUVOVElBTCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1hcCA9ICh0aGlzLmN1cnJlbnRNYXAgKyAxKSAlIHRoaXMuY29sb3JNYXBzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2dyYW0ucnVuKFxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZ2V0VFNNKCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sb3JNYXA6IHRoaXMuY29sb3JNYXBzW3RoaXMuY3VycmVudE1hcF0sXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLmJsZW5kTW9kZSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnByb2dyYW0uZGVzdHJveSgpO1xuICAgICAgICBlYWNoKHRoaXMuY29sb3JNYXBzLCAodGV4KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1haW4uZ2V0UmN0eCgpLmdldEdsKCkuZGVsZXRlVGV4dHVyZSh0ZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZU1hcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sb3JNYXBzKSB7XG4gICAgICAgICAgICBlYWNoKHRoaXMuY29sb3JNYXBzLCAodGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWluLmdldFJjdHgoKS5nZXRHbCgpLmRlbGV0ZVRleHR1cmUodGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sb3JNYXBzID0gbWFwKGZpbHRlcih0aGlzLm9wdHMubWFwcywgXCJlbmFibGVkXCIpLCAoY29sb3JNYXApID0+IHRoaXMuX2J1aWxkQ29sb3JNYXAoY29sb3JNYXAuY29sb3JzKSk7XG4gICAgICAgIHRoaXMuY3VycmVudE1hcCA9IDA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVDeWNsZU1vZGUoKSB7XG4gICAgICAgIHRoaXMubWFwQ3ljbGVNb2RlID0gQ29sb3JNYXBDeWNsZU1vZGVbdGhpcy5vcHRzLm1hcEN5Y2xlTW9kZV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVLZXkoKSB7XG4gICAgICAgIHRoaXMua2V5ID0gQ29sb3JNYXBLZXlbdGhpcy5vcHRzLmtleV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVCbGVuZE1vZGUoKSB7XG4gICAgICAgIHRoaXMuYmxlbmRNb2RlID0gQmxlbmRNb2RlW3RoaXMub3B0cy5vdXRwdXRdO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2J1aWxkQ29sb3JNYXAobWFwSXRlbXM6IElDb2xvck1hcEl0ZW1bXSk6IFdlYkdMVGV4dHVyZSB7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5tYWluLmdldFJjdHgoKS5nZXRHbCgpO1xuICAgICAgICBtYXBJdGVtcyA9IHNvcnRCeShtYXBJdGVtcywgKG1hcEl0ZW0pID0+IG1hcEl0ZW0ucG9zaXRpb24pO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciByZXBlYXRlZCBwb3NpdGlvbnNcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gbWFwKG1hcEl0ZW1zLCAobWFwSXRlbSkgPT4gbWFwSXRlbS5wb3NpdGlvbik7XG4gICAgICAgIGlmICh1bmlxKHBvc2l0aW9ucykubGVuZ3RoICE9PSBwb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXAgY2Fubm90IGhhdmUgcmVwZWF0ZWQgcG9zaXRpb25zXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFyc2UgYWxsIHRoZSBjb2xvcnNcbiAgICAgICAgY29uc3QgcGFyc2VkTWFwID0gbWFwKG1hcEl0ZW1zLCAobWFwSXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBwYXJzZUNvbG9yKG1hcEl0ZW0uY29sb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtjb2xvciwgcG9zaXRpb246IG1hcEl0ZW0ucG9zaXRpb259O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhZGQgYSBjYXAgZW50cmllcyBhdCB0aGUgZW5kc1xuICAgICAgICBjb25zdCBmaXJzdE1hcCA9IGZpcnN0KHBhcnNlZE1hcCk7XG4gICAgICAgIGlmIChmaXJzdE1hcC5wb3NpdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgcGFyc2VkTWFwLnNwbGljZSgwLCAwLCB7Y29sb3I6IGZpcnN0TWFwLmNvbG9yLCBwb3NpdGlvbjogMH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3RNYXAgPSBsYXN0KHBhcnNlZE1hcCk7XG4gICAgICAgIGlmIChsYXN0TWFwLnBvc2l0aW9uICE9PSAyNTUpIHtcbiAgICAgICAgICAgIHBhcnNlZE1hcC5wdXNoKHtjb2xvcjogbGFzdE1hcC5jb2xvciwgcG9zaXRpb246IDI1NX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVycCBpbnRlcm1lZGlhdGUgdmFsdWVzXG4gICAgICAgIGNvbnN0IGNvbG9yTWFwID0gbmV3IFVpbnQ4QXJyYXkoMjU2ICogMyk7XG4gICAgICAgIGxldCBjbWkgPSAwO1xuICAgICAgICBjb25zdCBwYWlycyA9IHppcCh0YWtlKHBhcnNlZE1hcCwgcGFyc2VkTWFwLmxlbmd0aCAtIDEpLCB0YWtlUmlnaHQocGFyc2VkTWFwLCBwYXJzZWRNYXAubGVuZ3RoIC0gMSkpO1xuICAgICAgICBlYWNoKHBhaXJzLCAocGFpcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RJdGVtID0gcGFpclswXTtcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZEl0ZW0gPSBwYWlyWzFdO1xuICAgICAgICAgICAgY29uc3Qgc3RlcHMgPSBzZWNvbmRJdGVtLnBvc2l0aW9uIC0gZmlyc3RJdGVtLnBvc2l0aW9uO1xuICAgICAgICAgICAgdGltZXMoc3RlcHMsIChpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29sb3JNYXBbY21pKytdID0gTWF0aC5mbG9vcigoZmlyc3RJdGVtLmNvbG9yWzBdICogKHN0ZXBzIC0gaSkgKyBzZWNvbmRJdGVtLmNvbG9yWzBdICogaSkgLyBzdGVwcyk7XG4gICAgICAgICAgICAgICAgY29sb3JNYXBbY21pKytdID0gTWF0aC5mbG9vcigoZmlyc3RJdGVtLmNvbG9yWzFdICogKHN0ZXBzIC0gaSkgKyBzZWNvbmRJdGVtLmNvbG9yWzFdICogaSkgLyBzdGVwcyk7XG4gICAgICAgICAgICAgICAgY29sb3JNYXBbY21pKytdID0gTWF0aC5mbG9vcigoZmlyc3RJdGVtLmNvbG9yWzJdICogKHN0ZXBzIC0gaSkgKyBzZWNvbmRJdGVtLmNvbG9yWzJdICogaSkgLyBzdGVwcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbG9yTWFwW2NtaSsrXSA9IGxhc3RNYXAuY29sb3JbMF07XG4gICAgICAgIGNvbG9yTWFwW2NtaSsrXSA9IGxhc3RNYXAuY29sb3JbMV07XG4gICAgICAgIGNvbG9yTWFwW2NtaSsrXSA9IGxhc3RNYXAuY29sb3JbMl07XG5cbiAgICAgICAgLy8gcHV0IHRoZSBjb2xvciB2YWx1ZXMgaW50byBhIDI1NngxIHRleHR1cmVcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCLCAyNTYsIDEsIDAsIGdsLlJHQiwgZ2wuVU5TSUdORURfQllURSwgY29sb3JNYXApO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdHJhbnMvQ29sb3JNYXAudHMiLCJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSAnLi9oZWFkLmpzJ1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2ZpcnN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAYWxpYXMgZmlyc3RcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5oZWFkKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAxXG4gKlxuICogXy5oZWFkKFtdKTtcbiAqIC8vID0+IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBoZWFkKGFycmF5KSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoZWFkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2hlYWQuanNcbi8vIG1vZHVsZSBpZCA9IDI4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBiYXNlRmxhdHRlbiBmcm9tICcuL19iYXNlRmxhdHRlbi5qcyc7XG5pbXBvcnQgYmFzZU9yZGVyQnkgZnJvbSAnLi9fYmFzZU9yZGVyQnkuanMnO1xuaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCBpc0l0ZXJhdGVlQ2FsbCBmcm9tICcuL19pc0l0ZXJhdGVlQ2FsbC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICogXTtcbiAqXG4gKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF0sIFsnZnJlZCcsIDQ4XV1cbiAqL1xudmFyIHNvcnRCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICBpdGVyYXRlZXMgPSBbXTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gIH1cbiAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzb3J0Qnk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc29ydEJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAyOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGJhc2VNYXAgZnJvbSAnLi9fYmFzZU1hcC5qcyc7XG5pbXBvcnQgYmFzZVNvcnRCeSBmcm9tICcuL19iYXNlU29ydEJ5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBjb21wYXJlTXVsdGlwbGUgZnJvbSAnLi9fY29tcGFyZU11bHRpcGxlLmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcy5sZW5ndGggPyBpdGVyYXRlZXMgOiBbaWRlbnRpdHldLCBiYXNlVW5hcnkoYmFzZUl0ZXJhdGVlKSk7XG5cbiAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gIH0pO1xuXG4gIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VPcmRlckJ5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlT3JkZXJCeS5qc1xuLy8gbW9kdWxlIGlkID0gMjkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gKiB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNvcnRCeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNvcnRCeS5qc1xuLy8gbW9kdWxlIGlkID0gMjkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGNvbXBhcmVBc2NlbmRpbmcgZnJvbSAnLi9fY29tcGFyZUFzY2VuZGluZy5qcyc7XG5cbi8qKlxuICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAqXG4gKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgfVxuICB9XG4gIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBhcmVNdWx0aXBsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29tcGFyZU11bHRpcGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKlxuICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29tcGFyZUFzY2VuZGluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29tcGFyZUFzY2VuZGluZy5qc1xuLy8gbW9kdWxlIGlkID0gMjk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCB1bnppcCBmcm9tICcuL3VuemlwLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAqIGZpcnN0IGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gKiBzZWNvbmQgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICovXG52YXIgemlwID0gYmFzZVJlc3QodW56aXApO1xuXG5leHBvcnQgZGVmYXVsdCB6aXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvemlwLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgYXJyYXlGaWx0ZXIgZnJvbSAnLi9fYXJyYXlGaWx0ZXIuanMnO1xuaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBiYXNlUHJvcGVydHkgZnJvbSAnLi9fYmFzZVByb3BlcnR5LmpzJztcbmltcG9ydCBiYXNlVGltZXMgZnJvbSAnLi9fYmFzZVRpbWVzLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZU9iamVjdCBmcm9tICcuL2lzQXJyYXlMaWtlT2JqZWN0LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIGdyb3VwZWRcbiAqIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGFuIGFycmF5IHJlZ3JvdXBpbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZS16aXBcbiAqIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjIuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgemlwcGVkID0gXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICpcbiAqIF8udW56aXAoemlwcGVkKTtcbiAqIC8vID0+IFtbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV1dXG4gKi9cbmZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XG4gIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGxlbmd0aCA9IDA7XG4gIGFycmF5ID0gYXJyYXlGaWx0ZXIoYXJyYXksIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGdyb3VwKSkge1xuICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBiYXNlVGltZXMobGVuZ3RoLCBmdW5jdGlvbihpbmRleCkge1xuICAgIHJldHVybiBhcnJheU1hcChhcnJheSwgYmFzZVByb3BlcnR5KGluZGV4KSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCB1bnppcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy91bnppcC5qc1xuLy8gbW9kdWxlIGlkID0gMjk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiaW1wb3J0IGlzQXJyYXkgZnJvbSBcImxvZGFzaC1lcy9pc0FycmF5XCI7XG5pbXBvcnQgcmVkdWNlIGZyb20gXCJsb2Rhc2gtZXMvcmVkdWNlXCI7XG5pbXBvcnQgQ29tcG9uZW50LCB7IElDb250YWluZXIgfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG5pbXBvcnQgSU1haW4gZnJvbSBcIi4uL0lNYWluXCI7XG5pbXBvcnQgeyBnbHNsRmxvYXRSZXByLCBXZWJHTFZhclR5cGUgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCBSZW5kZXJpbmdDb250ZXh0IGZyb20gXCIuLi93ZWJnbC9SZW5kZXJpbmdDb250ZXh0XCI7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tIFwiLi4vd2ViZ2wvU2hhZGVyUHJvZ3JhbVwiO1xuXG4vKipcbiAqIEVkZ2UgaGFuZGxpbmcgbW9kZXMgZm9yIFtbQ29udm9sdXRpb25dXSBjb21wb25lbnRcbiAqL1xuZW51bSBDb252RWRnZU1vZGUge1xuICAgIC8qKlxuICAgICAqIEV4dGVuZCBlZGdlIHZhbHVlIGJleW9uZCBlZGdlXG4gICAgICovXG4gICAgRVhURU5EID0gMCxcbiAgICAvKipcbiAgICAgKiBXcmFwIGFyb3VuZCB0byBvcHBvc2l0ZSBlZGdlXG4gICAgICovXG4gICAgV1JBUCxcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBbW0NvbnZvbHV0aW9uXV0gY29tcG9uZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNvbnZvbHV0aW9uT3B0cyB7XG4gICAgLyoqXG4gICAgICogRWRnZSBoYW5kbGluZSBtb2RlLiBzZWUgW1tDb252RWRnZU1vZGVdXS5cbiAgICAgKiBEZWZhdWx0OiBgRVhURU5EYFxuICAgICAqL1xuICAgIGVkZ2VNb2RlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljYWxseSBjb21wdXRlIHNjYWxlIHZhbHVlLiBEZWZhdWx0OiBgdHJ1ZWBcbiAgICAgKi9cbiAgICBhdXRvU2NhbGU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2NhbGUgZm9yIGNvbnZvbHV0aW9uLiBEZWZhdWx0OiAwXG4gICAgICovXG4gICAgc2NhbGU6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiAyRCBNYXRyaXggd2l0aCBjb252b2x1dGlvbiBrZXJuZWwuIERlZmF1bHQ6IGBbMCwwLDAgMCwxLDAsIDAsMCwwXWBcbiAgICAgKi9cbiAgICBrZXJuZWw6IG51bWJlcltdO1xuICAgIC8qKlxuICAgICAqIENvbnZvbHV0aW9uIGJpYXMgdmFsdWUuIERlZmF1bHQ6IDBcbiAgICAgKi9cbiAgICBiaWFzOiBudW1iZXI7XG59XG5cbi8qKlxuICogQSBjb21wb25lbnQgdGhhdCBhcHBsaWVzIGEgY29udm9sdXRpb24ga2VybmVsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnZvbHV0aW9uIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudE5hbWU6IHN0cmluZyA9IFwiQ29udm9sdXRpb25cIjtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudFRhZzogc3RyaW5nID0gXCJ0cmFuc1wiO1xuICAgIHByb3RlY3RlZCBzdGF0aWMgb3B0VXBkYXRlSGFuZGxlcnMgPSB7XG4gICAgICAgIGVkZ2VNb2RlOiBcInVwZGF0ZVByb2dyYW1cIixcbiAgICAgICAga2VybmVsOiBbXCJ1cGRhdGVQcm9ncmFtXCIsIFwidXBkYXRlU2NhbGVcIl0sXG4gICAgICAgIHNjYWxlOiBcInVwZGF0ZVNjYWxlXCIsXG4gICAgfTtcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlZmF1bHRPcHRpb25zOiBJQ29udm9sdXRpb25PcHRzID0ge1xuICAgICAgICBhdXRvU2NhbGU6IHRydWUsXG4gICAgICAgIGJpYXM6IDAsXG4gICAgICAgIGVkZ2VNb2RlOiBcIkVYVEVORFwiLFxuICAgICAgICBrZXJuZWw6IFtcbiAgICAgICAgICAgIDAsIDAsIDAsXG4gICAgICAgICAgICAwLCAxLCAwLFxuICAgICAgICAgICAgMCwgMCwgMCxcbiAgICAgICAgXSxcbiAgICAgICAgc2NhbGU6IDAsXG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBvcHRzOiBJQ29udm9sdXRpb25PcHRzO1xuICAgIHByaXZhdGUgcHJvZ3JhbTogU2hhZGVyUHJvZ3JhbTtcbiAgICBwcml2YXRlIHNjYWxlOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluOiBJTWFpbiwgcGFyZW50OiBJQ29udGFpbmVyLCBvcHRzOiBhbnkpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgcGFyZW50LCBvcHRzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaW5pdCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9ncmFtKCk7XG4gICAgICAgIHRoaXMudXBkYXRlU2NhbGUoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZHJhdygpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtLnJ1bih0aGlzLnBhcmVudC5nZXRUU00oKSwgeyBzY2FsZTogdGhpcy5zY2FsZSwgYmlhczogdGhpcy5vcHRzLmJpYXMgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVNjYWxlKCkge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICBpZiAob3B0cy5hdXRvU2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSByZWR1Y2Uob3B0cy5rZXJuZWwsIChtZW1vLCBudW0pID0+IG1lbW8gKyBudW0sIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IG9wdHMuc2NhbGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVByb2dyYW0oKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICAgIGlmICghaXNBcnJheShvcHRzLmtlcm5lbCkgfHwgb3B0cy5rZXJuZWwubGVuZ3RoICUgMiAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb252b2x1dGlvbiBrZXJuZWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2VybmVsU2l6ZSA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KG9wdHMua2VybmVsLmxlbmd0aCkpO1xuICAgICAgICBpZiAoa2VybmVsU2l6ZSAqIGtlcm5lbFNpemUgIT09IG9wdHMua2VybmVsLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb252b2x1dGlvbiBrZXJuZWxcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlZGdlTW9kZTogQ29udkVkZ2VNb2RlID0gQ29udkVkZ2VNb2RlW3RoaXMub3B0cy5lZGdlTW9kZV07XG5cbiAgICAgICAgLy8gZ2VuZXJhdGUgZWRnZSBjb3JyZWN0aW9uIGZ1bmN0aW9uXG4gICAgICAgIGxldCBlZGdlRnVuYyA9IFwiXCI7XG4gICAgICAgIHN3aXRjaCAoZWRnZU1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgQ29udkVkZ2VNb2RlLldSQVA6XG4gICAgICAgICAgICAgICAgZWRnZUZ1bmMgPSBcInBvcyA9IHZlYzIocG9zLng8MD9wb3MueCsxLjA6cG9zLnglMSwgcG9zLnk8MD9wb3MueSsxLjA6cG9zLnklMSk7XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbnZFZGdlTW9kZS5FWFRFTkQ6XG4gICAgICAgICAgICAgICAgZWRnZUZ1bmMgPSBcInBvcyA9IGNsYW1wKHBvcywgdmVjMigwLDApLCB2ZWMyKDEsMSkpO1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2VuZXJhdGUga2VybmVsIG11bHRpcGxpY2F0aW9uIGNvZGVcbiAgICAgICAgY29uc3QgY29sb3JTdW1FcSA9IFtdO1xuICAgICAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKGtlcm5lbFNpemUgLyAyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2VybmVsU2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRzLmtlcm5lbFsoaSAqIGtlcm5lbFNpemUgKyBqKV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xvclN1bUVxLnB1c2goXCJwb3MgPSB2X3Bvc2l0aW9uICsgdGV4ZWwgKiB2ZWMyKFwiICsgKGogLSBtaWQpICsgXCIsXCIgKyAobWlkIC0gaSkgKyBcIik7XCIpO1xuICAgICAgICAgICAgICAgIGNvbG9yU3VtRXEucHVzaChlZGdlRnVuYyk7XG4gICAgICAgICAgICAgICAgY29sb3JTdW1FcS5wdXNoKFwiY29sb3JTdW0gKz0gdGV4dHVyZTJEKHVfc3JjVGV4dHVyZSwgcG9zKSAqIFwiICsgZ2xzbEZsb2F0UmVwcih2YWx1ZSkgKyBcIjtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9ncmFtID0gbmV3IFNoYWRlclByb2dyYW0odGhpcy5tYWluLmdldFJjdHgoKSwge1xuICAgICAgICAgICAgYmluZGluZ3M6IHtcbiAgICAgICAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgICAgICAgICBiaWFzOiB7IG5hbWU6IFwidV9iaWFzXCIsIHZhbHVlVHlwZTogV2ViR0xWYXJUeXBlLl8xRiB9LFxuICAgICAgICAgICAgICAgICAgICBzY2FsZTogeyBuYW1lOiBcInVfc2NhbGVcIiwgdmFsdWVUeXBlOiBXZWJHTFZhclR5cGUuXzFGIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogYFxuICAgICAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdV9zY2FsZTtcbiAgICAgICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHVfYmlhcztcbiAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgdmVjMiB0ZXhlbCA9IDEuMC8odV9yZXNvbHV0aW9uLXZlYzIoMSwxKSk7XG4gICAgICAgICAgICAgICAgICAgdmVjMiBwb3M7XG4gICAgICAgICAgICAgICAgICAgdmVjNCBjb2xvclN1bSA9IHZlYzQoMCwwLDAsMCk7XG4gICAgICAgICAgICAgICAgICAgJHsgY29sb3JTdW1FcS5qb2luKFwiXFxuXCIpIH1cbiAgICAgICAgICAgICAgICAgICBzZXRGcmFnQ29sb3IodmVjNCgoKGNvbG9yU3VtK3VfYmlhcykvdV9zY2FsZSkucmdiLCAxLjApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgLFxuICAgICAgICAgICAgc3dhcEZyYW1lOiB0cnVlLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5wcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RyYW5zL0NvbnZvbHV0aW9uLnRzIiwiaW1wb3J0IGFycmF5UmVkdWNlIGZyb20gJy4vX2FycmF5UmVkdWNlLmpzJztcbmltcG9ydCBiYXNlRWFjaCBmcm9tICcuL19iYXNlRWFjaC5qcyc7XG5pbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5pbXBvcnQgYmFzZVJlZHVjZSBmcm9tICcuL19iYXNlUmVkdWNlLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gKlxuICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAqIGFuZCBgc29ydEJ5YFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICogICByZXR1cm4gc3VtICsgbjtcbiAqIH0sIDApO1xuICogLy8gPT4gM1xuICpcbiAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAqICAgcmV0dXJuIHJlc3VsdDtcbiAqIH0sIHt9KTtcbiAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9yZWR1Y2UuanNcbi8vIG1vZHVsZSBpZCA9IDI5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlSZWR1Y2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5UmVkdWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpbml0QWNjdW1cbiAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VSZWR1Y2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VSZWR1Y2UuanNcbi8vIG1vZHVsZSBpZCA9IDMwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCBDb21wb25lbnQsIHsgSUNvbnRhaW5lciB9IGZyb20gXCIuLi9Db21wb25lbnRcIjtcbmltcG9ydCBDb2RlSW5zdGFuY2UgZnJvbSBcIi4uL2V4cHIvQ29kZUluc3RhbmNlXCI7XG5pbXBvcnQgY29tcGlsZUV4cHIgZnJvbSBcIi4uL2V4cHIvY29tcGlsZUV4cHJcIjtcbmltcG9ydCBJTWFpbiBmcm9tIFwiLi4vSU1haW5cIjtcbmltcG9ydCB7IEJsZW5kTW9kZSwgY2xhbXAgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCBCdWZmZXIgZnJvbSBcIi4uL3dlYmdsL0J1ZmZlclwiO1xuaW1wb3J0IFJlbmRlcmluZ0NvbnRleHQgZnJvbSBcIi4uL3dlYmdsL1JlbmRlcmluZ0NvbnRleHRcIjtcbmltcG9ydCBTaGFkZXJQcm9ncmFtLCB7IElTaGFkZXJPcHRzIH0gZnJvbSBcIi4uL3dlYmdsL1NoYWRlclByb2dyYW1cIjtcblxuLyoqXG4gKiBDb29yZGluYXRlIE1vdmVtZW50IGNvb3JkaW5hdGUgbW9kZXNcbiAqL1xuZW51bSBEeW5hbWljTW92ZW1lbnRDb29yZE1vZGUge1xuICAgIFBPTEFSID0gMCxcbiAgICBSRUNULFxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIFtbRHluYW1pY01vdmVtZW50XV0gY29tcG9uZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUR5bmFtaWNNb3ZlbWVudE9wdHMge1xuICAgIC8qKlxuICAgICAqIEVFTCBjb2RlIHRvIGNvbnRyb2wgdGhlIG1vdmVtZW50IG9mIHBpeGVsc1xuICAgICAqXG4gICAgICogRUVMIFZhcmlhYmxlczpcbiAgICAgKiArIGB4YDogYChSZWFkV3JpdGUsIHBlclBpeGVsLCBSRUNUIG1vZGUpYCAtIEN1cnJlbnQgeCBwb3NpdGlvbi4gU2V0IHRoaXMgdmFsdWUgdG8gbW92ZSBwaXhlbCB0byBuZXcgcG9zaXRpb25cbiAgICAgKiArIGB5YDogYChSZWFkV3JpdGUsIHBlclBpeGVsLCBSRUNUIG1vZGUpYCAtIEN1cnJlbnQgeSBwb3NpdGlvbi4gU2V0IHRoaXMgdmFsdWUgdG8gbW92ZSBwaXhlbCB0byBuZXcgcG9zaXRpb25cbiAgICAgKiArIGBkYDogYChSZWFkV3JpdGUsIHBlclBpeGVsLCBQT0xBUiBtb2RlKWAgLSBDdXJyZW50IGRpc3RhbmNlIGZyb20gY2VudGVyLiBTZXQgdGhpcyB2YWx1ZSB0byBtb3ZlIHBpeGVsIHRvXG4gICAgICogICBuZXcgcG9zaXRpb25cbiAgICAgKiArIGByYDogYChSZWFkV3JpdGUsIHBlclBpeGVsLCBQT0xBUiBtb2RlKWAgLSBDdXJyZW50IGFuZ2xlLiBTZXQgdGhpcyB2YWx1ZSB0byBtb3ZlIHBpeGVsIHRvIG5ldyBsb2NhdGlvblxuICAgICAqICsgYGFscGhhYDogYChSZWFkV3JpdGUsIHBlclBpeGVsKWAgLSBXaGVuIGJsZW5kIG1vZGUgaXMgZW5hYmxlZCB0aGlzIHNldHMgdGhlIGFscGhhIG9mIHRoZSBuZXcgcGl4ZWxcbiAgICAgKiArIGBiYDogYChSZWFkLCBvbkJlYXQvcGVyRnJhbWUvcGVyUGl4ZWwpYCAtIDAvMSB2YWx1ZSBpbmRpY2F0ZSBhIGJlYXRcbiAgICAgKi9cbiAgICBjb2RlOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFRUwgdGhhdCdsbCBiZSBydW4gb24gaW5pdFxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogc3RyaW5nLFxuICAgICAgICAvKipcbiAgICAgICAgICogRUVMIGNvZGUgdGhhdCdzIHJ1biBvbiBiZWF0XG4gICAgICAgICAqL1xuICAgICAgICBvbkJlYXQ6IHN0cmluZyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVFTCBjb2RlIHRoYXQgd2lsbCBiZSBydW4gb25jZSBwZXIgZnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIHBlckZyYW1lOiBzdHJpbmcsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFRUwgY29kZSB0aGF0IHdpbGwgYmUgcnVuIG9uY2UgcGVyIHBpeGVsIG9yIGdyaWQgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIHBlclBpeGVsOiBzdHJpbmcsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIGBub0dyaWRgIGlzIHRydWUuIFRoaXMgaW5kaWNhdGVzIHRoZSB3aWR0aCBvZiB0aGUgZ3JpZHMuIERlZmF1bHQ6IDE2XG4gICAgICovXG4gICAgZ3JpZFc6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBXaGVuIGBub0dyaWRgIGlzIHRydWUuIFRoaXMgaW5kaWNhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIGdyaWRzLiBEZWZhdWx0OiAxNlxuICAgICAqL1xuICAgIGdyaWRIOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBibGVuZGluZy4gU2V0IGBhbHBoYWAgaW4gRUVMIHRvIGNvbnRyb2wgYmVsbmRpbmdcbiAgICAgKi9cbiAgICBibGVuZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlIHRoZW4gbm8gZ3JpZHMgYXJlIHVzZWQuIE1vdmVtZW50IGlzIGNvbXB1dGVkIGZvciBldmVyeSBwaXhlbC5cbiAgICAgKi9cbiAgICBub0dyaWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRW5hYmxlIEFWUyBjb21wYXRpYmlsaXR5IG1vZGUuXG4gICAgICovXG4gICAgY29tcGF0OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSBiaWxpbmVhciBmaWx0ZXJpbmdcbiAgICAgKi9cbiAgICBiRmlsdGVyOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIENvb3JkaW5hdGUgbW9kZS4gc2VlIFtbRHluYW1pY01vdmVtZW50Q29vcmRNb2RlXV1cbiAgICAgKi9cbiAgICBjb29yZDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSURNb3ZDb2RlSW5zdGFuY2UgZXh0ZW5kcyBDb2RlSW5zdGFuY2Uge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG4gICAgZDogbnVtYmVyO1xuICAgIHI6IG51bWJlcjtcbiAgICBiOiBudW1iZXI7XG4gICAgYWxwaGE6IG51bWJlcjtcbiAgICBpbml0OiAoKSA9PiB2b2lkO1xuICAgIHBlckZyYW1lOiAoKSA9PiB2b2lkO1xuICAgIG9uQmVhdDogKCkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBBIGNvbXBvbmVudCB0aGF0IG1vdmVzIHBpeGVscyBhY2NvcmRpbmcgdG8gdXNlciBjb2RlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIER5bmFtaWNNb3ZlbWVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgcHVibGljIHN0YXRpYyBjb21wb25lbnROYW1lOiBzdHJpbmcgPSBcIkR5bmFtaWNNb3ZlbWVudFwiO1xuICAgIHB1YmxpYyBzdGF0aWMgY29tcG9uZW50VGFnOiBzdHJpbmcgPSBcInRyYW5zXCI7XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBvcHRVcGRhdGVIYW5kbGVycyA9IHtcbiAgICAgICAgYkZpbHRlcjogXCJ1cGRhdGVQcm9ncmFtXCIsXG4gICAgICAgIGJsZW5kOiBcInVwZGF0ZVByb2dyYW1cIixcbiAgICAgICAgY29kZTogXCJ1cGRhdGVDb2RlXCIsXG4gICAgICAgIGNvbXBhdDogXCJ1cGRhdGVQcm9ncmFtXCIsXG4gICAgICAgIGNvb3JkOiBcInVwZGF0ZVByb2dyYW1cIixcbiAgICAgICAgZ3JpZEg6IFwidXBkYXRlR3JpZFwiLFxuICAgICAgICBncmlkVzogXCJ1cGRhdGVHcmlkXCIsXG4gICAgICAgIG5vR3JpZDogW1xuICAgICAgICAgICAgXCJ1cGRhdGVQcm9ncmFtXCIsXG4gICAgICAgICAgICBcInVwZGF0ZUdyaWRcIixcbiAgICAgICAgXSxcbiAgICB9O1xuICAgIHByb3RlY3RlZCBzdGF0aWMgZGVmYXVsdE9wdGlvbnM6IElEeW5hbWljTW92ZW1lbnRPcHRzID0ge1xuICAgICAgICBiRmlsdGVyOiB0cnVlLFxuICAgICAgICBibGVuZDogZmFsc2UsXG4gICAgICAgIGNvZGU6IHtcbiAgICAgICAgICAgIGluaXQ6IFwiXCIsXG4gICAgICAgICAgICBvbkJlYXQ6IFwiXCIsXG4gICAgICAgICAgICBwZXJGcmFtZTogXCJcIixcbiAgICAgICAgICAgIHBlclBpeGVsOiBcIlwiLFxuICAgICAgICB9LFxuICAgICAgICBjb21wYXQ6IGZhbHNlLFxuICAgICAgICBjb29yZDogXCJQT0xBUlwiLFxuICAgICAgICBncmlkSDogMTYsXG4gICAgICAgIGdyaWRXOiAxNixcbiAgICAgICAgbm9HcmlkOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIG9wdHM6IElEeW5hbWljTW92ZW1lbnRPcHRzO1xuICAgIHByaXZhdGUgY29kZTogSURNb3ZDb2RlSW5zdGFuY2U7XG4gICAgcHJpdmF0ZSBnbHNsQ29kZTogc3RyaW5nO1xuICAgIHByaXZhdGUgaW5pdGVkOiBib29sZWFuO1xuICAgIHByaXZhdGUgcHJvZ3JhbTogU2hhZGVyUHJvZ3JhbTtcbiAgICBwcml2YXRlIGdyaWRWZXJ0ZXhCdWZmZXI6IEJ1ZmZlcjtcblxuICAgIGNvbnN0cnVjdG9yKG1haW46IElNYWluLCBwYXJlbnQ6IElDb250YWluZXIsIG9wdHM6IGFueSkge1xuICAgICAgICBzdXBlcihtYWluLCBwYXJlbnQsIG9wdHMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbml0KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvZGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5tYWluLCBcInJlc2l6ZVwiLCAoKSA9PiB0aGlzLmhhbmRsZVJlc2l6ZSgpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZHJhdygpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuY29kZTtcblxuICAgICAgICAvLyBydW4gaW5pdCwgaWYgcmVxdWlyZWRcbiAgICAgICAgaWYgKCF0aGlzLmluaXRlZCkge1xuICAgICAgICAgICAgY29kZS5pbml0KCk7XG4gICAgICAgICAgICB0aGlzLmluaXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiZWF0ID0gdGhpcy5tYWluLmdldEFuYWx5c2VyKCkuaXNCZWF0KCk7XG4gICAgICAgIGNvZGUuYiA9IGJlYXQgPyAxIDogMDtcbiAgICAgICAgLy8gcnVuIHBlciBmcmFtZVxuICAgICAgICBjb2RlLnBlckZyYW1lKCk7XG4gICAgICAgIC8vIHJ1biBvbiBiZWF0XG4gICAgICAgIGlmIChiZWF0KSB7XG4gICAgICAgICAgICBjb2RlLm9uQmVhdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9ncmFtLnJ1bih0aGlzLnBhcmVudC5nZXRUU00oKSwgdGhpcy5vcHRzLm5vR3JpZCA/IHt9IDogeyBncmlkOiB0aGlzLmdyaWRWZXJ0ZXhCdWZmZXIgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZFZlcnRleEJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5ncmlkVmVydGV4QnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlQ29kZSgpIHtcbiAgICAgICAgY29uc3QgY29tcGlsZVJlc3VsdCA9IGNvbXBpbGVFeHByKFxuICAgICAgICAgICAgdGhpcy5vcHRzLmNvZGUsXG4gICAgICAgICAgICBbXCJpbml0XCIsIFwib25CZWF0XCIsIFwicGVyRnJhbWVcIl0sXG4gICAgICAgICAgICBbXCJwZXJQaXhlbFwiXSxcbiAgICAgICAgICAgIFtcInhcIiwgXCJ5XCIsIFwiZFwiLCBcInJcIiwgXCJiXCIsIFwiYWxwaGFcIl0sXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8ganMgY29kZVxuICAgICAgICBjb25zdCBjb2RlID0gY29tcGlsZVJlc3VsdC5jb2RlSW5zdDtcbiAgICAgICAgY29kZS5zZXR1cCh0aGlzLm1haW4pO1xuICAgICAgICB0aGlzLmluaXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlIGFzIElETW92Q29kZUluc3RhbmNlO1xuXG4gICAgICAgIC8vIGdsc2wgY29kZVxuICAgICAgICB0aGlzLmdsc2xDb2RlID0gY29tcGlsZVJlc3VsdC5nbHNsQ29kZTtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9ncmFtKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVQcm9ncmFtKCkge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRzO1xuICAgICAgICBjb25zdCBjb29yZE1vZGUgPSBEeW5hbWljTW92ZW1lbnRDb29yZE1vZGVbdGhpcy5vcHRzLmNvb3JkXTtcbiAgICAgICAgY29uc3QgcmN0eCA9IHRoaXMubWFpbi5nZXRSY3R4KCk7XG5cbiAgICAgICAgY29uc3QgcHJvZ3JhbU9wdHM6IElTaGFkZXJPcHRzID0ge1xuICAgICAgICAgICAgYmxlbmRNb2RlOiBvcHRzLmJsZW5kID8gQmxlbmRNb2RlLkFMUEhBIDogQmxlbmRNb2RlLlJFUExBQ0UsXG4gICAgICAgICAgICBkcmF3SG9vazogKHZhbHVlcywgZ2wsIGRtUHJvZ3JhbSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGJpbmQgdmFsdWVzIGZyb20gY29kZSBpbnN0YW5jZSBpbnRvIHByb2dyYW1cbiAgICAgICAgICAgICAgICB0aGlzLmNvZGUuYmluZFVuaWZvcm1zKGRtUHJvZ3JhbSk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRydWUgdG8gaW5kaWNhdGUgdW5oYW5kbGVkIGRyYXcuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBsZXRzIFNoYWRlclByb2dyYW0gaGFuZGxlIGRyYXcgY2FsbHNcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogXCJcIixcbiAgICAgICAgICAgIHN3YXBGcmFtZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdHMubm9HcmlkKSB7XG4gICAgICAgICAgICBwcm9ncmFtT3B0cy5mcmFnbWVudFNoYWRlciA9IGBcbiAgICAgICAgICAgICAgICAkeyB0aGlzLmdsc2xDb2RlIH1cbiAgICAgICAgICAgICAgICAkeyBnbHNsRmlsdGVyKG9wdHMuYkZpbHRlciwgb3B0cy5jb21wYXQpIH1cbiAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICR7dGhpcy5jb2RlLmhhc1JhbmRvbSA/IFwiX19yYW5kU2VlZCA9IHZfcG9zaXRpb247XCIgOiBcIlwifVxuICAgICAgICAgICAgICAgICAgICB4ID0gdl9wb3NpdGlvbi54KjIuMC0xLjA7XG4gICAgICAgICAgICAgICAgICAgIHkgPSAtKHZfcG9zaXRpb24ueSoyLjAtMS4wKTtcbiAgICAgICAgICAgICAgICAgICAgJHsgZ2xzbFJlY3RUb1BvbGFyKGNvb3JkTW9kZSkgfVxuICAgICAgICAgICAgICAgICAgICBhbHBoYT0wLjU7XG4gICAgICAgICAgICAgICAgICAgIHBlclBpeGVsKCk7XG4gICAgICAgICAgICAgICAgICAgICR7IGdsc2xQb2xhclRvUmVjdChjb29yZE1vZGUpIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0RnJhZ0NvbG9yKHZlYzQoZmlsdGVyKHZlYzIoeCwgLXkpKSwgJHtvcHRzLmJsZW5kID8gXCJhbHBoYVwiIDogXCIxLjBcIn0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvZ3JhbU9wdHMuYmluZGluZ3MgPSB7XG4gICAgICAgICAgICAgICAgYXR0cmliczoge1xuICAgICAgICAgICAgICAgICAgICBncmlkOiB7bmFtZTogXCJhX3Bvc2l0aW9uXCIsIGRyYXdNb2RlOiByY3R4LmdldEdsKCkuVFJJQU5HTEVTIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcm9ncmFtT3B0cy52ZXJ0ZXhTaGFkZXIgPSBgXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdl9uZXdQb2ludDtcbiAgICAgICAgICAgICAgICB2YXJ5aW5nIGZsb2F0IHZfYWxwaGE7XG4gICAgICAgICAgICAgICAgJHsgdGhpcy5nbHNsQ29kZSB9XG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgICAke3RoaXMuY29kZS5oYXNSYW5kb20gPyBcIl9fcmFuZFNlZWQgPSBhX3Bvc2l0aW9uO1wiIDogXCJcIn1cbiAgICAgICAgICAgICAgICAgICAgeCA9IGFfcG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICAgICAgeSA9IC1hX3Bvc2l0aW9uLnk7XG4gICAgICAgICAgICAgICAgICAgICR7IGdsc2xSZWN0VG9Qb2xhcihjb29yZE1vZGUpIH1cbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSAwLjU7XG4gICAgICAgICAgICAgICAgICAgIHBlclBpeGVsKCk7XG4gICAgICAgICAgICAgICAgICAgIHZfYWxwaGEgPSBhbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgJHsgZ2xzbFBvbGFyVG9SZWN0KGNvb3JkTW9kZSkgfVxuICAgICAgICAgICAgICAgICAgICB2X25ld1BvaW50ID0gdmVjMih4LC15KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0UG9zaXRpb24oYV9wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIHByb2dyYW1PcHRzLmZyYWdtZW50U2hhZGVyID0gYFxuICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2X25ld1BvaW50O1xuICAgICAgICAgICAgICAgIHZhcnlpbmcgZmxvYXQgdl9hbHBoYTtcbiAgICAgICAgICAgICAgICAkeyBnbHNsRmlsdGVyKG9wdHMuYkZpbHRlciwgb3B0cy5jb21wYXQpIH1cbiAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgc2V0RnJhZ0NvbG9yKHZlYzQoZmlsdGVyKHZfbmV3UG9pbnQpLCAke29wdHMuYmxlbmQgPyBcInZfYWxwaGFcIiA6IFwiMS4wXCJ9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbShyY3R4LCBwcm9ncmFtT3B0cyk7XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUdyaWQoKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5tYWluLmdldFJjdHgoKS5nZXRHbCgpO1xuICAgICAgICBpZiAoIW9wdHMubm9HcmlkKSB7XG4gICAgICAgICAgICBjb25zdCBncmlkVyA9IGNsYW1wKG9wdHMuZ3JpZFcsIDEsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCBncmlkSCA9IGNsYW1wKG9wdHMuZ3JpZEgsIDEsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgbkdyaWRXID0gKGdyaWRXIC8gZ2wuZHJhd2luZ0J1ZmZlcldpZHRoKSAqIDI7XG4gICAgICAgICAgICBjb25zdCBuR3JpZEggPSAoZ3JpZEggLyBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KSAqIDI7XG4gICAgICAgICAgICBjb25zdCBncmlkQ291bnRBY3Jvc3MgPSBNYXRoLmNlaWwoZ2wuZHJhd2luZ0J1ZmZlcldpZHRoIC8gZ3JpZFcpO1xuICAgICAgICAgICAgY29uc3QgZ3JpZENvdW50RG93biA9IE1hdGguY2VpbChnbC5kcmF3aW5nQnVmZmVySGVpZ2h0IC8gZ3JpZEgpO1xuICAgICAgICAgICAgY29uc3QgZ3JpZFZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShncmlkQ291bnRBY3Jvc3MgKiBncmlkQ291bnREb3duICogNiAqIDIpO1xuICAgICAgICAgICAgbGV0IHBiaSA9IDA7XG4gICAgICAgICAgICBsZXQgY3VyeCA9IC0xO1xuICAgICAgICAgICAgbGV0IGN1cnkgPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JpZENvdW50RG93bjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmlkQ291bnRBY3Jvc3M7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3JueCA9IE1hdGgubWluKGN1cnggKyBuR3JpZFcsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3JueSA9IE1hdGgubWluKGN1cnkgKyBuR3JpZEgsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGdyaWRWZXJ0aWNlc1twYmkrK10gPSBjdXJ4O1xuICAgICAgICAgICAgICAgICAgICBncmlkVmVydGljZXNbcGJpKytdID0gY3VyeTtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFZlcnRpY2VzW3BiaSsrXSA9IGNvcm54O1xuICAgICAgICAgICAgICAgICAgICBncmlkVmVydGljZXNbcGJpKytdID0gY3VyeTtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFZlcnRpY2VzW3BiaSsrXSA9IGN1cng7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRWZXJ0aWNlc1twYmkrK10gPSBjb3JueTtcblxuICAgICAgICAgICAgICAgICAgICBncmlkVmVydGljZXNbcGJpKytdID0gY29ybng7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRWZXJ0aWNlc1twYmkrK10gPSBjdXJ5O1xuICAgICAgICAgICAgICAgICAgICBncmlkVmVydGljZXNbcGJpKytdID0gY29ybng7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRWZXJ0aWNlc1twYmkrK10gPSBjb3JueTtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZFZlcnRpY2VzW3BiaSsrXSA9IGN1cng7XG4gICAgICAgICAgICAgICAgICAgIGdyaWRWZXJ0aWNlc1twYmkrK10gPSBjb3JueTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJ4ICs9IG5HcmlkVztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyeCA9IC0xO1xuICAgICAgICAgICAgICAgIGN1cnkgKz0gbkdyaWRIO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmdyaWRWZXJ0ZXhCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRWZXJ0ZXhCdWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMubWFpbi5nZXRSY3R4KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ncmlkVmVydGV4QnVmZmVyLnNldERhdGEoZ3JpZFZlcnRpY2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlUmVzaXplKCkge1xuICAgICAgICB0aGlzLmNvZGUudXBkYXRlRGltVmFycyh0aGlzLm1haW4uZ2V0UmN0eCgpLmdldEdsKCkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2xzbFJlY3RUb1BvbGFyKGNvb3JkTW9kZTogRHluYW1pY01vdmVtZW50Q29vcmRNb2RlKTogc3RyaW5nIHtcbiAgICBpZiAoY29vcmRNb2RlID09PSBEeW5hbWljTW92ZW1lbnRDb29yZE1vZGUuUE9MQVIpIHtcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIGZsb2F0IGFyID0gdV9yZXNvbHV0aW9uLngvdV9yZXNvbHV0aW9uLnk7XG4gICAgICAgICAgICB4PXgqYXI7XG4gICAgICAgICAgICBkID0gZGlzdGFuY2UodmVjMih4LCB5KSwgdmVjMigwLDApKS9zcXJ0KDIuMCk7XG4gICAgICAgICAgICByID0gbW9kKGF0YW4oeSwgeCkrUEkqMC41LCAyLjAqUEkpO1xuICAgICAgICBgO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2xzbFBvbGFyVG9SZWN0KGNvb3JkTW9kZTogRHluYW1pY01vdmVtZW50Q29vcmRNb2RlKTogc3RyaW5nIHtcbiAgICBpZiAoY29vcmRNb2RlID09PSBEeW5hbWljTW92ZW1lbnRDb29yZE1vZGUuUE9MQVIpIHtcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIGQgPSBkKnNxcnQoMi4wKTtcbiAgICAgICAgICAgIHggPSBkKnNpbihyKS9hcjtcbiAgICAgICAgICAgIHkgPSAtZCpjb3Mocik7XG4gICAgICAgIGA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnbHNsRmlsdGVyKGJGaWx0ZXI6IGJvb2xlYW4sIGNvbXBhdDogYm9vbGVhbik6IHN0cmluZyB7XG4gICAgaWYgKGJGaWx0ZXIgJiYgIWNvbXBhdCkge1xuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgdmVjMyBmaWx0ZXIodmVjMiBwb2ludCkge1xuICAgICAgICAgICAgICAgdmVjMiB0ZXhlbCA9IDEuMC8odV9yZXNvbHV0aW9uLXZlYzIoMSwxKSk7XG4gICAgICAgICAgICAgICB2ZWMyIGNvb3JkID0gKHBvaW50KzEuMCkvMi4wO1xuICAgICAgICAgICAgICAgdmVjMiBjb3Jub2ZmID0gZnJhY3QoY29vcmQvdGV4ZWwpO1xuICAgICAgICAgICAgICAgdmVjMiBjb3JuID0gZmxvb3IoY29vcmQvdGV4ZWwpKnRleGVsO1xuXG4gICAgICAgICAgICAgICB2ZWMzIHRsID0gZ2V0U3JjQ29sb3JBdFBvcyhjb3JuKS5yZ2I7XG4gICAgICAgICAgICAgICB2ZWMzIHRyID0gZ2V0U3JjQ29sb3JBdFBvcyhjb3JuICsgdmVjMih0ZXhlbC54LCAwKSkucmdiO1xuICAgICAgICAgICAgICAgdmVjMyBibCA9IGdldFNyY0NvbG9yQXRQb3MoY29ybiArIHZlYzIoMCwgdGV4ZWwueSkpLnJnYjtcbiAgICAgICAgICAgICAgIHZlYzMgYnIgPSBnZXRTcmNDb2xvckF0UG9zKGNvcm4gKyB0ZXhlbCkucmdiO1xuXG4gICAgICAgICAgICAgICB2ZWMzIHB0ID0gbWl4KHRsLCB0ciwgY29ybm9mZi54KTtcbiAgICAgICAgICAgICAgIHZlYzMgcGIgPSBtaXgoYmwsIGJyLCBjb3Jub2ZmLngpO1xuICAgICAgICAgICAgICAgcmV0dXJuIG1peChwdCwgcGIsIGNvcm5vZmYueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgfSBlbHNlIGlmIChiRmlsdGVyICYmIGNvbXBhdCkge1xuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgdmVjMyBmaWx0ZXIodmVjMiBwb2ludCkge1xuICAgICAgICAgICAgICAgdmVjMiB0ZXhlbCA9IDEuMC8odV9yZXNvbHV0aW9uLXZlYzIoMSwxKSk7XG4gICAgICAgICAgICAgICB2ZWMyIGNvb3JkID0gKHBvaW50KzEuMCkvMi4wO1xuICAgICAgICAgICAgICAgdmVjMiBjb3JuID0gZmxvb3IoY29vcmQvdGV4ZWwpKnRleGVsO1xuXG4gICAgICAgICAgICAgICBpdmVjMiBjb3Jub2ZmID0gKGl2ZWMyKGZyYWN0KGNvb3JkL3RleGVsKSoyNTUuMCkpO1xuXG4gICAgICAgICAgICAgICBpdmVjMyB0bCA9IGl2ZWMzKDI1NS4wICogZ2V0U3JjQ29sb3JBdFBvcyhjb3JuKS5yZ2IpO1xuICAgICAgICAgICAgICAgaXZlYzMgdHIgPSBpdmVjMygyNTUuMCAqIGdldFNyY0NvbG9yQXRQb3MoY29ybiArIHZlYzIodGV4ZWwueCwgMCkpLnJnYik7XG4gICAgICAgICAgICAgICBpdmVjMyBibCA9IGl2ZWMzKDI1NS4wICogZ2V0U3JjQ29sb3JBdFBvcyhjb3JuICsgdmVjMigwLCB0ZXhlbC55KSkucmdiKTtcbiAgICAgICAgICAgICAgIGl2ZWMzIGJyID0gaXZlYzMoMjU1LjAgKiBnZXRTcmNDb2xvckF0UG9zKGNvcm4gKyB0ZXhlbCkucmdiKTtcblxuICAgICAgICAgICAgICAgI2RlZmluZSBidChpLCBqKSBpbnQoKGZsb2F0KGkpLzI1NS4wKSpmbG9hdChqKSlcblxuICAgICAgICAgICAgICAgaW50IGExID0gYnQoMjU1LWNvcm5vZmYueCwyNTUtY29ybm9mZi55KTtcbiAgICAgICAgICAgICAgIGludCBhMiA9IGJ0KGNvcm5vZmYueCAgICAsMjU1LWNvcm5vZmYueSk7XG4gICAgICAgICAgICAgICBpbnQgYTMgPSBidCgyNTUtY29ybm9mZi54LGNvcm5vZmYueSk7XG4gICAgICAgICAgICAgICBpbnQgYTQgPSBidChjb3Jub2ZmLnggICAgLGNvcm5vZmYueSk7XG4gICAgICAgICAgICAgICBmbG9hdCByID0gZmxvYXQoYnQoYTEsdGwucikgKyBidChhMix0ci5yKSArIGJ0KGEzLGJsLnIpICsgYnQoYTQsYnIucikpLzI1NS4wO1xuICAgICAgICAgICAgICAgZmxvYXQgZyA9IGZsb2F0KGJ0KGExLHRsLmcpICsgYnQoYTIsdHIuZykgKyBidChhMyxibC5nKSArIGJ0KGE0LGJyLmcpKS8yNTUuMDtcbiAgICAgICAgICAgICAgIGZsb2F0IGIgPSBmbG9hdChidChhMSx0bC5iKSArIGJ0KGEyLHRyLmIpICsgYnQoYTMsYmwuYikgKyBidChhNCxici5iKSkvMjU1LjA7XG4gICAgICAgICAgICAgICByZXR1cm4gdmVjMyhyLGcsYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIHZlYzMgZmlsdGVyKHZlYzIgcG9pbnQpIHtcbiAgICAgICAgICAgICAgIHJldHVybiBnZXRTcmNDb2xvckF0UG9zKChwb2ludCsxLjApLzIuMCkucmdiO1xuICAgICAgICAgICAgfVxuICAgICAgICBgO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90cmFucy9EeW5hbWljTW92ZW1lbnQudHMiLCJpbXBvcnQgQ29tcG9uZW50LCB7IElDb250YWluZXIgfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG5pbXBvcnQgSU1haW4gZnJvbSBcIi4uL0lNYWluXCI7XG5pbXBvcnQgeyBCbGVuZE1vZGUsIENvbG9yLCBwYXJzZUNvbG9yTm9ybSB9IGZyb20gXCIuLi91dGlsc1wiO1xuaW1wb3J0IENsZWFyU2NyZWVuUHJvZ3JhbSBmcm9tIFwiLi4vd2ViZ2wvQ2xlYXJTY3JlZW5Qcm9ncmFtXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZhZGVPdXRPcHRzIHtcbiAgICBzcGVlZDogbnVtYmVyO1xuICAgIGNvbG9yOiBzdHJpbmc7XG59XG5cbi8vIEEgY29tcG9uZW50IHRoYXQgc2xvd2x5IGZhZGVzIHRoZSBzY3JlZW4gdG8gYSBzcGVjaWZpZWQgY29sb3JcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhZGVPdXQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHB1YmxpYyBzdGF0aWMgY29tcG9uZW50TmFtZTogc3RyaW5nID0gXCJGYWRlT3V0XCI7XG4gICAgcHVibGljIHN0YXRpYyBjb21wb25lbnRUYWc6IHN0cmluZyA9IFwidHJhbnNcIjtcbiAgICBwcm90ZWN0ZWQgc3RhdGljIG9wdFVwZGF0ZUhhbmRsZXJzID0ge1xuICAgICAgICBjb2xvcjogXCJ1cGRhdGVDb2xvclwiLFxuICAgICAgICBzcGVlZDogXCJ1cGRhdGVTcGVlZFwiLFxuICAgIH07XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkZWZhdWx0T3B0aW9uczogSUZhZGVPdXRPcHRzID0ge1xuICAgICAgICBjb2xvcjogXCIjMDAwMDAwXCIsXG4gICAgICAgIHNwZWVkOiAxLFxuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgb3B0czogSUZhZGVPdXRPcHRzO1xuICAgIHByaXZhdGUgcHJvZ3JhbTogQ2xlYXJTY3JlZW5Qcm9ncmFtO1xuICAgIHByaXZhdGUgZnJhbWVDb3VudDogbnVtYmVyO1xuICAgIHByaXZhdGUgbWF4RnJhbWVDb3VudDogbnVtYmVyO1xuICAgIHByaXZhdGUgY29sb3I6IENvbG9yO1xuXG4gICAgY29uc3RydWN0b3IobWFpbjogSU1haW4sIHBhcmVudDogSUNvbnRhaW5lciwgb3B0czogYW55KSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHBhcmVudCwgb3B0cyk7XG4gICAgfVxuXG4gICAgcHVibGljIGluaXQoKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG5ldyBDbGVhclNjcmVlblByb2dyYW0odGhpcy5tYWluLmdldFJjdHgoKSwgQmxlbmRNb2RlLkFWRVJBR0UpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNwZWVkKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ29sb3IoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZHJhdygpIHtcbiAgICAgICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgICAgIGlmICh0aGlzLmZyYW1lQ291bnQgPT09IHRoaXMubWF4RnJhbWVDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS5ydW4odGhpcy5wYXJlbnQuZ2V0VFNNKCksIHsgY29sb3I6IHRoaXMuY29sb3IgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnByb2dyYW0uZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlU3BlZWQoKSB7XG4gICAgICAgIHRoaXMuZnJhbWVDb3VudCA9IDA7XG4gICAgICAgIHRoaXMubWF4RnJhbWVDb3VudCA9IE1hdGguZmxvb3IoMSAvIHRoaXMub3B0cy5zcGVlZCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVDb2xvcigpIHtcbiAgICAgICAgdGhpcy5jb2xvciA9IHBhcnNlQ29sb3JOb3JtKHRoaXMub3B0cy5jb2xvcik7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3RyYW5zL0ZhZGVPdXQudHMiLCJpbXBvcnQgQ29tcG9uZW50LCB7IElDb250YWluZXIgfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG5pbXBvcnQgSU1haW4gZnJvbSBcIi4uL0lNYWluXCI7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tIFwiLi4vd2ViZ2wvU2hhZGVyUHJvZ3JhbVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZlcnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHB1YmxpYyBzdGF0aWMgY29tcG9uZW50TmFtZTogc3RyaW5nID0gXCJJbnZlcnRcIjtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudFRhZzogc3RyaW5nID0gXCJ0cmFuc1wiO1xuXG4gICAgcHJpdmF0ZSBwcm9ncmFtOiBTaGFkZXJQcm9ncmFtO1xuXG4gICAgY29uc3RydWN0b3IobWFpbjogSU1haW4sIHBhcmVudDogSUNvbnRhaW5lciwgb3B0czogYW55KSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHBhcmVudCwgb3B0cyk7XG4gICAgfVxuXG4gICAgcHVibGljIGluaXQoKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKHRoaXMubWFpbi5nZXRSY3R4KCksIHtcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBgXG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgIHNldEZyYWdDb2xvcih2ZWM0KDEsMSwxLDEpLWdldFNyY0NvbG9yKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGAsXG4gICAgICAgICAgICBzd2FwRnJhbWU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBkcmF3KCkge1xuICAgICAgICB0aGlzLnByb2dyYW0ucnVuKHRoaXMucGFyZW50LmdldFRTTSgpLCBudWxsKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnByb2dyYW0uZGVzdHJveSgpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90cmFucy9JbnZlcnQudHMiLCJpbXBvcnQgQ29tcG9uZW50LCB7IElDb250YWluZXIgfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG5pbXBvcnQgSU1haW4gZnJvbSBcIi4uL0lNYWluXCI7XG5pbXBvcnQgeyBXZWJHTFZhclR5cGUgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCBSZW5kZXJpbmdDb250ZXh0IGZyb20gXCIuLi93ZWJnbC9SZW5kZXJpbmdDb250ZXh0XCI7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tIFwiLi4vd2ViZ2wvU2hhZGVyUHJvZ3JhbVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIElNaXJyb3JEaXJzIHtcbiAgICB0b3BUb0JvdHRvbTogYm9vbGVhbjtcbiAgICBib3R0b21Ub1RvcDogYm9vbGVhbjtcbiAgICBsZWZ0VG9SaWdodDogYm9vbGVhbjtcbiAgICByaWdodFRvTGVmdDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTWlycm9yT3B0cyBleHRlbmRzIElNaXJyb3JEaXJzIHtcbiAgICBvbkJlYXRSYW5kb206IGJvb2xlYW47XG4gICAgc21vb3RoVHJhbnNpdGlvbjogYm9vbGVhbjtcbiAgICB0cmFuc2l0aW9uRHVyYXRpb246IG51bWJlcjtcbn1cblxuLy8gQSBjb21wb25lbnQgdGhhdCBtaXJyb3IgYmV0d2VlbiBxdWFuZHJhbnRzXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNaXJyb3IgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHB1YmxpYyBzdGF0aWMgY29tcG9uZW50TmFtZTogc3RyaW5nID0gXCJNaXJyb3JcIjtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudFRhZzogc3RyaW5nID0gXCJ0cmFuc1wiO1xuICAgIHByb3RlY3RlZCBzdGF0aWMgb3B0VXBkYXRlSGFuZGxlcnMgPSB7XG4gICAgICAgIGJvdHRvbVRvVG9wOiBcInVwZGF0ZU1hcFwiLFxuICAgICAgICBsZWZ0VG9SaWdodDogXCJ1cGRhdGVNYXBcIixcbiAgICAgICAgcmlnaHRUb0xlZnQ6IFwidXBkYXRlTWFwXCIsXG4gICAgICAgIHRvcFRvQm90dG9tOiBcInVwZGF0ZU1hcFwiLFxuICAgIH07XG4gICAgcHJvdGVjdGVkIHN0YXRpYyBkZWZhdWx0T3B0aW9uczogSU1pcnJvck9wdHMgPSB7XG4gICAgICAgIGJvdHRvbVRvVG9wOiBmYWxzZSxcbiAgICAgICAgbGVmdFRvUmlnaHQ6IGZhbHNlLFxuICAgICAgICBvbkJlYXRSYW5kb206IGZhbHNlLFxuICAgICAgICByaWdodFRvTGVmdDogZmFsc2UsXG4gICAgICAgIHNtb290aFRyYW5zaXRpb246IGZhbHNlLFxuICAgICAgICB0b3BUb0JvdHRvbTogdHJ1ZSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiA0LFxuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgb3B0czogSU1pcnJvck9wdHM7XG4gICAgcHJpdmF0ZSBwcm9ncmFtOiBTaGFkZXJQcm9ncmFtO1xuICAgIHByaXZhdGUgYW5pbUZyYW1lQ291bnQ6IG51bWJlcjtcbiAgICBwcml2YXRlIG1hcDogbnVtYmVyW107XG4gICAgcHJpdmF0ZSBtaXg6IG51bWJlcltdW107XG4gICAgcHJpdmF0ZSBtaXhEZWx0YTogbnVtYmVyW11bXTtcblxuICAgIGNvbnN0cnVjdG9yKG1haW46IElNYWluLCBwYXJlbnQ6IElDb250YWluZXIsIG9wdHM6IGFueSkge1xuICAgICAgICBzdXBlcihtYWluLCBwYXJlbnQsIG9wdHMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBfc2V0TWl4KG5vVHJhbnNpdGlvbjogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5vcHRzLnNtb290aFRyYW5zaXRpb24gJiYgIW5vVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgLy8gc2V0IG1peCB2ZWN0b3JzIHRvIHNlY29uZCBmb3JtYXQgaWYgd2UgYXJlIG5vdCBhbHJlYWR5XG4gICAgICAgICAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIGEgdHJhbnNpdGlvblxuICAgICAgICAgICAgaWYgKHRoaXMuYW5pbUZyYW1lQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBxdWFkID0gdGhpcy5taXhbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWl4W2ldWzBdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhbaV1bcXVhZF0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBtaXggZGVsdGEgdmFsdWVzXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZFZhbHVlID0gKGogID09PSB0aGlzLm1hcFtpXSkgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhEZWx0YVtpXVtqXSA9IChlbmRWYWx1ZSAtIHRoaXMubWl4W2ldW2pdKSAvIHRoaXMub3B0cy50cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFuaW1GcmFtZUNvdW50ID0gdGhpcy5vcHRzLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNldCBtaXggdmFsdWUgdG8gZmlyc3QgZm9ybWF0XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMubWl4W2ldWzBdID0gdGhpcy5tYXBbaV07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhbaV1bal0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBpbml0KCkge1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBuZXcgU2hhZGVyUHJvZ3JhbSh0aGlzLm1haW4uZ2V0UmN0eCgpLCB7XG4gICAgICAgICAgICBiaW5kaW5nczoge1xuICAgICAgICAgICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICAgICAgICAgIG1peDA6IHsgbmFtZTogXCJ1X21peDBcIiwgdmFsdWVUeXBlOiBXZWJHTFZhclR5cGUuXzRGViB9LFxuICAgICAgICAgICAgICAgICAgICBtaXgxOiB7IG5hbWU6IFwidV9taXgxXCIsIHZhbHVlVHlwZTogV2ViR0xWYXJUeXBlLl80RlYgfSxcbiAgICAgICAgICAgICAgICAgICAgbWl4MjogeyBuYW1lOiBcInVfbWl4MlwiLCB2YWx1ZVR5cGU6IFdlYkdMVmFyVHlwZS5fNEZWIH0sXG4gICAgICAgICAgICAgICAgICAgIG1peDM6IHsgbmFtZTogXCJ1X21peDNcIiwgdmFsdWVUeXBlOiBXZWJHTFZhclR5cGUuXzRGViB9LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiB7IG5hbWU6IFwidV9tb2RlXCIsIHZhbHVlVHlwZTogV2ViR0xWYXJUeXBlLl8xSSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGBcbiAgICAgICAgICAgICAgICB1bmlmb3JtIGludCB1X21vZGU7XG4gICAgICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVfbWl4MDtcbiAgICAgICAgICAgICAgICB1bmlmb3JtIHZlYzQgdV9taXgxO1xuICAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjNCB1X21peDI7XG4gICAgICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IHVfbWl4MztcblxuICAgICAgICAgICAgICAgICNkZWZpbmUgZ2V0UXVhZHJhbnQocG9zKSAoIChwb3MueDwwLjUpID8gKHBvcy55PDAuNT8yOjApIDogKHBvcy55PDAuNT8zOjEpIClcbiAgICAgICAgICAgICAgICAjZGVmaW5lIGNoZWNrKGEsYiwgYyxkLGUsZikgKCAoKGE9PWMgfHwgYT09ZCkgJiYgKGI9PWUgfHwgYj09ZikpIHx8ICgoYT09ZSB8fCBhPT1mKSAmJiAoYj09YyB8fCBiPT1kKSkgKVxuICAgICAgICAgICAgICAgICNkZWZpbmUgeEZsaXAocWEsIHFiKSAoY2hlY2socWEscWIsIDAsMiwgMSwzKT8tMToxKVxuICAgICAgICAgICAgICAgICNkZWZpbmUgeUZsaXAocWEsIHFiKSAoY2hlY2socWEscWIsIDAsMSwgMiwzKT8tMToxKVxuICAgICAgICAgICAgICAgICNkZWZpbmUgbWlycm9yUG9zKHBvcyxxYSxxYikgKChwb3MtdmVjMigwLjUsMC41KSkqdmVjMih4RmxpcChxYSxxYikseUZsaXAocWEscWIpKSt2ZWMyKDAuNSwwLjUpKVxuICAgICAgICAgICAgICAgICNkZWZpbmUgZ2V0TWlycm9yQ29sb3IocG9zLHFhLHFiKSAoZ2V0U3JjQ29sb3JBdFBvcyhtaXJyb3JQb3MocG9zLHFhLHFiKSkpXG5cbiAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgIGludCBxdWFkcmFudCA9IGdldFF1YWRyYW50KHZfcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB2ZWM0IG1peDtcbiAgICAgICAgICAgICAgICAgICAgaWYocXVhZHJhbnQgPT0gMCkgICAgICB7IG1peCA9IHVfbWl4MDsgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHF1YWRyYW50ID09IDEpIHsgbWl4ID0gdV9taXgxOyB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYocXVhZHJhbnQgPT0gMikgeyBtaXggPSB1X21peDI7IH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihxdWFkcmFudCA9PSAzKSB7IG1peCA9IHVfbWl4MzsgfVxuICAgICAgICAgICAgICAgICAgICBpZih1X21vZGUgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50IG90aGVyUXVhZHJhbnQgPSBpbnQobWl4LngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RnJhZ0NvbG9yKGdldE1pcnJvckNvbG9yKHZfcG9zaXRpb24sIHF1YWRyYW50LCBvdGhlclF1YWRyYW50KSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IGMwID0gZ2V0TWlycm9yQ29sb3Iodl9wb3NpdGlvbiwgcXVhZHJhbnQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBjMSA9IGdldE1pcnJvckNvbG9yKHZfcG9zaXRpb24sIHF1YWRyYW50LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgYzIgPSBnZXRNaXJyb3JDb2xvcih2X3Bvc2l0aW9uLCBxdWFkcmFudCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IGMzID0gZ2V0TWlycm9yQ29sb3Iodl9wb3NpdGlvbiwgcXVhZHJhbnQsIDMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRGcmFnQ29sb3IodmVjNChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QodmVjNChjMC5yLGMxLnIsYzIucixjMy5yKSwgbWl4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QodmVjNChjMC5nLGMxLmcsYzIuZyxjMy5nKSwgbWl4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QodmVjNChjMC5iLGMxLmIsYzIuYixjMy5iKSwgbWl4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLjBcbiAgICAgICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYCxcbiAgICAgICAgICAgIHN3YXBGcmFtZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYW5pbUZyYW1lQ291bnQgPSAwO1xuICAgICAgICB0aGlzLm1peCA9IFtcbiAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIFsxLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIFsyLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIFszLCAwLCAwLCAwXSxcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5taXhEZWx0YSA9IFtcbiAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy51cGRhdGVNYXAoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZHJhdygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5vbkJlYXRSYW5kb20gJiYgdGhpcy5tYWluLmdldEFuYWx5c2VyKCkuaXNCZWF0KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFF1YWRyYW50TWFwKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9ncmFtLnJ1bih0aGlzLnBhcmVudC5nZXRUU00oKSwge1xuICAgICAgICAgICAgbWl4MDogdGhpcy5taXhbMF0sXG4gICAgICAgICAgICBtaXgxOiB0aGlzLm1peFsxXSxcbiAgICAgICAgICAgIG1peDI6IHRoaXMubWl4WzJdLFxuICAgICAgICAgICAgbWl4MzogdGhpcy5taXhbM10sXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0aGlzLl9pblRyYW5zaXRpb24oKSA/IDEgOiAwLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5faW5UcmFuc2l0aW9uKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbUZyYW1lQ291bnQtLTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFuaW1GcmFtZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0TWl4KHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhbaV1bal0gKz0gdGhpcy5taXhEZWx0YVtpXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlTWFwKCkge1xuICAgICAgICB0aGlzLl9zZXRRdWFkcmFudE1hcCgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2luVHJhbnNpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm9wdHMuc21vb3RoVHJhbnNpdGlvbiAmJiB0aGlzLmFuaW1GcmFtZUNvdW50ICE9PSAwKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zZXRRdWFkcmFudE1hcChyYW5kb206IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBtYXAgPSBbMCwgMSwgMiwgM107XG4gICAgICAgIGxldCBtaXJyb3JEaXJzOiBJTWlycm9yRGlycyA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHJhbmRvbSkge1xuICAgICAgICAgICAgY29uc3QgcmFuZFZhbCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2KTtcbiAgICAgICAgICAgIG1pcnJvckRpcnMgPSB7XG4gICAgICAgICAgICAgICAgYm90dG9tVG9Ub3A6IChyYW5kVmFsICYgMikgJiYgdGhpcy5vcHRzLmJvdHRvbVRvVG9wLFxuICAgICAgICAgICAgICAgIGxlZnRUb1JpZ2h0OiAocmFuZFZhbCAmIDQpICYmIHRoaXMub3B0cy5sZWZ0VG9SaWdodCxcbiAgICAgICAgICAgICAgICByaWdodFRvTGVmdDogKHJhbmRWYWwgJiA4KSAmJiB0aGlzLm9wdHMucmlnaHRUb0xlZnQsXG4gICAgICAgICAgICAgICAgdG9wVG9Cb3R0b206IChyYW5kVmFsICYgMSkgJiYgdGhpcy5vcHRzLnRvcFRvQm90dG9tLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlycm9yRGlycy50b3BUb0JvdHRvbSkge1xuICAgICAgICAgICAgbWFwWzJdID0gbWFwWzBdOyBtYXBbM10gPSBtYXBbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pcnJvckRpcnMuYm90dG9tVG9Ub3ApIHtcbiAgICAgICAgICAgIG1hcFswXSA9IG1hcFsyXTsgbWFwWzFdID0gbWFwWzNdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaXJyb3JEaXJzLmxlZnRUb1JpZ2h0KSB7XG4gICAgICAgICAgICBtYXBbMV0gPSBtYXBbMF07IG1hcFszXSA9IG1hcFsyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlycm9yRGlycy5yaWdodFRvTGVmdCkge1xuICAgICAgICAgICAgbWFwWzBdID0gbWFwWzFdOyBtYXBbMl0gPSBtYXBbM107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG5cbiAgICAgICAgdGhpcy5fc2V0TWl4KGZhbHNlKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdHJhbnMvTWlycm9yLnRzIiwiaW1wb3J0IENvbXBvbmVudCwgeyBJQ29udGFpbmVyIH0gZnJvbSBcIi4uL0NvbXBvbmVudFwiO1xuaW1wb3J0IElNYWluIGZyb20gXCIuLi9JTWFpblwiO1xuaW1wb3J0IHsgQmxlbmRNb2RlLCBXZWJHTFZhclR5cGUgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCBSZW5kZXJpbmdDb250ZXh0IGZyb20gXCIuLi93ZWJnbC9SZW5kZXJpbmdDb250ZXh0XCI7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tIFwiLi4vd2ViZ2wvU2hhZGVyUHJvZ3JhbVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIElNb3NhaWNPcHRzIHtcbiAgICBibGVuZE1vZGU6IHN0cmluZztcbiAgICBzcXVhcmVTaXplOiBudW1iZXI7XG4gICAgb25CZWF0U2l6ZUNoYW5nZTogYm9vbGVhbjtcbiAgICBvbkJlYXRTcXVhcmVTaXplOiBudW1iZXI7XG4gICAgb25CZWF0U2l6ZUR1cmF0aW9uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vc2FpYyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgcHVibGljIHN0YXRpYyBjb21wb25lbnROYW1lID0gXCJNb3NhaWNcIjtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudFRhZyA9IFwidHJhbnNcIjtcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlZmF1bHRPcHRpb25zOiBJTW9zYWljT3B0cyA9IHtcbiAgICAgICAgYmxlbmRNb2RlOiBcIlJFUExBQ0VcIixcbiAgICAgICAgb25CZWF0U2l6ZUNoYW5nZTogZmFsc2UsXG4gICAgICAgIG9uQmVhdFNpemVEdXJhdGlvbjogMTAsXG4gICAgICAgIG9uQmVhdFNxdWFyZVNpemU6IDEsXG4gICAgICAgIHNxdWFyZVNpemU6IDAuNSxcbiAgICB9O1xuICAgIHByb3RlY3RlZCBzdGF0aWMgb3B0VXBkYXRlSGFuZGxlcnMgPSB7XG4gICAgICAgIGJsZW5kTW9kZTogXCJ1cGRhdGVQcm9ncmFtXCIsXG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBvcHRzOiBJTW9zYWljT3B0cztcbiAgICBwcml2YXRlIGZyYW1lQ291bnQ6IG51bWJlcjtcbiAgICBwcml2YXRlIHNpemU6IG51bWJlcjtcbiAgICBwcml2YXRlIHByb2dyYW06IFNoYWRlclByb2dyYW07XG5cbiAgICBjb25zdHJ1Y3RvcihtYWluOiBJTWFpbiwgcGFyZW50OiBJQ29udGFpbmVyLCBvcHRzOiBhbnkpIHtcbiAgICAgICAgc3VwZXIobWFpbiwgcGFyZW50LCBvcHRzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5vcHRzLnNxdWFyZVNpemU7XG4gICAgICAgIHRoaXMudXBkYXRlUHJvZ3JhbSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkcmF3KCkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMubWFpbi5nZXRSY3R4KCkuZ2V0R2woKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5vbkJlYXRTaXplQ2hhbmdlICYmIHRoaXMubWFpbi5nZXRBbmFseXNlcigpLmlzQmVhdCgpKSB7XG4gICAgICAgICAgICB0aGlzLnNpemUgPSB0aGlzLm9wdHMub25CZWF0U3F1YXJlU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVDb3VudCA9IHRoaXMub3B0cy5vbkJlYXRTaXplRHVyYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplWCA9IDEgLyBNYXRoLmZsb29yKHRoaXMuc2l6ZSAqIChnbC5kcmF3aW5nQnVmZmVyV2lkdGggLSAxKSArIDEpO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZVkgPSAxIC8gTWF0aC5mbG9vcih0aGlzLnNpemUgKiAoZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCAtIDEpICsgMSk7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0ucnVuKHRoaXMucGFyZW50LmdldFRTTSgpLCB7IHNpemU6IFtzaXplWCwgc2l6ZVldIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZnJhbWVDb3VudCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVDb3VudC0tO1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJhbWVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMub3B0cy5zcXVhcmVTaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNyID0gTWF0aC5hYnModGhpcy5vcHRzLnNxdWFyZVNpemUgLSB0aGlzLm9wdHMub25CZWF0U3F1YXJlU2l6ZSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRzLm9uQmVhdFNpemVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgKz0gaW5jciAqICh0aGlzLm9wdHMub25CZWF0U3F1YXJlU2l6ZSA+IHRoaXMub3B0cy5zcXVhcmVTaXplID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucHJvZ3JhbS5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVQcm9ncmFtKCkge1xuICAgICAgICBjb25zdCBibGVuZE1vZGU6IEJsZW5kTW9kZSA9IEJsZW5kTW9kZVt0aGlzLm9wdHMuYmxlbmRNb2RlXTtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKHRoaXMubWFpbi5nZXRSY3R4KCksIHtcbiAgICAgICAgICAgIGJpbmRpbmdzOiB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogeyBuYW1lOiBcInVfc2l6ZVwiLCB2YWx1ZVR5cGU6IFdlYkdMVmFyVHlwZS5fMkZWIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibGVuZE1vZGUsXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogYFxuICAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjMiB1X3NpemU7XG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgICB2ZWMyIHNhbXBsZVBvcyA9IHVfc2l6ZSAqICggZmxvb3Iodl9wb3NpdGlvbi91X3NpemUpICsgdmVjMigwLjUsMC41KSApO1xuICAgICAgICAgICAgICAgICAgICBzZXRGcmFnQ29sb3IoZ2V0U3JjQ29sb3JBdFBvcyhzYW1wbGVQb3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgLFxuICAgICAgICAgICAgc3dhcEZyYW1lOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90cmFucy9Nb3NhaWMudHMiLCJpbXBvcnQgQ29tcG9uZW50LCB7IElDb250YWluZXIgfSBmcm9tIFwiLi4vQ29tcG9uZW50XCI7XG5pbXBvcnQgSU1haW4gZnJvbSBcIi4uL0lNYWluXCI7XG5pbXBvcnQgeyBCbGVuZE1vZGUsIHBhcnNlQ29sb3JOb3JtLCBXZWJHTFZhclR5cGUgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCBSZW5kZXJpbmdDb250ZXh0IGZyb20gXCIuLi93ZWJnbC9SZW5kZXJpbmdDb250ZXh0XCI7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tIFwiLi4vd2ViZ2wvU2hhZGVyUHJvZ3JhbVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIElVbmlxdWVUb25lT3B0cyB7XG4gICAgY29sb3I6IHN0cmluZztcbiAgICBpbnZlcnQ6IGJvb2xlYW47XG4gICAgYmxlbmRNb2RlOiBzdHJpbmc7XG59XG5cbi8vIEEgQ29tcG9uZW50IHRoYXQgYXBwbGllcyBhIHVuaXF1ZSBjb2xvciB0b25lXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVbmlxdWVUb25lIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudE5hbWUgPSBcIlVuaXF1ZVRvbmVcIjtcbiAgICBwdWJsaWMgc3RhdGljIGNvbXBvbmVudFRhZyA9IFwidHJhbnNcIjtcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGRlZmF1bHRPcHRpb25zOiBJVW5pcXVlVG9uZU9wdHMgPSB7XG4gICAgICAgIGJsZW5kTW9kZTogXCJSRVBMQUNFXCIsXG4gICAgICAgIGNvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgaW52ZXJ0OiBmYWxzZSxcbiAgICB9O1xuICAgIHByb3RlY3RlZCBzdGF0aWMgb3B0VXBkYXRlSGFuZGxlcnMgPSB7XG4gICAgICAgIGJsZW5kTW9kZTogXCJ1cGRhdGVQcm9ncmFtXCIsXG4gICAgICAgIGNvbG9yOiBcInVwZGF0ZUNvbG9yXCIsXG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBvcHRzOiBJVW5pcXVlVG9uZU9wdHM7XG4gICAgcHJpdmF0ZSBwcm9ncmFtOiBTaGFkZXJQcm9ncmFtO1xuICAgIHByaXZhdGUgdG9uZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuXG4gICAgY29uc3RydWN0b3IobWFpbjogSU1haW4sIHBhcmVudDogSUNvbnRhaW5lciwgb3B0czogYW55KSB7XG4gICAgICAgIHN1cGVyKG1haW4sIHBhcmVudCwgb3B0cyk7XG4gICAgfVxuXG4gICAgcHVibGljIGluaXQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29sb3IoKTtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9ncmFtKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGRyYXcoKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbS5ydW4odGhpcy5wYXJlbnQuZ2V0VFNNKCksIHtcbiAgICAgICAgICAgIGludmVydDogdGhpcy5vcHRzLmludmVydCA/IDEgOiAwLFxuICAgICAgICAgICAgdG9uZTogdGhpcy50b25lLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnByb2dyYW0uZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlQ29sb3IoKSB7XG4gICAgICAgIHRoaXMudG9uZSA9IHBhcnNlQ29sb3JOb3JtKHRoaXMub3B0cy5jb2xvcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVQcm9ncmFtKCkge1xuICAgICAgICBjb25zdCBibGVuZE1vZGU6IEJsZW5kTW9kZSA9IEJsZW5kTW9kZVt0aGlzLm9wdHMuYmxlbmRNb2RlXTtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBTaGFkZXJQcm9ncmFtKHRoaXMubWFpbi5nZXRSY3R4KCksIHtcbiAgICAgICAgICAgIGJpbmRpbmdzOiB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0OiB7IG5hbWU6IFwidV9pbnZlcnRcIiwgdmFsdWVUeXBlOiBXZWJHTFZhclR5cGUuXzFGIH0sXG4gICAgICAgICAgICAgICAgICAgIHRvbmU6ICAgeyBuYW1lOiBcInVfdG9uZVwiLCB2YWx1ZVR5cGU6IFdlYkdMVmFyVHlwZS5fM0ZWIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibGVuZE1vZGUsXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogYFxuICAgICAgICAgICAgICAgIHVuaWZvcm0gdmVjMyB1X3RvbmU7XG4gICAgICAgICAgICAgICAgdW5pZm9ybSBib29sIHVfaW52ZXJ0O1xuICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICAgICB2ZWM0IHNyY0NvbG9yID0gZ2V0U3JjQ29sb3IoKTtcbiAgICAgICAgICAgICAgICAgICBmbG9hdCBkZXB0aCA9IG1heChzcmNDb2xvci5yLCBtYXgoc3JjQ29sb3IuZywgc3JjQ29sb3IuYikpO1xuICAgICAgICAgICAgICAgICAgIGlmKHVfaW52ZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gMS4wLWRlcHRoO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBzZXRGcmFnQ29sb3IodmVjNChkZXB0aCp1X3RvbmUsIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgLFxuICAgICAgICAgICAgc3dhcEZyYW1lOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy90cmFucy9VbmlxdWVUb25lLnRzIiwiaW1wb3J0IHsgV2ViR0xWYXJUeXBlIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5pbXBvcnQgUmVuZGVyaW5nQ29udGV4dCBmcm9tIFwiLi9SZW5kZXJpbmdDb250ZXh0XCI7XG5pbXBvcnQgU2hhZGVyUHJvZ3JhbSBmcm9tIFwiLi9TaGFkZXJQcm9ncmFtXCI7XG5cbi8qKlxuICogVmFsdWVzIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBbW0NvcHlQcm9ncmFtLnJ1bl1dXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNvcHlQcm9ncmFtVmFsdWVzIHtcbiAgICAvKipcbiAgICAgKiBTb3VyY2UgdGV4dHVyZSBmb3IgdGhlIGNvcHkgb3BlcmF0aW9uXG4gICAgICovXG4gICAgc3JjVGV4dHVyZTogV2ViR0xUZXh0dXJlO1xufVxuXG4vKipcbiAqIEEgU2hhZGVyIHRoYXQgY29waWVzIGdpdmVuIHRleHR1cmUgb250byBjdXJyZW50IGJ1ZmZlclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3B5UHJvZ3JhbSBleHRlbmRzIFNoYWRlclByb2dyYW08SUNvcHlQcm9ncmFtVmFsdWVzPiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgQ2xlYXJTY3JlZW5Qcm9ncmFtXG4gICAgICogQHBhcmFtIHJjdHggdGhlIHJlbmRlcmluZyBjb250ZXh0IGluIHdoaWNoIHRvIGNyZWF0ZSB0aGlzIHNoYWRlclxuICAgICAqIEBwYXJhbSBkeW5hbWljQmxlbmQgZW5hYmxlIG9yIGRpc2FibGUgZHluYW1pY0JsZW5kXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmN0eDogUmVuZGVyaW5nQ29udGV4dCwgZHluYW1pY0JsZW5kOiBib29sZWFuID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIocmN0eCwge1xuICAgICAgICAgICAgYmluZGluZ3M6IHtcbiAgICAgICAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgICAgICAgICBzcmNUZXh0dXJlOiB7IG5hbWU6IFwidV9jb3B5U291cmNlXCIsIHZhbHVlVHlwZTogV2ViR0xWYXJUeXBlLlRFWFRVUkUyRCB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHluYW1pY0JsZW5kLFxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IGBcbiAgICAgICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2NvcHlTb3VyY2U7XG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIHNldEZyYWdDb2xvcih0ZXh0dXJlMkQodV9jb3B5U291cmNlLCB2X3Bvc2l0aW9uKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3dlYmdsL0NvcHlQcm9ncmFtLnRzIiwiaW1wb3J0IEJ1ZmZlciBmcm9tIFwiLi9CdWZmZXJcIjtcblxuLyoqXG4gKiBSZW5kZXJpbmcgQ29udGV4dCB3cmFwcyBXZWJHTFJlbmRlcmluZ0NvbnRleHQgYW5kXG4gKiBhIGNhY2hlIGZvciBzaGFyZWQgQnVmZmVycy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyaW5nQ29udGV4dCB7XG4gICAgcHJpdmF0ZSBidWZmZXJzOiB7W25hbWU6IHN0cmluZ106IEJ1ZmZlcn0gPSB7fTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFJlbmRlcmluZ0NvbnRleHRcbiAgICAgKiBAcGFyYW0gZ2wgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCB0byBiZSB1c2VkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KSB7fVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0XG4gICAgICovXG4gICAgcHVibGljIGdldEdsKCk6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCB7XG4gICAgICAgIHJldHVybiB0aGlzLmdsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhY2hlcyBnaXZlbiBidWZmZXIgaW4gdGhpcyBjb250ZXh0XG4gICAgICogQHBhcmFtIG5hbWUgY2FjaGUga2V5IGZvciB0aGUgYnVmZmVyXG4gICAgICogQHBhcmFtIGJ1ZmZlciB0aGUgYnVmZmVyIHRvIGJlIGNhY2hlZFxuICAgICAqL1xuICAgIHB1YmxpYyBjYWNoZUJ1ZmZlcihuYW1lOiBzdHJpbmcsIGJ1ZmZlcjogQnVmZmVyKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyc1tuYW1lXSA9IGJ1ZmZlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYnVmZmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgY2FjaGVkIHdpdGggYVxuICAgICAqIFtbUmVuZGVyaW5nQ29udGV4dC5jYWNoZUJ1ZmZlcl1dIGNhbGxcbiAgICAgKiBAcGFyYW0gbmFtZSBjYWNoZSBrZXlcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0QnVmZmVyKG5hbWU6IHN0cmluZyk6IEJ1ZmZlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbbmFtZV07XG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAoY29uc3QgYnVmTmFtZSBpbiB0aGlzLmJ1ZmZlcnMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5idWZmZXJzLmhhc093blByb3BlcnR5KGJ1Zk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcnNbYnVmTmFtZV0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3dlYmdsL1JlbmRlcmluZ0NvbnRleHQudHMiLCJpbXBvcnQgZGVmYXVsdHMgZnJvbSBcImxvZGFzaC1lcy9kZWZhdWx0c1wiO1xuaW1wb3J0IHsgQ2hhbm5lbHMgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCBBbmFseXNlckFkYXB0ZXIgZnJvbSBcIi4vQW5hbHlzZXJBZGFwdGVyXCI7XG5cbmludGVyZmFjZSBJVmlzRGF0YSB7XG4gICAgc3BlY3RydW06IEZsb2F0MzJBcnJheTtcbiAgICB3YXZlZm9ybTogRmxvYXQzMkFycmF5O1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIFtbV2ViQXVkaW9BbmFseXNlcl1dXG4gKi9cbmludGVyZmFjZSBJV2ViQXVkaW9BbmFseXNlck9wdHMge1xuICAgIC8qKlxuICAgICAqIFdlYkF1ZGlvIENvbnRleHQgdG8gYmUgdXNlZCBmb3IgY3JlYXRpbmcgYXVkaW8gb2JqZWN0cy5cbiAgICAgKiBJZiBub25lIGlzIHByb3ZpZGVkIGFuIEF1ZGlvQ29udGV4dCBpcyBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQuXG4gICAgICovXG4gICAgY29udGV4dD86IEF1ZGlvQ29udGV4dDtcbiAgICAvKipcbiAgICAgKiBEZWNheSBmb3IgYmVhdCBkZXRlY3Rpb24uIERlZmF1bHQ6IDAuMDJcbiAgICAgKi9cbiAgICBkZWNheT86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBTaXplIG9mIEZGVCB3aW5kb3cgc2l6ZS4gRGVmYXVsdDogNTEyXG4gICAgICovXG4gICAgZmZ0U2l6ZT86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0aHJlc2hvbGQgb2YgYmVhdCBkZXRlY3Rpb24uIERlZmF1bHQ6IDAuMTI1XG4gICAgICovXG4gICAgdGhyZXNob2xkPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIFdlYkF1ZGlvQW5hbHlzZXIgaXMgYW4gQW5hbHlzZXJBZGFwdGVyIHRoYXQgc3VwcG9ydHMgYGF1ZGlvYCB0YWcgc291cmNlc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJBdWRpb0FuYWx5c2VyIGV4dGVuZHMgQW5hbHlzZXJBZGFwdGVyIHtcbiAgICBwcml2YXRlIGNvbnRleHQ6IEF1ZGlvQ29udGV4dDtcbiAgICBwcml2YXRlIGZmdFNpemU6IG51bWJlcjtcbiAgICBwcml2YXRlIHRocmVzaG9sZDogbnVtYmVyO1xuICAgIHByaXZhdGUgbW92aW5nVGhyZXNob2xkOiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgZGVjYXk6IG51bWJlcjtcbiAgICBwcml2YXRlIHZpc0RhdGE6IFtJVmlzRGF0YSwgSVZpc0RhdGEsIElWaXNEYXRhXTtcbiAgICBwcml2YXRlIHNvdXJjZTogQXVkaW9Ob2RlO1xuICAgIHByaXZhdGUgZ2FpbjogR2Fpbk5vZGU7XG4gICAgcHJpdmF0ZSBjaGFubmVsU3BsaXQ6IENoYW5uZWxTcGxpdHRlck5vZGU7XG4gICAgcHJpdmF0ZSBhbmFseXNlcnM6IFtBbmFseXNlck5vZGUsIEFuYWx5c2VyTm9kZV07XG4gICAgcHJpdmF0ZSBiZWF0OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBXZWJBdWRpb0FuYWx5c2VyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9ucyBmb3IgYW5hbHlzZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBJV2ViQXVkaW9BbmFseXNlck9wdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgICAgIGRlY2F5OiAwLjAyLFxuICAgICAgICAgICAgZmZ0U2l6ZTogNTEyLFxuICAgICAgICAgICAgdGhyZXNob2xkOiAwLjEyNSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKCh3aW5kb3cgYXMgYW55KS53ZWJraXRBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IG5ldyAod2luZG93IGFzIGFueSkud2Via2l0QXVkaW9Db250ZXh0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKHdpbmRvdyBhcyBhbnkpLkF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3ICh3aW5kb3cgYXMgYW55KS5BdWRpb0NvbnRleHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgd2ViYXVkaW8gY29udGV4dFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmZ0U2l6ZSA9IG9wdGlvbnMuZmZ0U2l6ZTtcblxuICAgICAgICB0aGlzLnRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB0aGlzLmRlY2F5ID0gb3B0aW9ucy5kZWNheTtcblxuICAgICAgICB0aGlzLnZpc0RhdGEgPSBbbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCAzOyBjaCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzcGVjdHJ1bSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5mZnRTaXplIC8gMik7XG4gICAgICAgICAgICBjb25zdCB3YXZlZm9ybSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5mZnRTaXplKTtcbiAgICAgICAgICAgIHRoaXMudmlzRGF0YVtjaF0gPSB7c3BlY3RydW0sIHdhdmVmb3JtfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdGhpcyBhbmFseXNlciB0byBhbnkgV2ViQXVkaW8gTm9kZVxuICAgICAqIEBwYXJhbSBzb3VyY2VOb2RlIG5vZGUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGF1ZGlvIHNvdXJjZVxuICAgICAqL1xuICAgIHB1YmxpYyBjb25uZWN0VG9Ob2RlKHNvdXJjZU5vZGU6IEF1ZGlvTm9kZSkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZU5vZGU7XG5cbiAgICAgICAgLy8gdGhpcyBnYWluIG5vZGUgc2ltcGx5IHVwL2Rvd24gbWl4ZXMgaW5wdXQgc291cmNlIHRvIHN0ZXJlbyBvdXRwdXRcbiAgICAgICAgdGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgdGhpcy5nYWluLmNoYW5uZWxDb3VudE1vZGUgPSBcImV4cGxpY2l0XCI7XG4gICAgICAgIHRoaXMuZ2Fpbi5jaGFubmVsQ291bnQgPSAyO1xuICAgICAgICB0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMuZ2Fpbik7XG5cbiAgICAgICAgLy8gc3BsaXQgdGhlIHN0ZXJlbyBvdXRwdXQgaW50byByZXNwZWN0aXZlIG1vbm8gY2hhbm5lbHNcbiAgICAgICAgdGhpcy5jaGFubmVsU3BsaXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDIpO1xuICAgICAgICB0aGlzLmdhaW4uY29ubmVjdCh0aGlzLmNoYW5uZWxTcGxpdCk7XG5cbiAgICAgICAgLy8gYW5hbHNlciBub2RlIGZvciBlYWNoIGNoYW5uZWxcbiAgICAgICAgdGhpcy5hbmFseXNlcnMgPSBbbnVsbCwgbnVsbF07XG4gICAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCAyOyBjaCsrKSB7XG4gICAgICAgICAgICBjb25zdCBhbmFseXNlciA9IHRoaXMuY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICAgICAgICAgICAgYW5hbHlzZXIuZmZ0U2l6ZSA9IHRoaXMuZmZ0U2l6ZTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbFNwbGl0LmNvbm5lY3QoYW5hbHlzZXIsIGNoKTtcbiAgICAgICAgICAgIHRoaXMuYW5hbHlzZXJzW2NoXSA9IGFuYWx5c2VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsbGVkIGV2ZXJ5IGZyYW1lLiBPdmVycmlkZSBhbmQgaW1wbGVtZW50IGFuYWx5c2VyIGNvZGVcbiAgICBwdWJsaWMgdXBkYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYW5hbHlzZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGFuYWx5c2VycyBub3QgcmVhZHkuIG5vdGhpbmcgdXBkYXRlXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRoaXMuZmZ0U2l6ZSk7XG4gICAgICAgIGZvciAobGV0IGNoID0gMDsgY2ggPCAyOyBjaCsrKSB7XG4gICAgICAgICAgICBjb25zdCB2aXNEYXRhID0gdGhpcy52aXNEYXRhW2NoICsgMV07XG4gICAgICAgICAgICBjb25zdCBhbmFseXNlciA9IHRoaXMuYW5hbHlzZXJzW2NoXTtcblxuICAgICAgICAgICAgYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoYnl0ZUJ1ZmZlcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpc0RhdGEuc3BlY3RydW0ubGVuZ3RoOyBpKyspIHsgLy8gc2NhbGUgdG8gMC0xIHJhbmdlXG4gICAgICAgICAgICAgICAgdmlzRGF0YS5zcGVjdHJ1bVtpXSA9IGJ5dGVCdWZmZXJbaV0gLyAyNTU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFuYWx5c2VyLmdldEJ5dGVUaW1lRG9tYWluRGF0YShieXRlQnVmZmVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzRGF0YS53YXZlZm9ybS5sZW5ndGg7IGkrKykgeyAvLyBzY2FsZSB0byAtMSB0byAxIHJhbmdlXG4gICAgICAgICAgICAgICAgdmlzRGF0YS53YXZlZm9ybVtpXSA9IChieXRlQnVmZmVyW2ldIC8gMjU1KSAqIDIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2VudGVyIGNoYW5uZWwgaXMgYXZlcmFnZSBvZiBsZWZ0IGFuZCByaWdodFxuICAgICAgICBjb25zdCBjZW50ZXJWaXNEYXRhID0gdGhpcy52aXNEYXRhWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbnRlclZpc0RhdGEuc3BlY3RydW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNlbnRlclZpc0RhdGEuc3BlY3RydW1baV0gPSAodGhpcy52aXNEYXRhWzFdLnNwZWN0cnVtW2ldIC8gMiArIHRoaXMudmlzRGF0YVsyXS5zcGVjdHJ1bVtpXSAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VudGVyVmlzRGF0YS53YXZlZm9ybS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2VudGVyVmlzRGF0YS53YXZlZm9ybVtpXSA9ICh0aGlzLnZpc0RhdGFbMV0ud2F2ZWZvcm1baV0gLyAyICsgdGhpcy52aXNEYXRhWzJdLndhdmVmb3JtW2ldIC8gMik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW1wbGUga2ljayBkZXRlY3Rpb25cbiAgICAgICAgdGhpcy5iZWF0ID0gZmFsc2U7XG4gICAgICAgIGxldCBwZWFrTGVmdCA9IDA7XG4gICAgICAgIGxldCBwZWFrUmlnaHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmZ0U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBwZWFrTGVmdCArPSBNYXRoLmFicyh0aGlzLnZpc0RhdGFbMV0ud2F2ZWZvcm1baV0pO1xuICAgICAgICAgICAgcGVha1JpZ2h0ICs9IE1hdGguYWJzKHRoaXMudmlzRGF0YVsyXS53YXZlZm9ybVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVhayA9IE1hdGgubWF4KHBlYWtMZWZ0LCBwZWFrUmlnaHQpIC8gdGhpcy5mZnRTaXplO1xuXG4gICAgICAgIGlmIChwZWFrID49IHRoaXMubW92aW5nVGhyZXNob2xkICYmIHBlYWsgPj0gdGhpcy50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHRoaXMubW92aW5nVGhyZXNob2xkID0gcGVhaztcbiAgICAgICAgICAgIHRoaXMuYmVhdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vdmluZ1RocmVzaG9sZCA9IHRoaXMubW92aW5nVGhyZXNob2xkICogKDEgLSB0aGlzLmRlY2F5KSArIHBlYWsgKiB0aGlzLmRlY2F5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZvciBXZWJ2cy5XZWJBdWRpb0FuYWx5c2VyI2Nvbm5lY3RUb05vZGUuIFRoaXMgY3JlYXRlcyBBdWRpbyBvYmplY3RcbiAgICAgKiBmb3IgdGhlIGF1ZGlvIGZpbGUgYW5kIGNvbm5lY3RzIHRoaXMgYW5hbHlzZXIgdG8gaXRzIG1lZGlhRWxlbWVudFNvdXJjZVxuICAgICAqIEBwYXJhbSBzb3VyY2Ugc291cmNlIGZvciB0aGUgYXVkaW8uIFVzZSBhbiBhdWRpbyB0YWcgZWxlbWVudCBvciBhIHVybFxuICAgICAqIEBwYXJhbSByZWFkeUZ1bmMgYSBjYWxsYmFjayB0aGF0J2xsIGJlIGNhbGxlZCB3aGVuIHJlYWR5IHRvIHBsYXlcbiAgICAgKi9cbiAgICBwdWJsaWMgbG9hZChzb3VyY2U6IEhUTUxNZWRpYUVsZW1lbnQgfCBzdHJpbmcsIHJlYWR5RnVuYyk6IEhUTUxNZWRpYUVsZW1lbnQge1xuICAgICAgICBsZXQgZWxlbWVudDogSFRNTE1lZGlhRWxlbWVudDtcbiAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxNZWRpYUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBzb3VyY2U7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UoZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gbmV3IEF1ZGlvKCk7XG4gICAgICAgICAgICBlbGVtZW50LnNyYyA9IHNvdXJjZTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZShlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9uQ2FuUGxheSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRvTm9kZSh0aGlzLnNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChyZWFkeUZ1bmMpIHtcbiAgICAgICAgICAgICAgICByZWFkeUZ1bmMoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIiwgb25DYW5QbGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGVsZW1lbnQucmVhZHlTdGF0ZSA8IDMpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIiwgb25DYW5QbGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uQ2FuUGxheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhcnJheSBvZiB3YXZlZm9ybSB2YWx1ZXNcbiAgICBwdWJsaWMgZ2V0V2F2ZWZvcm0oY2hhbm5lbDogQ2hhbm5lbHMgPSBDaGFubmVscy5DRU5URVIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzRGF0YVtjaGFubmVsXS53YXZlZm9ybTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGFycmF5IG9mIHNwZWN0cnVtIHZhbHVlc1xuICAgIHB1YmxpYyBnZXRTcGVjdHJ1bShjaGFubmVsOiBDaGFubmVscyA9IENoYW5uZWxzLkNFTlRFUikge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNEYXRhW2NoYW5uZWxdLnNwZWN0cnVtO1xuICAgIH1cblxuICAgIC8vIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIGEgYmVhdFxuICAgIC8vIGlzIGluIHByb2dyZXNzIG9yIG5vdFxuICAgIHB1YmxpYyBpc0JlYXQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlYXQ7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2FuYWx5c2VyL1dlYkF1ZGlvQW5hbHlzZXIudHMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFRQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExQkE7QUE0QkE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBOUJBO0FBZ0NBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBWkE7QUFjQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7Ozs7Ozs7O0FDM1BBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQWdDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTtBQUFBO0FBeURBOzs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQWxGQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBc0ZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBNU1BOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUF3TEE7QUFBQTtBQTVOQTs7Ozs7Ozs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF5SkE7OztBQUdBO0FBQ0E7QUF5QkE7Ozs7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBV0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUtBO0FBQ0E7QUFNQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTliQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEwYkE7QUFBQTtBQWhjQTs7Ozs7Ozs7O0FDbEtBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hCQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwQ0E7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcERBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ0xBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNiQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9EQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1QkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUEvQkE7QUFtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDOWdCQTtBQUdBOztBQUVBO0FBQ0E7QUFNQTs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7OztBQ2pFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEJBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ0xBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9CQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3QkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2QkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzlCQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNiQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaEJBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaENBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1QkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFCQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyQkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25CQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25DQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25CQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTEE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEJBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2JBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdCQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1QkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0JBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBUUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUF3SEE7QUF2R0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFBQTs7Ozs7Ozs7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JCQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1RBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZEE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNaQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBd0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7Ozs7O0FDdEpBO0FBR0E7Ozs7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXNCQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdCQTs7Ozs7Ozs7QUNuQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFLQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6QkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4QkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1ZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuQkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ05BO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNOQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNMQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcENBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0JBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0JBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNsQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNsRkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25CQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9DQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2JBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkJBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNiQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzlCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4Q0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2REE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdkVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFKQTtBQU1BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUxBOzs7Ozs7OztBQ3BEQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7QUNBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBU0E7OztBQUdBO0FBQ0E7QUFhQTs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6UEE7QUFFQTtBQVlBOztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7Ozs7QUNyQ0E7Ozs7QUFJQTtBQUNBO0FBQUE7QUF1QkE7QUFBQTtBQUFBOzs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFvQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQTtBQUNBO0FBQUE7QUEyQkE7OztBQUdBO0FBQ0E7QUFBQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFwWEE7O0FBRUE7QUFDQTtBQWtYQTtBQUFBO0FBdFhBOzs7Ozs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNaQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbENBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbEJBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNiQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckJBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0JBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0QkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2RBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JCQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoQkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0RBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0JBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ0xBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkJBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDbENBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ05BO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1RUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxQkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFCQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6QkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQzNCQTs7Ozs7QUFLQTtBQUNBO0FBSUE7Ozs7QUFJQTtBQUNBO0FBUkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOURBO0FBRUE7QUFHQTtBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXdEQTs7Ozs7QUFLQTtBQUNBO0FBQUE7QUE0QkE7QUFBQTtBQUxBOztBQU9BO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQTNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEySEE7QUFBQTtBQTdJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBS0E7Ozs7QUFJQTtBQUNBO0FBQUE7QUFJQTs7QUFFQTtBQUNBO0FBQUE7QUFFQTs7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7O0FDakxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4REE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25CQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvVUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEJBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNmQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0JBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JCQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3REE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaENBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0JBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4Q0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNIQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbEpBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0JBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNiQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pHQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0JBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0QkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1QkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6RkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNsQkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbEJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3ZDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcENBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqM0RBO0FBRUE7QUFvQkE7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQUE7QUFtQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXNFQTtBQUFBO0FBbEZBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BDQTtBQUVBO0FBa0JBO0FBQ0E7QUFDQTtBQUFBO0FBa0JBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXdDQTtBQUFBO0FBcERBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUVBO0FBQ0E7QUFTQTtBQUNBO0FBQUE7QUFtQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXlEQTtBQUFBO0FBcEVBOzs7Ozs7OztBQ2JBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6Q0E7QUFFQTtBQUVBO0FBRUE7QUFXQTtBQUNBO0FBQUE7QUEyQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUE3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWlIQTtBQUFBO0FBL0hBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUVBO0FBRUE7QUFFQTtBQVFBO0FBQ0E7QUFBQTtBQWtCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQVdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQS9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXVGQTtBQUFBO0FBakdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFtR0E7O0FBRUE7QUFDQTtBQUFBO0FBOENBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBL1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFvWEE7QUFBQTtBQWpaQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFtQ0E7QUFDQTtBQUFBO0FBcUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBTUE7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUExU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFzUkE7QUFBQTtBQTVTQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXVCQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFRQTtBQUFBO0FBUEE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7O0FDN01BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUVBO0FBRUE7QUFnQkE7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQWVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWtEQTtBQUFBO0FBM0RBOzs7Ozs7OztBQ3JDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVCQTtBQUVBO0FBRUE7QUF3QkE7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUFBO0FBcUJBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBK0VBO0FBQUE7QUE1RkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUErQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQUE7QUFnQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW9KQTtBQUFBO0FBMUtBOzs7Ozs7OztBQ3ZGQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9DQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEJBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3hDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUE2QkE7O0FBRUE7QUFDQTtBQUFBO0FBd0JBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFpR0E7QUFBQTtBQW5IQTs7Ozs7Ozs7QUNwREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBOEVBOztBQUVBO0FBQ0E7QUFBQTtBQXVDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFjQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBa0JBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBeE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTRMQTtBQUFBO0FBMU5BO0FBNE5BO0FBQ0E7QUFDQTtBQU1BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBaUJBO0FBQUE7QUFDQTtBQXlCQTtBQUFBO0FBQ0E7QUFLQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pZQTtBQUVBO0FBQ0E7QUFPQTtBQUNBO0FBQUE7QUFrQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQS9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXVDQTtBQUFBO0FBakRBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1hBO0FBRUE7QUFFQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUEzQkE7QUFDQTtBQTJCQTtBQUFBO0FBN0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0pBO0FBRUE7QUFFQTtBQWVBO0FBQ0E7QUFBQTtBQTBCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQS9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZ0xBO0FBQUE7QUFqTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEJBO0FBRUE7QUFFQTtBQVVBO0FBQUE7QUFtQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBc0VBO0FBQUE7QUFsRkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZEE7QUFFQTtBQUVBO0FBUUE7QUFDQTtBQUFBO0FBaUJBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTREQTtBQUFBO0FBdkVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2JBO0FBRUE7QUFZQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7Ozs7QUNyQ0E7OztBQUdBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUFBO0FBTEE7QUFLQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0NBO0FBQ0E7QUFDQTtBQThCQTs7QUFFQTtBQUNBO0FBQUE7QUFhQTs7O0FBR0E7QUFDQTtBQUFBO0FBYkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7OztBIiwic291cmNlUm9vdCI6IiJ9